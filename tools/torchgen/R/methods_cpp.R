# Functions related to the cpp Tensor methods generation.

method_cpp <- function() {

  methods <- tensor_methods() %>%
    purrr::discard(~.x$name %in% method_cpp_exceptions()) %>%
    purrr::map_chr(method_cpp_code) %>%
    purrr::map_chr(~paste("// [[Rcpp::export]]\n", .x))

  code <- paste(
    c("// Autogenerated file", cpp_deps(), paste(methods)),
    collapse = "\n\n"
  )

  code
}


#' Creates the cpp code for a method.
#'
#' @param method a single element of the [declarations()] list.
#'
method_cpp_code <- function(method) {
  glue::glue("
     {method_cpp_return_type(method)} {method_cpp_name(method)} ({method_cpp_signature(method)}) {{
       {method_cpp_body(method)}
     }};
  ")
}

#' Gets the return type of the cpp function.
#'
#' @inheritParams method_cpp_code
method_cpp_return_type <- function(method) {

  if (length(method$returns) == 1) {

    dynamic_type <- method$returns[[1]]$dynamic_type

    if (dynamic_type == "Tensor") {

      return("Rcpp::XPtr<torch::Tensor>")

    } else if (dynamic_type %in% c("void", "bool", "double", "int64_t")) {

      return(dynamic_type)

    } else if (dynamic_type == "TensorList") {

      return("Rcpp::List")

    } else if (dynamic_type == "Scalar") {

      return("SEXP")
    } else if (dynamic_type == "ScalarType") {

      return("Rcpp::XPtr<torch::ScalarType>")

    }

  } else if (all(purrr::map_chr(method$returns, ~.x$dynamic_type) %in% c("Tensor", "TensorList", "int64_t", "double", "Scalar"))) {

    return("Rcpp::List")

  }

  stop(
    "Don't know how to deal with the return type: ",
    dput(method$returns),
    call. = FALSE
  )

}

#' Makes the name of the cpp function.
#'
#' @inheritParams method_cpp_code
method_cpp_name <- function(method) {
  glue::glue("torch_{method$name}_{hash_arguments(method$arguments)}")
}

#' Makes the signature of the cpp function.
#'
#' @inheritParams method_cpp_code
method_cpp_signature <- function(method) {

  names <- method$arguments %>%
    purrr::map_chr(~.x$name) %>%
    stringr::str_replace_all("FALSE", "False")

  types <- method$arguments %>%
    purrr::map_chr(cpp_argument_type)

  paste(glue::glue("{types[!is.na(types)]} {names[!is.na(types)]}"), collapse = ", ")
}

#' Returns the code to create an `out` variable using a method and it's
#' arguments.
#'
method_cpp_create_out <- function(method) {

  arguments <- method$arguments[-1] %>%
    purrr::map_chr(cpp_use_argument) %>%
    purrr::discard(is.na) %>%
    paste(collapse = ", ")

  out <- glue::glue("self->{method$name}({arguments});")

  if (method$returns[[1]]$dynamic_type != "void")
    out <- paste0("auto r_out = ", out)

  out
}

#' Makes the body of the cpp function.
#'
#' @inheritParams method_cpp_code
method_cpp_body <- function(method) {
  glue::glue(
    "
    {method_cpp_create_out(method)}
    {cpp_return_statement(method$returns)}
    "
  )
}

#' Get the exceptions
method_cpp_exceptions <- function() {
  c("qscheme", "item", "polygamma", "set_quantizer_")
}

