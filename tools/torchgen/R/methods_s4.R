
method_s4 <- function() {

  methods <- tensor_methods() %>%
    purrr::discard(~.x$name %in% method_s4_exceptions())

  tm <- tensor_methods()

  unq_names <- methods %>%
    purrr::map_chr(~.x$name) %>%
    unique() %>%
    purrr::map(~declarations_with_name(tm, .x))

  generics <- unq_names %>%
    purrr::map_chr(generic_s4_code)

  impl <- methods %>%
    purrr::map_chr(method_s4_code)


  code <- paste(
    c("# Autogenerated file", generics, impl),
    collapse = "\n\n"
  )

  code
}


#' Generates the S4 generic definition
#'
#' @param methods the methods list. something like
#'  `tensor_methods() %>% declaration_with_name("abs")`
#'
generic_s4_code <- function(methods) {

  possible_names <- get_possible_argument_names(methods)
  nm <- method_s4_generic_name(methods)

  glue::glue(
    'setGeneric(
      "{nm}",
      function({paste(possible_names, collapse =", ")}) standardGeneric("{nm}")
     )'
  )
}

#' Generates the definition of an S4 method
#'
#' @inheritParams method_cpp_code
#'
method_s4_code <- function(method) {
  glue::glue(
"
setMethod(
 f = '{method_s4_generic_name(method)}',
 signature = {method_s4_signature(method)},
 definition = function({method_s4_impl_signature(method)}) {{
  {method_s4_impl_body(method)}
 }})
"
  )
}

#' Get's the name of the generic function corresponding to the method
#'
#' @param method a single method or a list of methods.
#'
method_s4_generic_name <- function(method) {

  nm <- method[["name"]]

  if (is.null(nm))
    nm <- method[[1]]$name

  glue::glue("torch_{nm}_")
}

#' Returns a tibble of argument names and types of methods.
#' Already discarding argument names with `NA` that wound't be
#' converted.
#'
#' @inheritParams method_cpp_code
#'
method_s4_argument_names_and_types <- function(method) {

  argument_types <- method$arguments %>%
    purrr::map_chr(argument_type_to_r)
  argument_names <- method$arguments %>%
    purrr::map_chr(~.x$name) %>%
    stringr::str_replace_all("FALSE", "False")

  # discard NA types
  nas <- which(is.na(argument_types))

  if (length(nas) > 0) {
    argument_types <- argument_types[-nas]
    argument_names <- argument_names[-nas]
  }

  tibble::tibble(
   names = argument_names,
   types = argument_types
  )
}

#' Creates the signature as required by S4 methods in R
#' See [methods::setMethod()]'s `signature` argument.
#'
#' @inheritParams method_cpp_code
#'
method_s4_signature <- function(method, methods = tensor_methods()) {

  arguments <- method_s4_argument_names_and_types(method)

  argument_names <- arguments$names
  argument_types <- arguments$types

  # find arguments that are present in the generic but not in the signature
  all_args <- methods %>%
    declarations_with_name(method$name) %>%
    get_possible_argument_names()
  missing_args <- all_args[!all_args %in% argument_names]

  argument_names <- c(argument_names, missing_args)
  argument_types <- c(argument_types, rep("missing", length(missing_args)))

  args <- glue::glue('{argument_names} = "{argument_types}"') %>%
    glue::glue_collapse(sep = ", ")

  if (length(args) == 0)
    return("list()")

  glue::glue("list({args})")
}

method_s4_impl_signature <- function(method) {

  arguments <- method_s4_argument_names_and_types(method)
  arguments$names %>%
    stringr::str_replace_all("FALSE", "False") %>%
    paste(collapse = ", ")

}

method_s4_impl_body <- function(method, fun_name = method_cpp_name) {
  glue::glue("{fun_name(method)}({method_s4_impl_signature(method)})")
}

method_s4_exceptions <- function() {
  NULL
}

