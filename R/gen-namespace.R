# This file is autogenerated. Do not modify it by hand.

torch___and__ <- function(self, other) {
  args <- rlang::env_get_list(nms = c("self", "other"))
expected_types <- list(self = "Tensor", other = c("Scalar", "Tensor"))
nd_args <- c("self", "other")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = '__and__',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch___lshift__ <- function(self, other) {
  args <- rlang::env_get_list(nms = c("self", "other"))
expected_types <- list(self = "Tensor", other = c("Scalar", "Tensor"))
nd_args <- c("self", "other")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = '__lshift__',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch___or__ <- function(self, other) {
  args <- rlang::env_get_list(nms = c("self", "other"))
expected_types <- list(self = "Tensor", other = c("Scalar", "Tensor"))
nd_args <- c("self", "other")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = '__or__',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch___rshift__ <- function(self, other) {
  args <- rlang::env_get_list(nms = c("self", "other"))
expected_types <- list(self = "Tensor", other = c("Scalar", "Tensor"))
nd_args <- c("self", "other")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = '__rshift__',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch___xor__ <- function(self, other) {
  args <- rlang::env_get_list(nms = c("self", "other"))
expected_types <- list(self = "Tensor", other = c("Scalar", "Tensor"))
nd_args <- c("self", "other")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = '__xor__',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch__adaptive_avg_pool2d <- function(self, output_size) {
  args <- rlang::env_get_list(nms = c("self", "output_size"))
expected_types <- list(self = "Tensor", output_size = "IntArrayRef")
nd_args <- c("self", "output_size")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = '_adaptive_avg_pool2d',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch__adaptive_avg_pool2d_backward <- function(grad_output, self) {
  args <- rlang::env_get_list(nms = c("grad_output", "self"))
expected_types <- list(grad_output = "Tensor", self = "Tensor")
nd_args <- c("grad_output", "self")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = '_adaptive_avg_pool2d_backward',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch__addr <- function(self, vec1, vec2, beta = 1, alpha = 1) {
  args <- rlang::env_get_list(nms = c("self", "vec1", "vec2", "beta", "alpha"))
expected_types <- list(self = "Tensor", vec1 = "Tensor", vec2 = "Tensor", beta = "Scalar", 
    alpha = "Scalar")
nd_args <- c("self", "vec1", "vec2")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = '_addr',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch__addr_ <- function(self, vec1, vec2, beta = 1, alpha = 1) {
  args <- rlang::env_get_list(nms = c("self", "vec1", "vec2", "beta", "alpha"))
expected_types <- list(self = "Tensor", vec1 = "Tensor", vec2 = "Tensor", beta = "Scalar", 
    alpha = "Scalar")
nd_args <- c("self", "vec1", "vec2")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = '_addr_',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch__addr_out <- function(out, self, vec1, vec2, beta = 1, alpha = 1) {
  args <- rlang::env_get_list(nms = c("out", "self", "vec1", "vec2", "beta", "alpha"))
expected_types <- list(out = "Tensor", self = "Tensor", vec1 = "Tensor", vec2 = "Tensor", 
    beta = "Scalar", alpha = "Scalar")
nd_args <- c("out", "self", "vec1", "vec2")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = '_addr_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch__amp_non_finite_check_and_unscale_ <- function(self, found_inf, inv_scale) {
  args <- rlang::env_get_list(nms = c("self", "found_inf", "inv_scale"))
expected_types <- list(self = "Tensor", found_inf = "Tensor", inv_scale = "Tensor")
nd_args <- c("self", "found_inf", "inv_scale")
return_types <- list(list("void"))
call_c_function(
fun_name = '_amp_non_finite_check_and_unscale_',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch__amp_update_scale <- function(growth_tracker, current_scale, found_inf, scale_growth_factor, scale_backoff_factor, growth_interval) {
  args <- rlang::env_get_list(nms = c("growth_tracker", "current_scale", "found_inf", "scale_growth_factor", "scale_backoff_factor", "growth_interval"))
expected_types <- list(growth_tracker = "Tensor", current_scale = "Tensor", found_inf = "Tensor", 
    scale_growth_factor = "double", scale_backoff_factor = "double", 
    growth_interval = "int64_t")
nd_args <- c("growth_tracker", "current_scale", "found_inf", "scale_growth_factor", 
"scale_backoff_factor", "growth_interval")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = '_amp_update_scale',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch__baddbmm_mkl_ <- function(self, batch1, batch2, beta = 1, alpha = 1) {
  args <- rlang::env_get_list(nms = c("self", "batch1", "batch2", "beta", "alpha"))
expected_types <- list(self = "Tensor", batch1 = "Tensor", batch2 = "Tensor", beta = "Scalar", 
    alpha = "Scalar")
nd_args <- c("self", "batch1", "batch2")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = '_baddbmm_mkl_',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch__batch_norm_impl_index <- function(input, weight, bias, running_mean, running_var, training, momentum, eps, cudnn_enabled) {
  args <- rlang::env_get_list(nms = c("input", "weight", "bias", "running_mean", "running_var", "training", "momentum", "eps", "cudnn_enabled"))
expected_types <- list(input = "Tensor", weight = "Tensor", bias = "Tensor", running_mean = "Tensor", 
    running_var = "Tensor", training = "bool", momentum = "double", 
    eps = "double", cudnn_enabled = "bool")
nd_args <- c("input", "weight", "bias", "running_mean", "running_var", "training", 
"momentum", "eps", "cudnn_enabled")
return_types <- list(list("Tensor", "Tensor", "Tensor", "Tensor", "int64_t"))
call_c_function(
fun_name = '_batch_norm_impl_index',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch__batch_norm_impl_index_backward <- function(impl_index, input, grad_output, weight, running_mean, running_var, save_mean, save_var_transform, train, eps, output_mask, reservedSpace) {
  args <- rlang::env_get_list(nms = c("impl_index", "input", "grad_output", "weight", "running_mean", "running_var", "save_mean", "save_var_transform", "train", "eps", "output_mask", "reservedSpace"))
expected_types <- list(impl_index = "int64_t", input = "Tensor", grad_output = "Tensor", 
    weight = "Tensor", running_mean = "Tensor", running_var = "Tensor", 
    save_mean = "Tensor", save_var_transform = "Tensor", train = "bool", 
    eps = "double", output_mask = "std::array<bool,3>", reservedSpace = "Tensor")
nd_args <- c("impl_index", "input", "grad_output", "weight", "running_mean", 
"running_var", "save_mean", "save_var_transform", "train", "eps", 
"output_mask", "reservedSpace")
return_types <- list(list("Tensor", "Tensor", "Tensor"))
call_c_function(
fun_name = '_batch_norm_impl_index_backward',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch__cast_Byte <- function(self, non_blocking = FALSE) {
  args <- rlang::env_get_list(nms = c("self", "non_blocking"))
expected_types <- list(self = "Tensor", non_blocking = "bool")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = '_cast_Byte',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch__cast_Char <- function(self, non_blocking = FALSE) {
  args <- rlang::env_get_list(nms = c("self", "non_blocking"))
expected_types <- list(self = "Tensor", non_blocking = "bool")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = '_cast_Char',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch__cast_Double <- function(self, non_blocking = FALSE) {
  args <- rlang::env_get_list(nms = c("self", "non_blocking"))
expected_types <- list(self = "Tensor", non_blocking = "bool")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = '_cast_Double',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch__cast_Float <- function(self, non_blocking = FALSE) {
  args <- rlang::env_get_list(nms = c("self", "non_blocking"))
expected_types <- list(self = "Tensor", non_blocking = "bool")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = '_cast_Float',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch__cast_Half <- function(self, non_blocking = FALSE) {
  args <- rlang::env_get_list(nms = c("self", "non_blocking"))
expected_types <- list(self = "Tensor", non_blocking = "bool")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = '_cast_Half',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch__cast_Int <- function(self, non_blocking = FALSE) {
  args <- rlang::env_get_list(nms = c("self", "non_blocking"))
expected_types <- list(self = "Tensor", non_blocking = "bool")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = '_cast_Int',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch__cast_Long <- function(self, non_blocking = FALSE) {
  args <- rlang::env_get_list(nms = c("self", "non_blocking"))
expected_types <- list(self = "Tensor", non_blocking = "bool")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = '_cast_Long',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch__cast_Short <- function(self, non_blocking = FALSE) {
  args <- rlang::env_get_list(nms = c("self", "non_blocking"))
expected_types <- list(self = "Tensor", non_blocking = "bool")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = '_cast_Short',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch__cat <- function(tensors, dim = 0) {
  args <- rlang::env_get_list(nms = c("tensors", "dim"))
expected_types <- list(tensors = "TensorList", dim = "int64_t")
nd_args <- "tensors"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = '_cat',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch__cat_out <- function(out, tensors, dim = 0) {
  args <- rlang::env_get_list(nms = c("out", "tensors", "dim"))
expected_types <- list(out = "Tensor", tensors = "TensorList", dim = "int64_t")
nd_args <- c("out", "tensors")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = '_cat_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch__cdist_backward <- function(grad, x1, x2, p, cdist) {
  args <- rlang::env_get_list(nms = c("grad", "x1", "x2", "p", "cdist"))
expected_types <- list(grad = "Tensor", x1 = "Tensor", x2 = "Tensor", p = "double", 
    cdist = "Tensor")
nd_args <- c("grad", "x1", "x2", "p", "cdist")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = '_cdist_backward',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch__cdist_forward <- function(x1, x2, p, compute_mode) {
  args <- rlang::env_get_list(nms = c("x1", "x2", "p", "compute_mode"))
expected_types <- list(x1 = "Tensor", x2 = "Tensor", p = "double", compute_mode = "int64_t")
nd_args <- c("x1", "x2", "p", "compute_mode")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = '_cdist_forward',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch__cholesky_helper <- function(self, upper) {
  args <- rlang::env_get_list(nms = c("self", "upper"))
expected_types <- list(self = "Tensor", upper = "bool")
nd_args <- c("self", "upper")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = '_cholesky_helper',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch__cholesky_solve_helper <- function(self, A, upper) {
  args <- rlang::env_get_list(nms = c("self", "A", "upper"))
expected_types <- list(self = "Tensor", A = "Tensor", upper = "bool")
nd_args <- c("self", "A", "upper")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = '_cholesky_solve_helper',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch__convolution <- function(input, weight, bias, stride, padding, dilation, transposed, output_padding, groups, benchmark, deterministic, cudnn_enabled) {
  args <- rlang::env_get_list(nms = c("input", "weight", "bias", "stride", "padding", "dilation", "transposed", "output_padding", "groups", "benchmark", "deterministic", "cudnn_enabled"))
expected_types <- list(input = "Tensor", weight = "Tensor", bias = "Tensor", stride = "IntArrayRef", 
    padding = "IntArrayRef", dilation = "IntArrayRef", transposed = "bool", 
    output_padding = "IntArrayRef", groups = "int64_t", benchmark = "bool", 
    deterministic = "bool", cudnn_enabled = "bool")
nd_args <- c("input", "weight", "bias", "stride", "padding", "dilation", 
"transposed", "output_padding", "groups", "benchmark", "deterministic", 
"cudnn_enabled")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = '_convolution',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch__convolution_double_backward <- function(ggI, ggW, ggb, gO, weight, self, stride, padding, dilation, transposed, output_padding, groups, benchmark, deterministic, cudnn_enabled, output_mask) {
  args <- rlang::env_get_list(nms = c("ggI", "ggW", "ggb", "gO", "weight", "self", "stride", "padding", "dilation", "transposed", "output_padding", "groups", "benchmark", "deterministic", "cudnn_enabled", "output_mask"))
expected_types <- list(ggI = "Tensor", ggW = "Tensor", ggb = "Tensor", gO = "Tensor", 
    weight = "Tensor", self = "Tensor", stride = "IntArrayRef", 
    padding = "IntArrayRef", dilation = "IntArrayRef", transposed = "bool", 
    output_padding = "IntArrayRef", groups = "int64_t", benchmark = "bool", 
    deterministic = "bool", cudnn_enabled = "bool", output_mask = "std::array<bool,3>")
nd_args <- c("ggI", "ggW", "ggb", "gO", "weight", "self", "stride", "padding", 
"dilation", "transposed", "output_padding", "groups", "benchmark", 
"deterministic", "cudnn_enabled", "output_mask")
return_types <- list(list("Tensor", "Tensor", "Tensor"))
call_c_function(
fun_name = '_convolution_double_backward',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch__convolution_nogroup <- function(input, weight, bias, stride, padding, dilation, transposed, output_padding) {
  args <- rlang::env_get_list(nms = c("input", "weight", "bias", "stride", "padding", "dilation", "transposed", "output_padding"))
expected_types <- list(input = "Tensor", weight = "Tensor", bias = "Tensor", stride = "IntArrayRef", 
    padding = "IntArrayRef", dilation = "IntArrayRef", transposed = "bool", 
    output_padding = "IntArrayRef")
nd_args <- c("input", "weight", "bias", "stride", "padding", "dilation", 
"transposed", "output_padding")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = '_convolution_nogroup',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch__copy_from <- function(self, dst, non_blocking = FALSE) {
  args <- rlang::env_get_list(nms = c("self", "dst", "non_blocking"))
expected_types <- list(self = "Tensor", dst = "Tensor", non_blocking = "bool")
nd_args <- c("self", "dst")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = '_copy_from',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch__ctc_loss <- function(log_probs, targets, input_lengths, target_lengths, blank = 0, zero_infinity = FALSE) {
  args <- rlang::env_get_list(nms = c("log_probs", "targets", "input_lengths", "target_lengths", "blank", "zero_infinity"))
expected_types <- list(log_probs = "Tensor", targets = "Tensor", input_lengths = "IntArrayRef", 
    target_lengths = "IntArrayRef", blank = "int64_t", zero_infinity = "bool")
nd_args <- c("log_probs", "targets", "input_lengths", "target_lengths")
return_types <- list(list("Tensor", "Tensor"))
call_c_function(
fun_name = '_ctc_loss',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch__ctc_loss_backward <- function(grad, log_probs, targets, input_lengths, target_lengths, neg_log_likelihood, log_alpha, blank, zero_infinity = FALSE) {
  args <- rlang::env_get_list(nms = c("grad", "log_probs", "targets", "input_lengths", "target_lengths", "neg_log_likelihood", "log_alpha", "blank", "zero_infinity"))
expected_types <- list(grad = "Tensor", log_probs = "Tensor", targets = "Tensor", 
    input_lengths = "IntArrayRef", target_lengths = "IntArrayRef", 
    neg_log_likelihood = "Tensor", log_alpha = "Tensor", blank = "int64_t", 
    zero_infinity = "bool")
nd_args <- c("grad", "log_probs", "targets", "input_lengths", "target_lengths", 
"neg_log_likelihood", "log_alpha", "blank")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = '_ctc_loss_backward',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch__cudnn_ctc_loss <- function(log_probs, targets, input_lengths, target_lengths, blank, deterministic, zero_infinity) {
  args <- rlang::env_get_list(nms = c("log_probs", "targets", "input_lengths", "target_lengths", "blank", "deterministic", "zero_infinity"))
expected_types <- list(log_probs = "Tensor", targets = "Tensor", input_lengths = "IntArrayRef", 
    target_lengths = "IntArrayRef", blank = "int64_t", deterministic = "bool", 
    zero_infinity = "bool")
nd_args <- c("log_probs", "targets", "input_lengths", "target_lengths", 
"blank", "deterministic", "zero_infinity")
return_types <- list(list("Tensor", "Tensor"))
call_c_function(
fun_name = '_cudnn_ctc_loss',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch__cudnn_init_dropout_state <- function(dropout, train, dropout_seed, options) {
  args <- rlang::env_get_list(nms = c("dropout", "train", "dropout_seed", "options"))
expected_types <- list(dropout = "double", train = "bool", dropout_seed = "int64_t", 
    options = "TensorOptions")
nd_args <- c("dropout", "train", "dropout_seed", "options")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = '_cudnn_init_dropout_state',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch__cudnn_rnn <- function(input, weight, weight_stride0, weight_buf, hx, cx, mode, hidden_size, num_layers, batch_first, dropout, train, bidirectional, batch_sizes, dropout_state) {
  args <- rlang::env_get_list(nms = c("input", "weight", "weight_stride0", "weight_buf", "hx", "cx", "mode", "hidden_size", "num_layers", "batch_first", "dropout", "train", "bidirectional", "batch_sizes", "dropout_state"))
expected_types <- list(input = "Tensor", weight = "TensorList", weight_stride0 = "int64_t", 
    weight_buf = "Tensor", hx = "Tensor", cx = "Tensor", mode = "int64_t", 
    hidden_size = "int64_t", num_layers = "int64_t", batch_first = "bool", 
    dropout = "double", train = "bool", bidirectional = "bool", 
    batch_sizes = "IntArrayRef", dropout_state = "Tensor")
nd_args <- c("input", "weight", "weight_stride0", "weight_buf", "hx", "cx", 
"mode", "hidden_size", "num_layers", "batch_first", "dropout", 
"train", "bidirectional", "batch_sizes", "dropout_state")
return_types <- list(list("Tensor", "Tensor", "Tensor", "Tensor", "Tensor"))
call_c_function(
fun_name = '_cudnn_rnn',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch__cudnn_rnn_backward <- function(input, weight, weight_stride0, weight_buf, hx, cx, output, grad_output, grad_hy, grad_cy, mode, hidden_size, num_layers, batch_first, dropout, train, bidirectional, batch_sizes, dropout_state, reserve, output_mask) {
  args <- rlang::env_get_list(nms = c("input", "weight", "weight_stride0", "weight_buf", "hx", "cx", "output", "grad_output", "grad_hy", "grad_cy", "mode", "hidden_size", "num_layers", "batch_first", "dropout", "train", "bidirectional", "batch_sizes", "dropout_state", "reserve", "output_mask"))
expected_types <- list(input = "Tensor", weight = "TensorList", weight_stride0 = "int64_t", 
    weight_buf = "Tensor", hx = "Tensor", cx = "Tensor", output = "Tensor", 
    grad_output = "Tensor", grad_hy = "Tensor", grad_cy = "Tensor", 
    mode = "int64_t", hidden_size = "int64_t", num_layers = "int64_t", 
    batch_first = "bool", dropout = "double", train = "bool", 
    bidirectional = "bool", batch_sizes = "IntArrayRef", dropout_state = "Tensor", 
    reserve = "Tensor", output_mask = "std::array<bool,4>")
nd_args <- c("input", "weight", "weight_stride0", "weight_buf", "hx", "cx", 
"output", "grad_output", "grad_hy", "grad_cy", "mode", "hidden_size", 
"num_layers", "batch_first", "dropout", "train", "bidirectional", 
"batch_sizes", "dropout_state", "reserve", "output_mask")
return_types <- list(list("Tensor", "Tensor", "Tensor", "TensorList"))
call_c_function(
fun_name = '_cudnn_rnn_backward',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch__cudnn_rnn_flatten_weight <- function(weight_arr, weight_stride0, input_size, mode, hidden_size, num_layers, batch_first, bidirectional) {
  args <- rlang::env_get_list(nms = c("weight_arr", "weight_stride0", "input_size", "mode", "hidden_size", "num_layers", "batch_first", "bidirectional"))
expected_types <- list(weight_arr = "TensorList", weight_stride0 = "int64_t", input_size = "int64_t", 
    mode = "int64_t", hidden_size = "int64_t", num_layers = "int64_t", 
    batch_first = "bool", bidirectional = "bool")
nd_args <- c("weight_arr", "weight_stride0", "input_size", "mode", "hidden_size", 
"num_layers", "batch_first", "bidirectional")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = '_cudnn_rnn_flatten_weight',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch__cufft_clear_plan_cache <- function(device_index) {
  args <- rlang::env_get_list(nms = c("device_index"))
expected_types <- list(device_index = "int64_t")
nd_args <- "device_index"
return_types <- list(list("void"))
call_c_function(
fun_name = '_cufft_clear_plan_cache',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch__cufft_get_plan_cache_max_size <- function(device_index) {
  args <- rlang::env_get_list(nms = c("device_index"))
expected_types <- list(device_index = "int64_t")
nd_args <- "device_index"
return_types <- list(list('int64_t'))
call_c_function(
fun_name = '_cufft_get_plan_cache_max_size',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch__cufft_get_plan_cache_size <- function(device_index) {
  args <- rlang::env_get_list(nms = c("device_index"))
expected_types <- list(device_index = "int64_t")
nd_args <- "device_index"
return_types <- list(list('int64_t'))
call_c_function(
fun_name = '_cufft_get_plan_cache_size',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch__cufft_set_plan_cache_max_size <- function(device_index, max_size) {
  args <- rlang::env_get_list(nms = c("device_index", "max_size"))
expected_types <- list(device_index = "int64_t", max_size = "int64_t")
nd_args <- c("device_index", "max_size")
return_types <- list(list("void"))
call_c_function(
fun_name = '_cufft_set_plan_cache_max_size',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch__cummax_helper <- function(self, values, indices, dim) {
  args <- rlang::env_get_list(nms = c("self", "values", "indices", "dim"))
expected_types <- list(self = "Tensor", values = "Tensor", indices = "Tensor", 
    dim = "int64_t")
nd_args <- c("self", "values", "indices", "dim")
return_types <- list(list("void"))
call_c_function(
fun_name = '_cummax_helper',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch__cummin_helper <- function(self, values, indices, dim) {
  args <- rlang::env_get_list(nms = c("self", "values", "indices", "dim"))
expected_types <- list(self = "Tensor", values = "Tensor", indices = "Tensor", 
    dim = "int64_t")
nd_args <- c("self", "values", "indices", "dim")
return_types <- list(list("void"))
call_c_function(
fun_name = '_cummin_helper',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch__cumprod <- function(self, dim) {
  args <- rlang::env_get_list(nms = c("self", "dim"))
expected_types <- list(self = "Tensor", dim = "int64_t")
nd_args <- c("self", "dim")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = '_cumprod',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch__cumprod_out <- function(out, self, dim) {
  args <- rlang::env_get_list(nms = c("out", "self", "dim"))
expected_types <- list(out = "Tensor", self = "Tensor", dim = "int64_t")
nd_args <- c("out", "self", "dim")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = '_cumprod_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch__cumsum <- function(self, dim) {
  args <- rlang::env_get_list(nms = c("self", "dim"))
expected_types <- list(self = "Tensor", dim = "int64_t")
nd_args <- c("self", "dim")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = '_cumsum',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch__cumsum_out <- function(out, self, dim) {
  args <- rlang::env_get_list(nms = c("out", "self", "dim"))
expected_types <- list(out = "Tensor", self = "Tensor", dim = "int64_t")
nd_args <- c("out", "self", "dim")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = '_cumsum_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch__debug_has_internal_overlap <- function(self) {
  args <- rlang::env_get_list(nms = c("self"))
expected_types <- list(self = "Tensor")
nd_args <- "self"
return_types <- list(list('int64_t'))
call_c_function(
fun_name = '_debug_has_internal_overlap',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch__dim_arange <- function(like, dim) {
  args <- rlang::env_get_list(nms = c("like", "dim"))
expected_types <- list(like = "Tensor", dim = "int64_t")
nd_args <- c("like", "dim")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = '_dim_arange',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch__dirichlet_grad <- function(x, alpha, total) {
  args <- rlang::env_get_list(nms = c("x", "alpha", "total"))
expected_types <- list(x = "Tensor", alpha = "Tensor", total = "Tensor")
nd_args <- c("x", "alpha", "total")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = '_dirichlet_grad',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch__embedding_bag <- function(weight, indices, offsets, scale_grad_by_freq = FALSE, mode = 0, sparse = FALSE, per_sample_weights = list(), include_last_offset = FALSE) {
  args <- rlang::env_get_list(nms = c("weight", "indices", "offsets", "scale_grad_by_freq", "mode", "sparse", "per_sample_weights", "include_last_offset"))
expected_types <- list(weight = "Tensor", indices = "Tensor", offsets = "Tensor", 
    scale_grad_by_freq = "bool", mode = "int64_t", sparse = "bool", 
    per_sample_weights = "Tensor", include_last_offset = "bool")
nd_args <- c("weight", "indices", "offsets")
return_types <- list(list("Tensor", "Tensor", "Tensor", "Tensor"))
call_c_function(
fun_name = '_embedding_bag',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch__embedding_bag_backward <- function(grad, indices, offsets, offset2bag, bag_size, maximum_indices, num_weights, scale_grad_by_freq, mode, sparse, per_sample_weights) {
  args <- rlang::env_get_list(nms = c("grad", "indices", "offsets", "offset2bag", "bag_size", "maximum_indices", "num_weights", "scale_grad_by_freq", "mode", "sparse", "per_sample_weights"))
expected_types <- list(grad = "Tensor", indices = "Tensor", offsets = "Tensor", 
    offset2bag = "Tensor", bag_size = "Tensor", maximum_indices = "Tensor", 
    num_weights = "int64_t", scale_grad_by_freq = "bool", mode = "int64_t", 
    sparse = "bool", per_sample_weights = "Tensor")
nd_args <- c("grad", "indices", "offsets", "offset2bag", "bag_size", "maximum_indices", 
"num_weights", "scale_grad_by_freq", "mode", "sparse", "per_sample_weights"
)
return_types <- list(list('Tensor'))
call_c_function(
fun_name = '_embedding_bag_backward',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch__embedding_bag_dense_backward <- function(grad, indices, offsets, offset2bag, bag_size, maximum_indices, num_weights, scale_grad_by_freq, mode, per_sample_weights) {
  args <- rlang::env_get_list(nms = c("grad", "indices", "offsets", "offset2bag", "bag_size", "maximum_indices", "num_weights", "scale_grad_by_freq", "mode", "per_sample_weights"))
expected_types <- list(grad = "Tensor", indices = "Tensor", offsets = "Tensor", 
    offset2bag = "Tensor", bag_size = "Tensor", maximum_indices = "Tensor", 
    num_weights = "int64_t", scale_grad_by_freq = "bool", mode = "int64_t", 
    per_sample_weights = "Tensor")
nd_args <- c("grad", "indices", "offsets", "offset2bag", "bag_size", "maximum_indices", 
"num_weights", "scale_grad_by_freq", "mode", "per_sample_weights"
)
return_types <- list(list('Tensor'))
call_c_function(
fun_name = '_embedding_bag_dense_backward',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch__embedding_bag_per_sample_weights_backward <- function(grad, weight, indices, offsets, offset2bag, mode) {
  args <- rlang::env_get_list(nms = c("grad", "weight", "indices", "offsets", "offset2bag", "mode"))
expected_types <- list(grad = "Tensor", weight = "Tensor", indices = "Tensor", 
    offsets = "Tensor", offset2bag = "Tensor", mode = "int64_t")
nd_args <- c("grad", "weight", "indices", "offsets", "offset2bag", "mode"
)
return_types <- list(list('Tensor'))
call_c_function(
fun_name = '_embedding_bag_per_sample_weights_backward',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch__embedding_bag_sparse_backward <- function(grad, indices, offsets, offset2bag, bag_size, num_weights, scale_grad_by_freq, mode, per_sample_weights) {
  args <- rlang::env_get_list(nms = c("grad", "indices", "offsets", "offset2bag", "bag_size", "num_weights", "scale_grad_by_freq", "mode", "per_sample_weights"))
expected_types <- list(grad = "Tensor", indices = "Tensor", offsets = "Tensor", 
    offset2bag = "Tensor", bag_size = "Tensor", num_weights = "int64_t", 
    scale_grad_by_freq = "bool", mode = "int64_t", per_sample_weights = "Tensor")
nd_args <- c("grad", "indices", "offsets", "offset2bag", "bag_size", "num_weights", 
"scale_grad_by_freq", "mode", "per_sample_weights")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = '_embedding_bag_sparse_backward',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch__empty_affine_quantized <- function(size, options = list(), scale = 1, zero_point = 0, memory_format = torch_contiguous_format()) {
  args <- rlang::env_get_list(nms = c("size", "options", "scale", "zero_point", "memory_format"))
expected_types <- list(size = "IntArrayRef", options = "TensorOptions", scale = "double", 
    zero_point = "int64_t", memory_format = "MemoryFormat")
nd_args <- "size"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = '_empty_affine_quantized',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch__empty_per_channel_affine_quantized <- function(size, scales, zero_points, axis, options = list(), memory_format = torch_contiguous_format()) {
  args <- rlang::env_get_list(nms = c("size", "scales", "zero_points", "axis", "options", "memory_format"))
expected_types <- list(size = "IntArrayRef", scales = "Tensor", zero_points = "Tensor", 
    axis = "int64_t", options = "TensorOptions", memory_format = "MemoryFormat")
nd_args <- c("size", "scales", "zero_points", "axis")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = '_empty_per_channel_affine_quantized',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch__fft_with_size <- function(self, signal_ndim, complex_input, complex_output, inverse, checked_signal_sizes, normalized, onesided, output_sizes) {
  args <- rlang::env_get_list(nms = c("self", "signal_ndim", "complex_input", "complex_output", "inverse", "checked_signal_sizes", "normalized", "onesided", "output_sizes"))
expected_types <- list(self = "Tensor", signal_ndim = "int64_t", complex_input = "bool", 
    complex_output = "bool", inverse = "bool", checked_signal_sizes = "IntArrayRef", 
    normalized = "bool", onesided = "bool", output_sizes = "IntArrayRef")
nd_args <- c("self", "signal_ndim", "complex_input", "complex_output", "inverse", 
"checked_signal_sizes", "normalized", "onesided", "output_sizes"
)
return_types <- list(list('Tensor'))
call_c_function(
fun_name = '_fft_with_size',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch__fused_dropout <- function(self, p, generator = NULL) {
  args <- rlang::env_get_list(nms = c("self", "p", "generator"))
expected_types <- list(self = "Tensor", p = "double", generator = "Generator *")
nd_args <- c("self", "p")
return_types <- list(list("Tensor", "Tensor"))
call_c_function(
fun_name = '_fused_dropout',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch__gather_sparse_backward <- function(self, dim, index, grad) {
  args <- rlang::env_get_list(nms = c("self", "dim", "index", "grad"))
expected_types <- list(self = "Tensor", dim = "int64_t", index = "Tensor", grad = "Tensor")
nd_args <- c("self", "dim", "index", "grad")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = '_gather_sparse_backward',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch__has_compatible_shallow_copy_type <- function(self, from) {
  args <- rlang::env_get_list(nms = c("self", "from"))
expected_types <- list(self = "Tensor", from = "Tensor")
nd_args <- c("self", "from")
return_types <- list(list('bool'))
call_c_function(
fun_name = '_has_compatible_shallow_copy_type',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch__index_copy_ <- function(self, dim, index, source) {
  args <- rlang::env_get_list(nms = c("self", "dim", "index", "source"))
expected_types <- list(self = "Tensor", dim = "int64_t", index = "Tensor", source = "Tensor")
nd_args <- c("self", "dim", "index", "source")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = '_index_copy_',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch__index_put_impl_ <- function(self, indices, values, accumulate = FALSE, unsafe = FALSE) {
  args <- rlang::env_get_list(nms = c("self", "indices", "values", "accumulate", "unsafe"))
expected_types <- list(self = "Tensor", indices = "TensorList", values = "Tensor", 
    accumulate = "bool", unsafe = "bool")
nd_args <- c("self", "indices", "values")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = '_index_put_impl_',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch__inverse_helper <- function(self) {
  args <- rlang::env_get_list(nms = c("self"))
expected_types <- list(self = "Tensor")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = '_inverse_helper',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch__local_scalar_dense <- function(self) {
  args <- rlang::env_get_list(nms = c("self"))
expected_types <- list(self = "Tensor")
nd_args <- "self"
return_types <- list(list('Scalar'))
call_c_function(
fun_name = '_local_scalar_dense',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch__log_softmax <- function(self, dim, half_to_float) {
  args <- rlang::env_get_list(nms = c("self", "dim", "half_to_float"))
expected_types <- list(self = "Tensor", dim = "int64_t", half_to_float = "bool")
nd_args <- c("self", "dim", "half_to_float")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = '_log_softmax',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch__log_softmax_backward_data <- function(grad_output, output, dim, self) {
  args <- rlang::env_get_list(nms = c("grad_output", "output", "dim", "self"))
expected_types <- list(grad_output = "Tensor", output = "Tensor", dim = "int64_t", 
    self = "Tensor")
nd_args <- c("grad_output", "output", "dim", "self")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = '_log_softmax_backward_data',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch__lu_solve_helper <- function(self, LU_data, LU_pivots) {
  args <- rlang::env_get_list(nms = c("self", "LU_data", "LU_pivots"))
expected_types <- list(self = "Tensor", LU_data = "Tensor", LU_pivots = "Tensor")
nd_args <- c("self", "LU_data", "LU_pivots")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = '_lu_solve_helper',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch__lu_with_info <- function(self, pivot = TRUE, check_errors = TRUE) {
  args <- rlang::env_get_list(nms = c("self", "pivot", "check_errors"))
expected_types <- list(self = "Tensor", pivot = "bool", check_errors = "bool")
nd_args <- "self"
return_types <- list(list("Tensor", "Tensor", "Tensor"))
call_c_function(
fun_name = '_lu_with_info',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch__make_per_channel_quantized_tensor <- function(self, scale, zero_point, axis) {
  args <- rlang::env_get_list(nms = c("self", "scale", "zero_point", "axis"))
expected_types <- list(self = "Tensor", scale = "Tensor", zero_point = "Tensor", 
    axis = "int64_t")
nd_args <- c("self", "scale", "zero_point", "axis")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = '_make_per_channel_quantized_tensor',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch__make_per_tensor_quantized_tensor <- function(self, scale, zero_point) {
  args <- rlang::env_get_list(nms = c("self", "scale", "zero_point"))
expected_types <- list(self = "Tensor", scale = "double", zero_point = "int64_t")
nd_args <- c("self", "scale", "zero_point")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = '_make_per_tensor_quantized_tensor',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch__masked_scale <- function(self, mask, scale) {
  args <- rlang::env_get_list(nms = c("self", "mask", "scale"))
expected_types <- list(self = "Tensor", mask = "Tensor", scale = "double")
nd_args <- c("self", "mask", "scale")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = '_masked_scale',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch__max <- function(self, dim, keepdim = FALSE) {
  args <- rlang::env_get_list(nms = c("self", "dim", "keepdim"))
expected_types <- list(self = "Tensor", dim = "int64_t", keepdim = "bool")
nd_args <- c("self", "dim")
return_types <- list(list("Tensor", "Tensor"))
call_c_function(
fun_name = '_max',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch__max_out <- function(max, max_indices, self, dim, keepdim = FALSE) {
  args <- rlang::env_get_list(nms = c("max", "max_indices", "self", "dim", "keepdim"))
expected_types <- list(max = "Tensor", max_indices = "Tensor", self = "Tensor", 
    dim = "int64_t", keepdim = "bool")
nd_args <- c("max", "max_indices", "self", "dim")
return_types <- list(list("Tensor", "Tensor"))
call_c_function(
fun_name = '_max_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch__min <- function(self, dim, keepdim = FALSE) {
  args <- rlang::env_get_list(nms = c("self", "dim", "keepdim"))
expected_types <- list(self = "Tensor", dim = "int64_t", keepdim = "bool")
nd_args <- c("self", "dim")
return_types <- list(list("Tensor", "Tensor"))
call_c_function(
fun_name = '_min',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch__min_out <- function(min, min_indices, self, dim, keepdim = FALSE) {
  args <- rlang::env_get_list(nms = c("min", "min_indices", "self", "dim", "keepdim"))
expected_types <- list(min = "Tensor", min_indices = "Tensor", self = "Tensor", 
    dim = "int64_t", keepdim = "bool")
nd_args <- c("min", "min_indices", "self", "dim")
return_types <- list(list("Tensor", "Tensor"))
call_c_function(
fun_name = '_min_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch__mkldnn_reshape <- function(self, shape) {
  args <- rlang::env_get_list(nms = c("self", "shape"))
expected_types <- list(self = "Tensor", shape = "IntArrayRef")
nd_args <- c("self", "shape")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = '_mkldnn_reshape',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch__mkldnn_transpose <- function(self, dim0, dim1) {
  args <- rlang::env_get_list(nms = c("self", "dim0", "dim1"))
expected_types <- list(self = "Tensor", dim0 = "int64_t", dim1 = "int64_t")
nd_args <- c("self", "dim0", "dim1")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = '_mkldnn_transpose',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch__mkldnn_transpose_ <- function(self, dim0, dim1) {
  args <- rlang::env_get_list(nms = c("self", "dim0", "dim1"))
expected_types <- list(self = "Tensor", dim0 = "int64_t", dim1 = "int64_t")
nd_args <- c("self", "dim0", "dim1")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = '_mkldnn_transpose_',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch__mode <- function(self, dim = -1, keepdim = FALSE) {
  args <- rlang::env_get_list(nms = c("self", "dim", "keepdim"))
expected_types <- list(self = "Tensor", dim = "int64_t", keepdim = "bool")
nd_args <- "self"
return_types <- list(list("Tensor", "Tensor"))
call_c_function(
fun_name = '_mode',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch__mode_out <- function(values, indices, self, dim = -1, keepdim = FALSE) {
  args <- rlang::env_get_list(nms = c("values", "indices", "self", "dim", "keepdim"))
expected_types <- list(values = "Tensor", indices = "Tensor", self = "Tensor", 
    dim = "int64_t", keepdim = "bool")
nd_args <- c("values", "indices", "self")
return_types <- list(list("Tensor", "Tensor"))
call_c_function(
fun_name = '_mode_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch__multinomial_alias_draw <- function(J, q, num_samples, generator = NULL) {
  args <- rlang::env_get_list(nms = c("J", "q", "num_samples", "generator"))
expected_types <- list(J = "Tensor", q = "Tensor", num_samples = "int64_t", generator = "Generator *")
nd_args <- c("J", "q", "num_samples")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = '_multinomial_alias_draw',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch__multinomial_alias_setup <- function(probs) {
  args <- rlang::env_get_list(nms = c("probs"))
expected_types <- list(probs = "Tensor")
nd_args <- "probs"
return_types <- list(list("Tensor", "Tensor"))
call_c_function(
fun_name = '_multinomial_alias_setup',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch__nnpack_available <- function() {
  args <- list()
expected_types <- list()
nd_args <- character(0)
return_types <- list(list('bool'))
call_c_function(
fun_name = '_nnpack_available',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch__nnpack_spatial_convolution <- function(input, weight, bias, padding, stride = 1) {
  args <- rlang::env_get_list(nms = c("input", "weight", "bias", "padding", "stride"))
expected_types <- list(input = "Tensor", weight = "Tensor", bias = "Tensor", padding = "IntArrayRef", 
    stride = "IntArrayRef")
nd_args <- c("input", "weight", "bias", "padding")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = '_nnpack_spatial_convolution',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch__nnpack_spatial_convolution_backward <- function(input, grad_output, weight, padding, output_mask) {
  args <- rlang::env_get_list(nms = c("input", "grad_output", "weight", "padding", "output_mask"))
expected_types <- list(input = "Tensor", grad_output = "Tensor", weight = "Tensor", 
    padding = "IntArrayRef", output_mask = "std::array<bool,3>")
nd_args <- c("input", "grad_output", "weight", "padding", "output_mask")
return_types <- list(list("Tensor", "Tensor", "Tensor"))
call_c_function(
fun_name = '_nnpack_spatial_convolution_backward',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch__nnpack_spatial_convolution_backward_input <- function(input, grad_output, weight, padding) {
  args <- rlang::env_get_list(nms = c("input", "grad_output", "weight", "padding"))
expected_types <- list(input = "Tensor", grad_output = "Tensor", weight = "Tensor", 
    padding = "IntArrayRef")
nd_args <- c("input", "grad_output", "weight", "padding")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = '_nnpack_spatial_convolution_backward_input',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch__nnpack_spatial_convolution_backward_weight <- function(input, weightsize, grad_output, padding) {
  args <- rlang::env_get_list(nms = c("input", "weightsize", "grad_output", "padding"))
expected_types <- list(input = "Tensor", weightsize = "IntArrayRef", grad_output = "Tensor", 
    padding = "IntArrayRef")
nd_args <- c("input", "weightsize", "grad_output", "padding")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = '_nnpack_spatial_convolution_backward_weight',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch__pack_padded_sequence <- function(input, lengths, batch_first) {
  args <- rlang::env_get_list(nms = c("input", "lengths", "batch_first"))
expected_types <- list(input = "Tensor", lengths = "Tensor", batch_first = "bool")
nd_args <- c("input", "lengths", "batch_first")
return_types <- list(list("Tensor", "Tensor"))
call_c_function(
fun_name = '_pack_padded_sequence',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch__pack_padded_sequence_backward <- function(grad, input_size, batch_sizes, batch_first) {
  args <- rlang::env_get_list(nms = c("grad", "input_size", "batch_sizes", "batch_first"))
expected_types <- list(grad = "Tensor", input_size = "IntArrayRef", batch_sizes = "Tensor", 
    batch_first = "bool")
nd_args <- c("grad", "input_size", "batch_sizes", "batch_first")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = '_pack_padded_sequence_backward',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch__pad_packed_sequence <- function(data, batch_sizes, batch_first, padding_value, total_length) {
  args <- rlang::env_get_list(nms = c("data", "batch_sizes", "batch_first", "padding_value", "total_length"))
expected_types <- list(data = "Tensor", batch_sizes = "Tensor", batch_first = "bool", 
    padding_value = "Scalar", total_length = "int64_t")
nd_args <- c("data", "batch_sizes", "batch_first", "padding_value", "total_length"
)
return_types <- list(list("Tensor", "Tensor"))
call_c_function(
fun_name = '_pad_packed_sequence',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch__pdist_backward <- function(grad, self, p, pdist) {
  args <- rlang::env_get_list(nms = c("grad", "self", "p", "pdist"))
expected_types <- list(grad = "Tensor", self = "Tensor", p = "double", pdist = "Tensor")
nd_args <- c("grad", "self", "p", "pdist")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = '_pdist_backward',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch__pdist_forward <- function(self, p = 2) {
  args <- rlang::env_get_list(nms = c("self", "p"))
expected_types <- list(self = "Tensor", p = "double")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = '_pdist_forward',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch__qr_helper <- function(self, some) {
  args <- rlang::env_get_list(nms = c("self", "some"))
expected_types <- list(self = "Tensor", some = "bool")
nd_args <- c("self", "some")
return_types <- list(list("Tensor", "Tensor"))
call_c_function(
fun_name = '_qr_helper',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch__reshape_from_tensor <- function(self, shape) {
  args <- rlang::env_get_list(nms = c("self", "shape"))
expected_types <- list(self = "Tensor", shape = "Tensor")
nd_args <- c("self", "shape")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = '_reshape_from_tensor',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch__s_where <- function(condition, self, other) {
  args <- rlang::env_get_list(nms = c("condition", "self", "other"))
expected_types <- list(condition = "Tensor", self = "Tensor", other = "Tensor")
nd_args <- c("condition", "self", "other")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = '_s_where',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch__sample_dirichlet <- function(self, generator = NULL) {
  args <- rlang::env_get_list(nms = c("self", "generator"))
expected_types <- list(self = "Tensor", generator = "Generator *")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = '_sample_dirichlet',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch__shape_as_tensor <- function(self) {
  args <- rlang::env_get_list(nms = c("self"))
expected_types <- list(self = "Tensor")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = '_shape_as_tensor',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch__sobol_engine_draw <- function(quasi, n, sobolstate, dimension, num_generated, dtype) {
  args <- rlang::env_get_list(nms = c("quasi", "n", "sobolstate", "dimension", "num_generated", "dtype"))
expected_types <- list(quasi = "Tensor", n = "int64_t", sobolstate = "Tensor", 
    dimension = "int64_t", num_generated = "int64_t", dtype = "ScalarType")
nd_args <- c("quasi", "n", "sobolstate", "dimension", "num_generated", "dtype"
)
return_types <- list(list("Tensor", "Tensor"))
call_c_function(
fun_name = '_sobol_engine_draw',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch__sobol_engine_ff_ <- function(self, n, sobolstate, dimension, num_generated) {
  args <- rlang::env_get_list(nms = c("self", "n", "sobolstate", "dimension", "num_generated"))
expected_types <- list(self = "Tensor", n = "int64_t", sobolstate = "Tensor", dimension = "int64_t", 
    num_generated = "int64_t")
nd_args <- c("self", "n", "sobolstate", "dimension", "num_generated")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = '_sobol_engine_ff_',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch__sobol_engine_initialize_state_ <- function(self, dimension) {
  args <- rlang::env_get_list(nms = c("self", "dimension"))
expected_types <- list(self = "Tensor", dimension = "int64_t")
nd_args <- c("self", "dimension")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = '_sobol_engine_initialize_state_',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch__sobol_engine_scramble_ <- function(self, ltm, dimension) {
  args <- rlang::env_get_list(nms = c("self", "ltm", "dimension"))
expected_types <- list(self = "Tensor", ltm = "Tensor", dimension = "int64_t")
nd_args <- c("self", "ltm", "dimension")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = '_sobol_engine_scramble_',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch__softmax <- function(self, dim, half_to_float) {
  args <- rlang::env_get_list(nms = c("self", "dim", "half_to_float"))
expected_types <- list(self = "Tensor", dim = "int64_t", half_to_float = "bool")
nd_args <- c("self", "dim", "half_to_float")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = '_softmax',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch__softmax_backward_data <- function(grad_output, output, dim, self) {
  args <- rlang::env_get_list(nms = c("grad_output", "output", "dim", "self"))
expected_types <- list(grad_output = "Tensor", output = "Tensor", dim = "int64_t", 
    self = "Tensor")
nd_args <- c("grad_output", "output", "dim", "self")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = '_softmax_backward_data',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch__solve_helper <- function(self, A) {
  args <- rlang::env_get_list(nms = c("self", "A"))
expected_types <- list(self = "Tensor", A = "Tensor")
nd_args <- c("self", "A")
return_types <- list(list("Tensor", "Tensor"))
call_c_function(
fun_name = '_solve_helper',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch__sparse_addmm <- function(self, sparse, dense, beta = 1, alpha = 1) {
  args <- rlang::env_get_list(nms = c("self", "sparse", "dense", "beta", "alpha"))
expected_types <- list(self = "Tensor", sparse = "Tensor", dense = "Tensor", beta = "Scalar", 
    alpha = "Scalar")
nd_args <- c("self", "sparse", "dense")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = '_sparse_addmm',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch__sparse_coo_tensor_unsafe <- function(indices, values, size, options = list()) {
  args <- rlang::env_get_list(nms = c("indices", "values", "size", "options"))
expected_types <- list(indices = "Tensor", values = "Tensor", size = "IntArrayRef", 
    options = "TensorOptions")
nd_args <- c("indices", "values", "size")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = '_sparse_coo_tensor_unsafe',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch__sparse_coo_tensor_with_dims <- function(sparse_dim, dense_dim, size, options) {
  args <- rlang::env_get_list(nms = c("sparse_dim", "dense_dim", "size", "options"))
expected_types <- list(sparse_dim = "int64_t", dense_dim = "int64_t", size = "IntArrayRef", 
    options = "TensorOptions")
nd_args <- c("sparse_dim", "dense_dim", "size", "options")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = '_sparse_coo_tensor_with_dims',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch__sparse_coo_tensor_with_dims_and_tensors <- function(sparse_dim, dense_dim, size, indices, values, options) {
  args <- rlang::env_get_list(nms = c("sparse_dim", "dense_dim", "size", "indices", "values", "options"))
expected_types <- list(sparse_dim = "int64_t", dense_dim = "int64_t", size = "IntArrayRef", 
    indices = "Tensor", values = "Tensor", options = "TensorOptions")
nd_args <- c("sparse_dim", "dense_dim", "size", "indices", "values", "options"
)
return_types <- list(list('Tensor'))
call_c_function(
fun_name = '_sparse_coo_tensor_with_dims_and_tensors',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch__sparse_mm <- function(sparse, dense) {
  args <- rlang::env_get_list(nms = c("sparse", "dense"))
expected_types <- list(sparse = "Tensor", dense = "Tensor")
nd_args <- c("sparse", "dense")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = '_sparse_mm',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch__sparse_sum <- function(self, dim, dtype) {
  args <- rlang::env_get_list(nms = c("self", "dim", "dtype"))
expected_types <- list(self = "Tensor", dim = "IntArrayRef", dtype = "ScalarType")
nd_args <- c("self", "dim", "dtype")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = '_sparse_sum',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch__sparse_sum_backward <- function(grad, self, dim) {
  args <- rlang::env_get_list(nms = c("grad", "self", "dim"))
expected_types <- list(grad = "Tensor", self = "Tensor", dim = "IntArrayRef")
nd_args <- c("grad", "self", "dim")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = '_sparse_sum_backward',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch__standard_gamma <- function(self, generator = NULL) {
  args <- rlang::env_get_list(nms = c("self", "generator"))
expected_types <- list(self = "Tensor", generator = "Generator *")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = '_standard_gamma',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch__standard_gamma_grad <- function(self, output) {
  args <- rlang::env_get_list(nms = c("self", "output"))
expected_types <- list(self = "Tensor", output = "Tensor")
nd_args <- c("self", "output")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = '_standard_gamma_grad',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch__std <- function(self, unbiased = TRUE) {
  args <- rlang::env_get_list(nms = c("self", "unbiased"))
expected_types <- list(self = "Tensor", unbiased = "bool")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = '_std',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch__svd_helper <- function(self, some, compute_uv) {
  args <- rlang::env_get_list(nms = c("self", "some", "compute_uv"))
expected_types <- list(self = "Tensor", some = "bool", compute_uv = "bool")
nd_args <- c("self", "some", "compute_uv")
return_types <- list(list("Tensor", "Tensor", "Tensor"))
call_c_function(
fun_name = '_svd_helper',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch__symeig_helper <- function(self, eigenvectors, upper) {
  args <- rlang::env_get_list(nms = c("self", "eigenvectors", "upper"))
expected_types <- list(self = "Tensor", eigenvectors = "bool", upper = "bool")
nd_args <- c("self", "eigenvectors", "upper")
return_types <- list(list("Tensor", "Tensor"))
call_c_function(
fun_name = '_symeig_helper',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch__thnn_differentiable_gru_cell_backward <- function(grad_hy, input_gates, hidden_gates, hx, input_bias, hidden_bias) {
  args <- rlang::env_get_list(nms = c("grad_hy", "input_gates", "hidden_gates", "hx", "input_bias", "hidden_bias"))
expected_types <- list(grad_hy = "Tensor", input_gates = "Tensor", hidden_gates = "Tensor", 
    hx = "Tensor", input_bias = "Tensor", hidden_bias = "Tensor")
nd_args <- c("grad_hy", "input_gates", "hidden_gates", "hx", "input_bias", 
"hidden_bias")
return_types <- list(list("Tensor", "Tensor", "Tensor", "Tensor", "Tensor"))
call_c_function(
fun_name = '_thnn_differentiable_gru_cell_backward',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch__thnn_differentiable_lstm_cell_backward <- function(grad_hy, grad_cy, input_gates, hidden_gates, input_bias, hidden_bias, cx, cy) {
  args <- rlang::env_get_list(nms = c("grad_hy", "grad_cy", "input_gates", "hidden_gates", "input_bias", "hidden_bias", "cx", "cy"))
expected_types <- list(grad_hy = "Tensor", grad_cy = "Tensor", input_gates = "Tensor", 
    hidden_gates = "Tensor", input_bias = "Tensor", hidden_bias = "Tensor", 
    cx = "Tensor", cy = "Tensor")
nd_args <- c("grad_hy", "grad_cy", "input_gates", "hidden_gates", "input_bias", 
"hidden_bias", "cx", "cy")
return_types <- list(list("Tensor", "Tensor", "Tensor", "Tensor", "Tensor"))
call_c_function(
fun_name = '_thnn_differentiable_lstm_cell_backward',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch__thnn_fused_gru_cell <- function(input_gates, hidden_gates, hx, input_bias = list(), hidden_bias = list()) {
  args <- rlang::env_get_list(nms = c("input_gates", "hidden_gates", "hx", "input_bias", "hidden_bias"))
expected_types <- list(input_gates = "Tensor", hidden_gates = "Tensor", hx = "Tensor", 
    input_bias = "Tensor", hidden_bias = "Tensor")
nd_args <- c("input_gates", "hidden_gates", "hx")
return_types <- list(list("Tensor", "Tensor"))
call_c_function(
fun_name = '_thnn_fused_gru_cell',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch__thnn_fused_gru_cell_backward <- function(grad_hy, workspace, has_bias) {
  args <- rlang::env_get_list(nms = c("grad_hy", "workspace", "has_bias"))
expected_types <- list(grad_hy = "Tensor", workspace = "Tensor", has_bias = "bool")
nd_args <- c("grad_hy", "workspace", "has_bias")
return_types <- list(list("Tensor", "Tensor", "Tensor", "Tensor", "Tensor"))
call_c_function(
fun_name = '_thnn_fused_gru_cell_backward',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch__thnn_fused_lstm_cell <- function(input_gates, hidden_gates, cx, input_bias = list(), hidden_bias = list()) {
  args <- rlang::env_get_list(nms = c("input_gates", "hidden_gates", "cx", "input_bias", "hidden_bias"))
expected_types <- list(input_gates = "Tensor", hidden_gates = "Tensor", cx = "Tensor", 
    input_bias = "Tensor", hidden_bias = "Tensor")
nd_args <- c("input_gates", "hidden_gates", "cx")
return_types <- list(list("Tensor", "Tensor", "Tensor"))
call_c_function(
fun_name = '_thnn_fused_lstm_cell',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch__thnn_fused_lstm_cell_backward <- function(grad_hy, grad_cy, cx, cy, workspace, has_bias) {
  args <- rlang::env_get_list(nms = c("grad_hy", "grad_cy", "cx", "cy", "workspace", "has_bias"))
expected_types <- list(grad_hy = "Tensor", grad_cy = "Tensor", cx = "Tensor", cy = "Tensor", 
    workspace = "Tensor", has_bias = "bool")
nd_args <- c("grad_hy", "grad_cy", "cx", "cy", "workspace", "has_bias")
return_types <- list(list("Tensor", "Tensor", "Tensor", "Tensor", "Tensor"))
call_c_function(
fun_name = '_thnn_fused_lstm_cell_backward',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch__triangular_solve_helper <- function(self, A, upper, transpose, unitriangular) {
  args <- rlang::env_get_list(nms = c("self", "A", "upper", "transpose", "unitriangular"))
expected_types <- list(self = "Tensor", A = "Tensor", upper = "bool", transpose = "bool", 
    unitriangular = "bool")
nd_args <- c("self", "A", "upper", "transpose", "unitriangular")
return_types <- list(list("Tensor", "Tensor"))
call_c_function(
fun_name = '_triangular_solve_helper',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch__trilinear <- function(i1, i2, i3, expand1, expand2, expand3, sumdim, unroll_dim = 1) {
  args <- rlang::env_get_list(nms = c("i1", "i2", "i3", "expand1", "expand2", "expand3", "sumdim", "unroll_dim"))
expected_types <- list(i1 = "Tensor", i2 = "Tensor", i3 = "Tensor", expand1 = "IntArrayRef", 
    expand2 = "IntArrayRef", expand3 = "IntArrayRef", sumdim = "IntArrayRef", 
    unroll_dim = "int64_t")
nd_args <- c("i1", "i2", "i3", "expand1", "expand2", "expand3", "sumdim"
)
return_types <- list(list('Tensor'))
call_c_function(
fun_name = '_trilinear',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch__unique <- function(self, sorted = TRUE, return_inverse = FALSE) {
  args <- rlang::env_get_list(nms = c("self", "sorted", "return_inverse"))
expected_types <- list(self = "Tensor", sorted = "bool", return_inverse = "bool")
nd_args <- "self"
return_types <- list(list("Tensor", "Tensor"))
call_c_function(
fun_name = '_unique',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch__unique2 <- function(self, sorted = TRUE, return_inverse = FALSE, return_counts = FALSE) {
  args <- rlang::env_get_list(nms = c("self", "sorted", "return_inverse", "return_counts"))
expected_types <- list(self = "Tensor", sorted = "bool", return_inverse = "bool", 
    return_counts = "bool")
nd_args <- "self"
return_types <- list(list("Tensor", "Tensor", "Tensor"))
call_c_function(
fun_name = '_unique2',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch__unsafe_view <- function(self, size) {
  args <- rlang::env_get_list(nms = c("self", "size"))
expected_types <- list(self = "Tensor", size = "IntArrayRef")
nd_args <- c("self", "size")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = '_unsafe_view',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch__use_cudnn_ctc_loss <- function(log_probs, targets, input_lengths, target_lengths, blank) {
  args <- rlang::env_get_list(nms = c("log_probs", "targets", "input_lengths", "target_lengths", "blank"))
expected_types <- list(log_probs = "Tensor", targets = "Tensor", input_lengths = "IntArrayRef", 
    target_lengths = "IntArrayRef", blank = "int64_t")
nd_args <- c("log_probs", "targets", "input_lengths", "target_lengths", 
"blank")
return_types <- list(list('bool'))
call_c_function(
fun_name = '_use_cudnn_ctc_loss',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch__use_cudnn_rnn_flatten_weight <- function() {
  args <- list()
expected_types <- list()
nd_args <- character(0)
return_types <- list(list('bool'))
call_c_function(
fun_name = '_use_cudnn_rnn_flatten_weight',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch__var <- function(self, unbiased = TRUE) {
  args <- rlang::env_get_list(nms = c("self", "unbiased"))
expected_types <- list(self = "Tensor", unbiased = "bool")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = '_var',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch__weight_norm <- function(v, g, dim = 0) {
  args <- rlang::env_get_list(nms = c("v", "g", "dim"))
expected_types <- list(v = "Tensor", g = "Tensor", dim = "int64_t")
nd_args <- c("v", "g")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = '_weight_norm',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch__weight_norm_cuda_interface <- function(v, g, dim = 0) {
  args <- rlang::env_get_list(nms = c("v", "g", "dim"))
expected_types <- list(v = "Tensor", g = "Tensor", dim = "int64_t")
nd_args <- c("v", "g")
return_types <- list(list("Tensor", "Tensor"))
call_c_function(
fun_name = '_weight_norm_cuda_interface',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch__weight_norm_cuda_interface_backward <- function(grad_w, saved_v, saved_g, saved_norms, dim) {
  args <- rlang::env_get_list(nms = c("grad_w", "saved_v", "saved_g", "saved_norms", "dim"))
expected_types <- list(grad_w = "Tensor", saved_v = "Tensor", saved_g = "Tensor", 
    saved_norms = "Tensor", dim = "int64_t")
nd_args <- c("grad_w", "saved_v", "saved_g", "saved_norms", "dim")
return_types <- list(list("Tensor", "Tensor"))
call_c_function(
fun_name = '_weight_norm_cuda_interface_backward',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch__weight_norm_differentiable_backward <- function(grad_w, saved_v, saved_g, saved_norms, dim) {
  args <- rlang::env_get_list(nms = c("grad_w", "saved_v", "saved_g", "saved_norms", "dim"))
expected_types <- list(grad_w = "Tensor", saved_v = "Tensor", saved_g = "Tensor", 
    saved_norms = "Tensor", dim = "int64_t")
nd_args <- c("grad_w", "saved_v", "saved_g", "saved_norms", "dim")
return_types <- list(list("Tensor", "Tensor"))
call_c_function(
fun_name = '_weight_norm_differentiable_backward',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_abs <- function(self) {
  args <- rlang::env_get_list(nms = c("self"))
expected_types <- list(self = "Tensor")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'abs',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_abs_ <- function(self) {
  args <- rlang::env_get_list(nms = c("self"))
expected_types <- list(self = "Tensor")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'abs_',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_abs_out <- function(out, self) {
  args <- rlang::env_get_list(nms = c("out", "self"))
expected_types <- list(out = "Tensor", self = "Tensor")
nd_args <- c("out", "self")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'abs_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_acos <- function(self) {
  args <- rlang::env_get_list(nms = c("self"))
expected_types <- list(self = "Tensor")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'acos',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_acos_ <- function(self) {
  args <- rlang::env_get_list(nms = c("self"))
expected_types <- list(self = "Tensor")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'acos_',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_acos_out <- function(out, self) {
  args <- rlang::env_get_list(nms = c("out", "self"))
expected_types <- list(out = "Tensor", self = "Tensor")
nd_args <- c("out", "self")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'acos_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_adaptive_avg_pool1d <- function(self, output_size) {
  args <- rlang::env_get_list(nms = c("self", "output_size"))
expected_types <- list(self = "Tensor", output_size = "IntArrayRef")
nd_args <- c("self", "output_size")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'adaptive_avg_pool1d',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_adaptive_avg_pool2d <- function(self, output_size) {
  args <- rlang::env_get_list(nms = c("self", "output_size"))
expected_types <- list(self = "Tensor", output_size = "IntArrayRef")
nd_args <- c("self", "output_size")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'adaptive_avg_pool2d',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_adaptive_avg_pool2d_out <- function(out, self, output_size) {
  args <- rlang::env_get_list(nms = c("out", "self", "output_size"))
expected_types <- list(out = "Tensor", self = "Tensor", output_size = "IntArrayRef")
nd_args <- c("out", "self", "output_size")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'adaptive_avg_pool2d_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_adaptive_avg_pool3d <- function(self, output_size) {
  args <- rlang::env_get_list(nms = c("self", "output_size"))
expected_types <- list(self = "Tensor", output_size = "IntArrayRef")
nd_args <- c("self", "output_size")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'adaptive_avg_pool3d',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_adaptive_avg_pool3d_backward <- function(grad_output, self) {
  args <- rlang::env_get_list(nms = c("grad_output", "self"))
expected_types <- list(grad_output = "Tensor", self = "Tensor")
nd_args <- c("grad_output", "self")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'adaptive_avg_pool3d_backward',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_adaptive_avg_pool3d_backward_out <- function(grad_input, grad_output, self) {
  args <- rlang::env_get_list(nms = c("grad_input", "grad_output", "self"))
expected_types <- list(grad_input = "Tensor", grad_output = "Tensor", self = "Tensor")
nd_args <- c("grad_input", "grad_output", "self")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'adaptive_avg_pool3d_backward_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_adaptive_avg_pool3d_out <- function(out, self, output_size) {
  args <- rlang::env_get_list(nms = c("out", "self", "output_size"))
expected_types <- list(out = "Tensor", self = "Tensor", output_size = "IntArrayRef")
nd_args <- c("out", "self", "output_size")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'adaptive_avg_pool3d_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_adaptive_max_pool1d <- function(self, output_size) {
  args <- rlang::env_get_list(nms = c("self", "output_size"))
expected_types <- list(self = "Tensor", output_size = "IntArrayRef")
nd_args <- c("self", "output_size")
return_types <- list(list("Tensor", "Tensor"))
call_c_function(
fun_name = 'adaptive_max_pool1d',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_adaptive_max_pool2d <- function(self, output_size) {
  args <- rlang::env_get_list(nms = c("self", "output_size"))
expected_types <- list(self = "Tensor", output_size = "IntArrayRef")
nd_args <- c("self", "output_size")
return_types <- list(list("Tensor", "Tensor"))
call_c_function(
fun_name = 'adaptive_max_pool2d',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_adaptive_max_pool2d_backward <- function(grad_output, self, indices) {
  args <- rlang::env_get_list(nms = c("grad_output", "self", "indices"))
expected_types <- list(grad_output = "Tensor", self = "Tensor", indices = "Tensor")
nd_args <- c("grad_output", "self", "indices")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'adaptive_max_pool2d_backward',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_adaptive_max_pool2d_backward_out <- function(grad_input, grad_output, self, indices) {
  args <- rlang::env_get_list(nms = c("grad_input", "grad_output", "self", "indices"))
expected_types <- list(grad_input = "Tensor", grad_output = "Tensor", self = "Tensor", 
    indices = "Tensor")
nd_args <- c("grad_input", "grad_output", "self", "indices")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'adaptive_max_pool2d_backward_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_adaptive_max_pool2d_out <- function(out, indices, self, output_size) {
  args <- rlang::env_get_list(nms = c("out", "indices", "self", "output_size"))
expected_types <- list(out = "Tensor", indices = "Tensor", self = "Tensor", output_size = "IntArrayRef")
nd_args <- c("out", "indices", "self", "output_size")
return_types <- list(list("Tensor", "Tensor"))
call_c_function(
fun_name = 'adaptive_max_pool2d_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_adaptive_max_pool3d <- function(self, output_size) {
  args <- rlang::env_get_list(nms = c("self", "output_size"))
expected_types <- list(self = "Tensor", output_size = "IntArrayRef")
nd_args <- c("self", "output_size")
return_types <- list(list("Tensor", "Tensor"))
call_c_function(
fun_name = 'adaptive_max_pool3d',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_adaptive_max_pool3d_backward <- function(grad_output, self, indices) {
  args <- rlang::env_get_list(nms = c("grad_output", "self", "indices"))
expected_types <- list(grad_output = "Tensor", self = "Tensor", indices = "Tensor")
nd_args <- c("grad_output", "self", "indices")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'adaptive_max_pool3d_backward',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_adaptive_max_pool3d_backward_out <- function(grad_input, grad_output, self, indices) {
  args <- rlang::env_get_list(nms = c("grad_input", "grad_output", "self", "indices"))
expected_types <- list(grad_input = "Tensor", grad_output = "Tensor", self = "Tensor", 
    indices = "Tensor")
nd_args <- c("grad_input", "grad_output", "self", "indices")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'adaptive_max_pool3d_backward_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_adaptive_max_pool3d_out <- function(out, indices, self, output_size) {
  args <- rlang::env_get_list(nms = c("out", "indices", "self", "output_size"))
expected_types <- list(out = "Tensor", indices = "Tensor", self = "Tensor", output_size = "IntArrayRef")
nd_args <- c("out", "indices", "self", "output_size")
return_types <- list(list("Tensor", "Tensor"))
call_c_function(
fun_name = 'adaptive_max_pool3d_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_add <- function(self, other, alpha = 1) {
  args <- rlang::env_get_list(nms = c("self", "other", "alpha"))
expected_types <- list(self = "Tensor", other = c("Tensor", "Scalar"), alpha = "Scalar")
nd_args <- c("self", "other")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'add',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_add_out <- function(out, self, other, alpha = 1) {
  args <- rlang::env_get_list(nms = c("out", "self", "other", "alpha"))
expected_types <- list(out = "Tensor", self = "Tensor", other = "Tensor", alpha = "Scalar")
nd_args <- c("out", "self", "other")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'add_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_addbmm <- function(self, batch1, batch2, beta = 1, alpha = 1) {
  args <- rlang::env_get_list(nms = c("self", "batch1", "batch2", "beta", "alpha"))
expected_types <- list(self = "Tensor", batch1 = "Tensor", batch2 = "Tensor", beta = "Scalar", 
    alpha = "Scalar")
nd_args <- c("self", "batch1", "batch2")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'addbmm',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_addbmm_out <- function(out, self, batch1, batch2, beta = 1, alpha = 1) {
  args <- rlang::env_get_list(nms = c("out", "self", "batch1", "batch2", "beta", "alpha"))
expected_types <- list(out = "Tensor", self = "Tensor", batch1 = "Tensor", batch2 = "Tensor", 
    beta = "Scalar", alpha = "Scalar")
nd_args <- c("out", "self", "batch1", "batch2")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'addbmm_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_addcdiv <- function(self, tensor1, tensor2, value = 1) {
  args <- rlang::env_get_list(nms = c("self", "tensor1", "tensor2", "value"))
expected_types <- list(self = "Tensor", tensor1 = "Tensor", tensor2 = "Tensor", 
    value = "Scalar")
nd_args <- c("self", "tensor1", "tensor2")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'addcdiv',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_addcdiv_out <- function(out, self, tensor1, tensor2, value = 1) {
  args <- rlang::env_get_list(nms = c("out", "self", "tensor1", "tensor2", "value"))
expected_types <- list(out = "Tensor", self = "Tensor", tensor1 = "Tensor", tensor2 = "Tensor", 
    value = "Scalar")
nd_args <- c("out", "self", "tensor1", "tensor2")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'addcdiv_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_addcmul <- function(self, tensor1, tensor2, value = 1) {
  args <- rlang::env_get_list(nms = c("self", "tensor1", "tensor2", "value"))
expected_types <- list(self = "Tensor", tensor1 = "Tensor", tensor2 = "Tensor", 
    value = "Scalar")
nd_args <- c("self", "tensor1", "tensor2")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'addcmul',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_addcmul_out <- function(out, self, tensor1, tensor2, value = 1) {
  args <- rlang::env_get_list(nms = c("out", "self", "tensor1", "tensor2", "value"))
expected_types <- list(out = "Tensor", self = "Tensor", tensor1 = "Tensor", tensor2 = "Tensor", 
    value = "Scalar")
nd_args <- c("out", "self", "tensor1", "tensor2")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'addcmul_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_addmm <- function(self, mat1, mat2, beta = 1, alpha = 1) {
  args <- rlang::env_get_list(nms = c("self", "mat1", "mat2", "beta", "alpha"))
expected_types <- list(self = "Tensor", mat1 = "Tensor", mat2 = "Tensor", beta = "Scalar", 
    alpha = "Scalar")
nd_args <- c("self", "mat1", "mat2")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'addmm',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_addmm_out <- function(out, self, mat1, mat2, beta = 1, alpha = 1) {
  args <- rlang::env_get_list(nms = c("out", "self", "mat1", "mat2", "beta", "alpha"))
expected_types <- list(out = "Tensor", self = "Tensor", mat1 = "Tensor", mat2 = "Tensor", 
    beta = "Scalar", alpha = "Scalar")
nd_args <- c("out", "self", "mat1", "mat2")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'addmm_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_addmv <- function(self, mat, vec, beta = 1, alpha = 1) {
  args <- rlang::env_get_list(nms = c("self", "mat", "vec", "beta", "alpha"))
expected_types <- list(self = "Tensor", mat = "Tensor", vec = "Tensor", beta = "Scalar", 
    alpha = "Scalar")
nd_args <- c("self", "mat", "vec")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'addmv',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_addmv_ <- function(self, mat, vec, beta = 1, alpha = 1) {
  args <- rlang::env_get_list(nms = c("self", "mat", "vec", "beta", "alpha"))
expected_types <- list(self = "Tensor", mat = "Tensor", vec = "Tensor", beta = "Scalar", 
    alpha = "Scalar")
nd_args <- c("self", "mat", "vec")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'addmv_',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_addmv_out <- function(out, self, mat, vec, beta = 1, alpha = 1) {
  args <- rlang::env_get_list(nms = c("out", "self", "mat", "vec", "beta", "alpha"))
expected_types <- list(out = "Tensor", self = "Tensor", mat = "Tensor", vec = "Tensor", 
    beta = "Scalar", alpha = "Scalar")
nd_args <- c("out", "self", "mat", "vec")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'addmv_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_addr <- function(self, vec1, vec2, beta = 1, alpha = 1) {
  args <- rlang::env_get_list(nms = c("self", "vec1", "vec2", "beta", "alpha"))
expected_types <- list(self = "Tensor", vec1 = "Tensor", vec2 = "Tensor", beta = "Scalar", 
    alpha = "Scalar")
nd_args <- c("self", "vec1", "vec2")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'addr',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_addr_out <- function(out, self, vec1, vec2, beta = 1, alpha = 1) {
  args <- rlang::env_get_list(nms = c("out", "self", "vec1", "vec2", "beta", "alpha"))
expected_types <- list(out = "Tensor", self = "Tensor", vec1 = "Tensor", vec2 = "Tensor", 
    beta = "Scalar", alpha = "Scalar")
nd_args <- c("out", "self", "vec1", "vec2")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'addr_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_affine_grid_generator <- function(theta, size, align_corners) {
  args <- rlang::env_get_list(nms = c("theta", "size", "align_corners"))
expected_types <- list(theta = "Tensor", size = "IntArrayRef", align_corners = "bool")
nd_args <- c("theta", "size", "align_corners")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'affine_grid_generator',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_affine_grid_generator_backward <- function(grad, size, align_corners) {
  args <- rlang::env_get_list(nms = c("grad", "size", "align_corners"))
expected_types <- list(grad = "Tensor", size = "IntArrayRef", align_corners = "bool")
nd_args <- c("grad", "size", "align_corners")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'affine_grid_generator_backward',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_alias <- function(self) {
  args <- rlang::env_get_list(nms = c("self"))
expected_types <- list(self = "Tensor")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'alias',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_align_tensors <- function(tensors) {
  args <- rlang::env_get_list(nms = c("tensors"))
expected_types <- list(tensors = "TensorList")
nd_args <- "tensors"
return_types <- list(list('TensorList'))
call_c_function(
fun_name = 'align_tensors',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_all <- function(self, dim, keepdim = FALSE) {
  args <- rlang::env_get_list(nms = c("self", "dim", "keepdim"))
expected_types <- list(self = "Tensor", dim = c("int64_t", "Dimname"), keepdim = "bool")
nd_args <- c("self", "dim")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'all',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_all_out <- function(out, self, dim, keepdim = FALSE) {
  args <- rlang::env_get_list(nms = c("out", "self", "dim", "keepdim"))
expected_types <- list(out = "Tensor", self = "Tensor", dim = c("int64_t", "Dimname"
), keepdim = "bool")
nd_args <- c("out", "self", "dim")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'all_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_allclose <- function(self, other, rtol = 0.000010, atol = 0.000000, equal_nan = FALSE) {
  args <- rlang::env_get_list(nms = c("self", "other", "rtol", "atol", "equal_nan"))
expected_types <- list(self = "Tensor", other = "Tensor", rtol = "double", atol = "double", 
    equal_nan = "bool")
nd_args <- c("self", "other")
return_types <- list(list('bool'))
call_c_function(
fun_name = 'allclose',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_alpha_dropout <- function(input, p, train) {
  args <- rlang::env_get_list(nms = c("input", "p", "train"))
expected_types <- list(input = "Tensor", p = "double", train = "bool")
nd_args <- c("input", "p", "train")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'alpha_dropout',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_alpha_dropout_ <- function(self, p, train) {
  args <- rlang::env_get_list(nms = c("self", "p", "train"))
expected_types <- list(self = "Tensor", p = "double", train = "bool")
nd_args <- c("self", "p", "train")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'alpha_dropout_',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_angle <- function(self) {
  args <- rlang::env_get_list(nms = c("self"))
expected_types <- list(self = "Tensor")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'angle',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_angle_out <- function(out, self) {
  args <- rlang::env_get_list(nms = c("out", "self"))
expected_types <- list(out = "Tensor", self = "Tensor")
nd_args <- c("out", "self")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'angle_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_any <- function(self, dim, keepdim = FALSE) {
  args <- rlang::env_get_list(nms = c("self", "dim", "keepdim"))
expected_types <- list(self = "Tensor", dim = c("int64_t", "Dimname"), keepdim = "bool")
nd_args <- c("self", "dim")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'any',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_any_out <- function(out, self, dim, keepdim = FALSE) {
  args <- rlang::env_get_list(nms = c("out", "self", "dim", "keepdim"))
expected_types <- list(out = "Tensor", self = "Tensor", dim = c("int64_t", "Dimname"
), keepdim = "bool")
nd_args <- c("out", "self", "dim")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'any_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


.torch_arange <- function(start, end, step, options = list()) {
  args <- rlang::env_get_list(nms = c("start", "end", "step", "options"))
expected_types <- list(start = "Scalar", end = "Scalar", step = "Scalar", options = "TensorOptions")
nd_args <- c("start", "end", "step")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'arange',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_arange_out <- function(out, start, end, step = 1) {
  args <- rlang::env_get_list(nms = c("out", "start", "end", "step"))
expected_types <- list(out = "Tensor", start = "Scalar", end = "Scalar", step = "Scalar")
nd_args <- c("out", "start", "end")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'arange_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_argmax <- function(self, dim = NULL, keepdim = FALSE) {
  args <- rlang::env_get_list(nms = c("self", "dim", "keepdim"))
expected_types <- list(self = "Tensor", dim = "int64_t", keepdim = "bool")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'argmax',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_argmin <- function(self, dim = NULL, keepdim = FALSE) {
  args <- rlang::env_get_list(nms = c("self", "dim", "keepdim"))
expected_types <- list(self = "Tensor", dim = "int64_t", keepdim = "bool")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'argmin',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_argsort <- function(self, dim = -1, descending = FALSE) {
  args <- rlang::env_get_list(nms = c("self", "dim", "descending"))
expected_types <- list(self = "Tensor", dim = c("int64_t", "Dimname"), descending = "bool")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'argsort',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_as_strided <- function(self, size, stride, storage_offset = NULL) {
  args <- rlang::env_get_list(nms = c("self", "size", "stride", "storage_offset"))
expected_types <- list(self = "Tensor", size = "IntArrayRef", stride = "IntArrayRef", 
    storage_offset = "int64_t")
nd_args <- c("self", "size", "stride")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'as_strided',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_as_strided_ <- function(self, size, stride, storage_offset = NULL) {
  args <- rlang::env_get_list(nms = c("self", "size", "stride", "storage_offset"))
expected_types <- list(self = "Tensor", size = "IntArrayRef", stride = "IntArrayRef", 
    storage_offset = "int64_t")
nd_args <- c("self", "size", "stride")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'as_strided_',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_asin <- function(self) {
  args <- rlang::env_get_list(nms = c("self"))
expected_types <- list(self = "Tensor")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'asin',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_asin_ <- function(self) {
  args <- rlang::env_get_list(nms = c("self"))
expected_types <- list(self = "Tensor")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'asin_',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_asin_out <- function(out, self) {
  args <- rlang::env_get_list(nms = c("out", "self"))
expected_types <- list(out = "Tensor", self = "Tensor")
nd_args <- c("out", "self")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'asin_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_atan <- function(self) {
  args <- rlang::env_get_list(nms = c("self"))
expected_types <- list(self = "Tensor")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'atan',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_atan_ <- function(self) {
  args <- rlang::env_get_list(nms = c("self"))
expected_types <- list(self = "Tensor")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'atan_',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_atan_out <- function(out, self) {
  args <- rlang::env_get_list(nms = c("out", "self"))
expected_types <- list(out = "Tensor", self = "Tensor")
nd_args <- c("out", "self")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'atan_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_atan2 <- function(self, other) {
  args <- rlang::env_get_list(nms = c("self", "other"))
expected_types <- list(self = "Tensor", other = "Tensor")
nd_args <- c("self", "other")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'atan2',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_atan2_out <- function(out, self, other) {
  args <- rlang::env_get_list(nms = c("out", "self", "other"))
expected_types <- list(out = "Tensor", self = "Tensor", other = "Tensor")
nd_args <- c("out", "self", "other")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'atan2_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_avg_pool1d <- function(self, kernel_size, stride = list(), padding = 0, ceil_mode = FALSE, count_include_pad = TRUE) {
  args <- rlang::env_get_list(nms = c("self", "kernel_size", "stride", "padding", "ceil_mode", "count_include_pad"))
expected_types <- list(self = "Tensor", kernel_size = "IntArrayRef", stride = "IntArrayRef", 
    padding = "IntArrayRef", ceil_mode = "bool", count_include_pad = "bool")
nd_args <- c("self", "kernel_size")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'avg_pool1d',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_avg_pool2d <- function(self, kernel_size, stride = list(), padding = 0, ceil_mode = FALSE, count_include_pad = TRUE, divisor_override = NULL) {
  args <- rlang::env_get_list(nms = c("self", "kernel_size", "stride", "padding", "ceil_mode", "count_include_pad", "divisor_override"))
expected_types <- list(self = "Tensor", kernel_size = "IntArrayRef", stride = "IntArrayRef", 
    padding = "IntArrayRef", ceil_mode = "bool", count_include_pad = "bool", 
    divisor_override = "int64_t")
nd_args <- c("self", "kernel_size")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'avg_pool2d',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_avg_pool2d_backward <- function(grad_output, self, kernel_size, stride, padding, ceil_mode, count_include_pad, divisor_override) {
  args <- rlang::env_get_list(nms = c("grad_output", "self", "kernel_size", "stride", "padding", "ceil_mode", "count_include_pad", "divisor_override"))
expected_types <- list(grad_output = "Tensor", self = "Tensor", kernel_size = "IntArrayRef", 
    stride = "IntArrayRef", padding = "IntArrayRef", ceil_mode = "bool", 
    count_include_pad = "bool", divisor_override = "int64_t")
nd_args <- c("grad_output", "self", "kernel_size", "stride", "padding", 
"ceil_mode", "count_include_pad", "divisor_override")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'avg_pool2d_backward',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_avg_pool2d_backward_out <- function(grad_input, grad_output, self, kernel_size, stride, padding, ceil_mode, count_include_pad, divisor_override) {
  args <- rlang::env_get_list(nms = c("grad_input", "grad_output", "self", "kernel_size", "stride", "padding", "ceil_mode", "count_include_pad", "divisor_override"))
expected_types <- list(grad_input = "Tensor", grad_output = "Tensor", self = "Tensor", 
    kernel_size = "IntArrayRef", stride = "IntArrayRef", padding = "IntArrayRef", 
    ceil_mode = "bool", count_include_pad = "bool", divisor_override = "int64_t")
nd_args <- c("grad_input", "grad_output", "self", "kernel_size", "stride", 
"padding", "ceil_mode", "count_include_pad", "divisor_override"
)
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'avg_pool2d_backward_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_avg_pool2d_out <- function(out, self, kernel_size, stride = list(), padding = 0, ceil_mode = FALSE, count_include_pad = TRUE, divisor_override = NULL) {
  args <- rlang::env_get_list(nms = c("out", "self", "kernel_size", "stride", "padding", "ceil_mode", "count_include_pad", "divisor_override"))
expected_types <- list(out = "Tensor", self = "Tensor", kernel_size = "IntArrayRef", 
    stride = "IntArrayRef", padding = "IntArrayRef", ceil_mode = "bool", 
    count_include_pad = "bool", divisor_override = "int64_t")
nd_args <- c("out", "self", "kernel_size")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'avg_pool2d_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_avg_pool3d <- function(self, kernel_size, stride = list(), padding = 0, ceil_mode = FALSE, count_include_pad = TRUE, divisor_override = NULL) {
  args <- rlang::env_get_list(nms = c("self", "kernel_size", "stride", "padding", "ceil_mode", "count_include_pad", "divisor_override"))
expected_types <- list(self = "Tensor", kernel_size = "IntArrayRef", stride = "IntArrayRef", 
    padding = "IntArrayRef", ceil_mode = "bool", count_include_pad = "bool", 
    divisor_override = "int64_t")
nd_args <- c("self", "kernel_size")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'avg_pool3d',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_avg_pool3d_backward <- function(grad_output, self, kernel_size, stride, padding, ceil_mode, count_include_pad, divisor_override) {
  args <- rlang::env_get_list(nms = c("grad_output", "self", "kernel_size", "stride", "padding", "ceil_mode", "count_include_pad", "divisor_override"))
expected_types <- list(grad_output = "Tensor", self = "Tensor", kernel_size = "IntArrayRef", 
    stride = "IntArrayRef", padding = "IntArrayRef", ceil_mode = "bool", 
    count_include_pad = "bool", divisor_override = "int64_t")
nd_args <- c("grad_output", "self", "kernel_size", "stride", "padding", 
"ceil_mode", "count_include_pad", "divisor_override")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'avg_pool3d_backward',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_avg_pool3d_backward_out <- function(grad_input, grad_output, self, kernel_size, stride, padding, ceil_mode, count_include_pad, divisor_override) {
  args <- rlang::env_get_list(nms = c("grad_input", "grad_output", "self", "kernel_size", "stride", "padding", "ceil_mode", "count_include_pad", "divisor_override"))
expected_types <- list(grad_input = "Tensor", grad_output = "Tensor", self = "Tensor", 
    kernel_size = "IntArrayRef", stride = "IntArrayRef", padding = "IntArrayRef", 
    ceil_mode = "bool", count_include_pad = "bool", divisor_override = "int64_t")
nd_args <- c("grad_input", "grad_output", "self", "kernel_size", "stride", 
"padding", "ceil_mode", "count_include_pad", "divisor_override"
)
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'avg_pool3d_backward_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_avg_pool3d_out <- function(out, self, kernel_size, stride = list(), padding = 0, ceil_mode = FALSE, count_include_pad = TRUE, divisor_override = NULL) {
  args <- rlang::env_get_list(nms = c("out", "self", "kernel_size", "stride", "padding", "ceil_mode", "count_include_pad", "divisor_override"))
expected_types <- list(out = "Tensor", self = "Tensor", kernel_size = "IntArrayRef", 
    stride = "IntArrayRef", padding = "IntArrayRef", ceil_mode = "bool", 
    count_include_pad = "bool", divisor_override = "int64_t")
nd_args <- c("out", "self", "kernel_size")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'avg_pool3d_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_baddbmm <- function(self, batch1, batch2, beta = 1, alpha = 1) {
  args <- rlang::env_get_list(nms = c("self", "batch1", "batch2", "beta", "alpha"))
expected_types <- list(self = "Tensor", batch1 = "Tensor", batch2 = "Tensor", beta = "Scalar", 
    alpha = "Scalar")
nd_args <- c("self", "batch1", "batch2")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'baddbmm',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_baddbmm_out <- function(out, self, batch1, batch2, beta = 1, alpha = 1) {
  args <- rlang::env_get_list(nms = c("out", "self", "batch1", "batch2", "beta", "alpha"))
expected_types <- list(out = "Tensor", self = "Tensor", batch1 = "Tensor", batch2 = "Tensor", 
    beta = "Scalar", alpha = "Scalar")
nd_args <- c("out", "self", "batch1", "batch2")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'baddbmm_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_bartlett_window <- function(window_length, periodic, options = list()) {
  args <- rlang::env_get_list(nms = c("window_length", "periodic", "options"))
expected_types <- list(window_length = "int64_t", periodic = "bool", options = "TensorOptions")
nd_args <- c("window_length", "periodic")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'bartlett_window',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_batch_norm <- function(input, weight, bias, running_mean, running_var, training, momentum, eps, cudnn_enabled) {
  args <- rlang::env_get_list(nms = c("input", "weight", "bias", "running_mean", "running_var", "training", "momentum", "eps", "cudnn_enabled"))
expected_types <- list(input = "Tensor", weight = "Tensor", bias = "Tensor", running_mean = "Tensor", 
    running_var = "Tensor", training = "bool", momentum = "double", 
    eps = "double", cudnn_enabled = "bool")
nd_args <- c("input", "weight", "bias", "running_mean", "running_var", "training", 
"momentum", "eps", "cudnn_enabled")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'batch_norm',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_batch_norm_backward_elemt <- function(grad_out, input, mean, invstd, weight, mean_dy, mean_dy_xmu) {
  args <- rlang::env_get_list(nms = c("grad_out", "input", "mean", "invstd", "weight", "mean_dy", "mean_dy_xmu"))
expected_types <- list(grad_out = "Tensor", input = "Tensor", mean = "Tensor", 
    invstd = "Tensor", weight = "Tensor", mean_dy = "Tensor", 
    mean_dy_xmu = "Tensor")
nd_args <- c("grad_out", "input", "mean", "invstd", "weight", "mean_dy", 
"mean_dy_xmu")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'batch_norm_backward_elemt',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_batch_norm_backward_reduce <- function(grad_out, input, mean, invstd, weight, input_g, weight_g, bias_g) {
  args <- rlang::env_get_list(nms = c("grad_out", "input", "mean", "invstd", "weight", "input_g", "weight_g", "bias_g"))
expected_types <- list(grad_out = "Tensor", input = "Tensor", mean = "Tensor", 
    invstd = "Tensor", weight = "Tensor", input_g = "bool", weight_g = "bool", 
    bias_g = "bool")
nd_args <- c("grad_out", "input", "mean", "invstd", "weight", "input_g", 
"weight_g", "bias_g")
return_types <- list(list("Tensor", "Tensor", "Tensor", "Tensor"))
call_c_function(
fun_name = 'batch_norm_backward_reduce',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_batch_norm_elemt <- function(input, weight, bias, mean, invstd, eps) {
  args <- rlang::env_get_list(nms = c("input", "weight", "bias", "mean", "invstd", "eps"))
expected_types <- list(input = "Tensor", weight = "Tensor", bias = "Tensor", mean = "Tensor", 
    invstd = "Tensor", eps = "double")
nd_args <- c("input", "weight", "bias", "mean", "invstd", "eps")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'batch_norm_elemt',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_batch_norm_elemt_out <- function(out, input, weight, bias, mean, invstd, eps) {
  args <- rlang::env_get_list(nms = c("out", "input", "weight", "bias", "mean", "invstd", "eps"))
expected_types <- list(out = "Tensor", input = "Tensor", weight = "Tensor", bias = "Tensor", 
    mean = "Tensor", invstd = "Tensor", eps = "double")
nd_args <- c("out", "input", "weight", "bias", "mean", "invstd", "eps")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'batch_norm_elemt_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_batch_norm_gather_stats <- function(input, mean, invstd, running_mean, running_var, momentum, eps, count) {
  args <- rlang::env_get_list(nms = c("input", "mean", "invstd", "running_mean", "running_var", "momentum", "eps", "count"))
expected_types <- list(input = "Tensor", mean = "Tensor", invstd = "Tensor", running_mean = "Tensor", 
    running_var = "Tensor", momentum = "double", eps = "double", 
    count = "int64_t")
nd_args <- c("input", "mean", "invstd", "running_mean", "running_var", "momentum", 
"eps", "count")
return_types <- list(list("Tensor", "Tensor"))
call_c_function(
fun_name = 'batch_norm_gather_stats',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_batch_norm_gather_stats_with_counts <- function(input, mean, invstd, running_mean, running_var, momentum, eps, counts) {
  args <- rlang::env_get_list(nms = c("input", "mean", "invstd", "running_mean", "running_var", "momentum", "eps", "counts"))
expected_types <- list(input = "Tensor", mean = "Tensor", invstd = "Tensor", running_mean = "Tensor", 
    running_var = "Tensor", momentum = "double", eps = "double", 
    counts = "IntArrayRef")
nd_args <- c("input", "mean", "invstd", "running_mean", "running_var", "momentum", 
"eps", "counts")
return_types <- list(list("Tensor", "Tensor"))
call_c_function(
fun_name = 'batch_norm_gather_stats_with_counts',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_batch_norm_stats <- function(input, eps) {
  args <- rlang::env_get_list(nms = c("input", "eps"))
expected_types <- list(input = "Tensor", eps = "double")
nd_args <- c("input", "eps")
return_types <- list(list("Tensor", "Tensor"))
call_c_function(
fun_name = 'batch_norm_stats',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_batch_norm_update_stats <- function(input, running_mean, running_var, momentum) {
  args <- rlang::env_get_list(nms = c("input", "running_mean", "running_var", "momentum"))
expected_types <- list(input = "Tensor", running_mean = "Tensor", running_var = "Tensor", 
    momentum = "double")
nd_args <- c("input", "running_mean", "running_var", "momentum")
return_types <- list(list("Tensor", "Tensor"))
call_c_function(
fun_name = 'batch_norm_update_stats',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_bernoulli <- function(self, p, generator = NULL) {
  args <- rlang::env_get_list(nms = c("self", "p", "generator"))
expected_types <- list(self = "Tensor", p = "double", generator = "Generator *")
nd_args <- c("self", "p")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'bernoulli',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_bernoulli_out <- function(out, self, generator = NULL) {
  args <- rlang::env_get_list(nms = c("out", "self", "generator"))
expected_types <- list(out = "Tensor", self = "Tensor", generator = "Generator *")
nd_args <- c("out", "self")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'bernoulli_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_bilinear <- function(input1, input2, weight, bias) {
  args <- rlang::env_get_list(nms = c("input1", "input2", "weight", "bias"))
expected_types <- list(input1 = "Tensor", input2 = "Tensor", weight = "Tensor", 
    bias = "Tensor")
nd_args <- c("input1", "input2", "weight", "bias")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'bilinear',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_binary_cross_entropy <- function(self, target, weight = list(), reduction = torch_reduction_mean()) {
  args <- rlang::env_get_list(nms = c("self", "target", "weight", "reduction"))
expected_types <- list(self = "Tensor", target = "Tensor", weight = "Tensor", reduction = "int64_t")
nd_args <- c("self", "target")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'binary_cross_entropy',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_binary_cross_entropy_backward <- function(grad_output, self, target, weight = list(), reduction = torch_reduction_mean()) {
  args <- rlang::env_get_list(nms = c("grad_output", "self", "target", "weight", "reduction"))
expected_types <- list(grad_output = "Tensor", self = "Tensor", target = "Tensor", 
    weight = "Tensor", reduction = "int64_t")
nd_args <- c("grad_output", "self", "target")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'binary_cross_entropy_backward',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_binary_cross_entropy_backward_out <- function(grad_input, grad_output, self, target, weight = list(), reduction = torch_reduction_mean()) {
  args <- rlang::env_get_list(nms = c("grad_input", "grad_output", "self", "target", "weight", "reduction"))
expected_types <- list(grad_input = "Tensor", grad_output = "Tensor", self = "Tensor", 
    target = "Tensor", weight = "Tensor", reduction = "int64_t")
nd_args <- c("grad_input", "grad_output", "self", "target")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'binary_cross_entropy_backward_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_binary_cross_entropy_out <- function(out, self, target, weight = list(), reduction = torch_reduction_mean()) {
  args <- rlang::env_get_list(nms = c("out", "self", "target", "weight", "reduction"))
expected_types <- list(out = "Tensor", self = "Tensor", target = "Tensor", weight = "Tensor", 
    reduction = "int64_t")
nd_args <- c("out", "self", "target")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'binary_cross_entropy_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_binary_cross_entropy_with_logits <- function(self, target, weight = list(), pos_weight = list(), reduction = torch_reduction_mean()) {
  args <- rlang::env_get_list(nms = c("self", "target", "weight", "pos_weight", "reduction"))
expected_types <- list(self = "Tensor", target = "Tensor", weight = "Tensor", pos_weight = "Tensor", 
    reduction = "int64_t")
nd_args <- c("self", "target")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'binary_cross_entropy_with_logits',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_binary_cross_entropy_with_logits_backward <- function(grad_output, self, target, weight = list(), pos_weight = list(), reduction = torch_reduction_mean()) {
  args <- rlang::env_get_list(nms = c("grad_output", "self", "target", "weight", "pos_weight", "reduction"))
expected_types <- list(grad_output = "Tensor", self = "Tensor", target = "Tensor", 
    weight = "Tensor", pos_weight = "Tensor", reduction = "int64_t")
nd_args <- c("grad_output", "self", "target")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'binary_cross_entropy_with_logits_backward',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_bincount <- function(self, weights = list(), minlength = 0) {
  args <- rlang::env_get_list(nms = c("self", "weights", "minlength"))
expected_types <- list(self = "Tensor", weights = "Tensor", minlength = "int64_t")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'bincount',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_bitwise_and <- function(self, other) {
  args <- rlang::env_get_list(nms = c("self", "other"))
expected_types <- list(self = "Tensor", other = c("Scalar", "Tensor"))
nd_args <- c("self", "other")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'bitwise_and',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_bitwise_and_out <- function(out, self, other) {
  args <- rlang::env_get_list(nms = c("out", "self", "other"))
expected_types <- list(out = "Tensor", self = "Tensor", other = c("Tensor", "Scalar"
))
nd_args <- c("out", "self", "other")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'bitwise_and_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_bitwise_not <- function(self) {
  args <- rlang::env_get_list(nms = c("self"))
expected_types <- list(self = "Tensor")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'bitwise_not',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_bitwise_not_out <- function(out, self) {
  args <- rlang::env_get_list(nms = c("out", "self"))
expected_types <- list(out = "Tensor", self = "Tensor")
nd_args <- c("out", "self")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'bitwise_not_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_bitwise_or <- function(self, other) {
  args <- rlang::env_get_list(nms = c("self", "other"))
expected_types <- list(self = "Tensor", other = c("Scalar", "Tensor"))
nd_args <- c("self", "other")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'bitwise_or',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_bitwise_or_out <- function(out, self, other) {
  args <- rlang::env_get_list(nms = c("out", "self", "other"))
expected_types <- list(out = "Tensor", self = "Tensor", other = c("Tensor", "Scalar"
))
nd_args <- c("out", "self", "other")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'bitwise_or_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_bitwise_xor <- function(self, other) {
  args <- rlang::env_get_list(nms = c("self", "other"))
expected_types <- list(self = "Tensor", other = c("Scalar", "Tensor"))
nd_args <- c("self", "other")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'bitwise_xor',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_bitwise_xor_out <- function(out, self, other) {
  args <- rlang::env_get_list(nms = c("out", "self", "other"))
expected_types <- list(out = "Tensor", self = "Tensor", other = c("Tensor", "Scalar"
))
nd_args <- c("out", "self", "other")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'bitwise_xor_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_blackman_window <- function(window_length, periodic, options = list()) {
  args <- rlang::env_get_list(nms = c("window_length", "periodic", "options"))
expected_types <- list(window_length = "int64_t", periodic = "bool", options = "TensorOptions")
nd_args <- c("window_length", "periodic")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'blackman_window',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_bmm <- function(self, mat2) {
  args <- rlang::env_get_list(nms = c("self", "mat2"))
expected_types <- list(self = "Tensor", mat2 = "Tensor")
nd_args <- c("self", "mat2")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'bmm',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_bmm_out <- function(out, self, mat2) {
  args <- rlang::env_get_list(nms = c("out", "self", "mat2"))
expected_types <- list(out = "Tensor", self = "Tensor", mat2 = "Tensor")
nd_args <- c("out", "self", "mat2")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'bmm_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_broadcast_tensors <- function(tensors) {
  args <- rlang::env_get_list(nms = c("tensors"))
expected_types <- list(tensors = "TensorList")
nd_args <- "tensors"
return_types <- list(list('TensorList'))
call_c_function(
fun_name = 'broadcast_tensors',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_can_cast <- function(from, to) {
  args <- rlang::env_get_list(nms = c("from", "to"))
expected_types <- list(from = "ScalarType", to = "ScalarType")
nd_args <- c("from", "to")
return_types <- list(list('bool'))
call_c_function(
fun_name = 'can_cast',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_cartesian_prod <- function(tensors) {
  args <- rlang::env_get_list(nms = c("tensors"))
expected_types <- list(tensors = "TensorList")
nd_args <- "tensors"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'cartesian_prod',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_cat <- function(tensors, dim = 0) {
  args <- rlang::env_get_list(nms = c("tensors", "dim"))
expected_types <- list(tensors = "TensorList", dim = c("int64_t", "Dimname"))
nd_args <- "tensors"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'cat',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_cat_out <- function(out, tensors, dim = 0) {
  args <- rlang::env_get_list(nms = c("out", "tensors", "dim"))
expected_types <- list(out = "Tensor", tensors = "TensorList", dim = c("int64_t", 
"Dimname"))
nd_args <- c("out", "tensors")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'cat_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_cdist <- function(x1, x2, p = 2, compute_mode = NULL) {
  args <- rlang::env_get_list(nms = c("x1", "x2", "p", "compute_mode"))
expected_types <- list(x1 = "Tensor", x2 = "Tensor", p = "double", compute_mode = "int64_t")
nd_args <- c("x1", "x2")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'cdist',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_ceil <- function(self) {
  args <- rlang::env_get_list(nms = c("self"))
expected_types <- list(self = "Tensor")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'ceil',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_ceil_ <- function(self) {
  args <- rlang::env_get_list(nms = c("self"))
expected_types <- list(self = "Tensor")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'ceil_',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_ceil_out <- function(out, self) {
  args <- rlang::env_get_list(nms = c("out", "self"))
expected_types <- list(out = "Tensor", self = "Tensor")
nd_args <- c("out", "self")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'ceil_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_celu <- function(self, alpha = 1.000000) {
  args <- rlang::env_get_list(nms = c("self", "alpha"))
expected_types <- list(self = "Tensor", alpha = "Scalar")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'celu',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_celu_ <- function(self, alpha = 1.000000) {
  args <- rlang::env_get_list(nms = c("self", "alpha"))
expected_types <- list(self = "Tensor", alpha = "Scalar")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'celu_',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_chain_matmul <- function(matrices) {
  args <- rlang::env_get_list(nms = c("matrices"))
expected_types <- list(matrices = "TensorList")
nd_args <- "matrices"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'chain_matmul',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_cholesky <- function(self, upper = FALSE) {
  args <- rlang::env_get_list(nms = c("self", "upper"))
expected_types <- list(self = "Tensor", upper = "bool")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'cholesky',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_cholesky_inverse <- function(self, upper = FALSE) {
  args <- rlang::env_get_list(nms = c("self", "upper"))
expected_types <- list(self = "Tensor", upper = "bool")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'cholesky_inverse',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_cholesky_inverse_out <- function(out, self, upper = FALSE) {
  args <- rlang::env_get_list(nms = c("out", "self", "upper"))
expected_types <- list(out = "Tensor", self = "Tensor", upper = "bool")
nd_args <- c("out", "self")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'cholesky_inverse_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_cholesky_out <- function(out, self, upper = FALSE) {
  args <- rlang::env_get_list(nms = c("out", "self", "upper"))
expected_types <- list(out = "Tensor", self = "Tensor", upper = "bool")
nd_args <- c("out", "self")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'cholesky_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_cholesky_solve <- function(self, input2, upper = FALSE) {
  args <- rlang::env_get_list(nms = c("self", "input2", "upper"))
expected_types <- list(self = "Tensor", input2 = "Tensor", upper = "bool")
nd_args <- c("self", "input2")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'cholesky_solve',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_cholesky_solve_out <- function(out, self, input2, upper = FALSE) {
  args <- rlang::env_get_list(nms = c("out", "self", "input2", "upper"))
expected_types <- list(out = "Tensor", self = "Tensor", input2 = "Tensor", upper = "bool")
nd_args <- c("out", "self", "input2")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'cholesky_solve_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_chunk <- function(self, chunks, dim = 0) {
  args <- rlang::env_get_list(nms = c("self", "chunks", "dim"))
expected_types <- list(self = "Tensor", chunks = "int64_t", dim = "int64_t")
nd_args <- c("self", "chunks")
return_types <- list(list('TensorList'))
call_c_function(
fun_name = 'chunk',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_clamp <- function(self, min = NULL, max = NULL) {
  args <- rlang::env_get_list(nms = c("self", "min", "max"))
expected_types <- list(self = "Tensor", min = "Scalar", max = "Scalar")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'clamp',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_clamp_ <- function(self, min = NULL, max = NULL) {
  args <- rlang::env_get_list(nms = c("self", "min", "max"))
expected_types <- list(self = "Tensor", min = "Scalar", max = "Scalar")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'clamp_',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_clamp_max <- function(self, max) {
  args <- rlang::env_get_list(nms = c("self", "max"))
expected_types <- list(self = "Tensor", max = "Scalar")
nd_args <- c("self", "max")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'clamp_max',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_clamp_max_ <- function(self, max) {
  args <- rlang::env_get_list(nms = c("self", "max"))
expected_types <- list(self = "Tensor", max = "Scalar")
nd_args <- c("self", "max")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'clamp_max_',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_clamp_max_out <- function(out, self, max) {
  args <- rlang::env_get_list(nms = c("out", "self", "max"))
expected_types <- list(out = "Tensor", self = "Tensor", max = "Scalar")
nd_args <- c("out", "self", "max")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'clamp_max_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_clamp_min <- function(self, min) {
  args <- rlang::env_get_list(nms = c("self", "min"))
expected_types <- list(self = "Tensor", min = "Scalar")
nd_args <- c("self", "min")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'clamp_min',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_clamp_min_ <- function(self, min) {
  args <- rlang::env_get_list(nms = c("self", "min"))
expected_types <- list(self = "Tensor", min = "Scalar")
nd_args <- c("self", "min")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'clamp_min_',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_clamp_min_out <- function(out, self, min) {
  args <- rlang::env_get_list(nms = c("out", "self", "min"))
expected_types <- list(out = "Tensor", self = "Tensor", min = "Scalar")
nd_args <- c("out", "self", "min")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'clamp_min_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_clamp_out <- function(out, self, min = NULL, max = NULL) {
  args <- rlang::env_get_list(nms = c("out", "self", "min", "max"))
expected_types <- list(out = "Tensor", self = "Tensor", min = "Scalar", max = "Scalar")
nd_args <- c("out", "self")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'clamp_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_clone <- function(self, memory_format = NULL) {
  args <- rlang::env_get_list(nms = c("self", "memory_format"))
expected_types <- list(self = "Tensor", memory_format = "MemoryFormat")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'clone',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_col2im <- function(self, output_size, kernel_size, dilation, padding, stride) {
  args <- rlang::env_get_list(nms = c("self", "output_size", "kernel_size", "dilation", "padding", "stride"))
expected_types <- list(self = "Tensor", output_size = "IntArrayRef", kernel_size = "IntArrayRef", 
    dilation = "IntArrayRef", padding = "IntArrayRef", stride = "IntArrayRef")
nd_args <- c("self", "output_size", "kernel_size", "dilation", "padding", 
"stride")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'col2im',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_col2im_backward <- function(grad_output, kernel_size, dilation, padding, stride) {
  args <- rlang::env_get_list(nms = c("grad_output", "kernel_size", "dilation", "padding", "stride"))
expected_types <- list(grad_output = "Tensor", kernel_size = "IntArrayRef", dilation = "IntArrayRef", 
    padding = "IntArrayRef", stride = "IntArrayRef")
nd_args <- c("grad_output", "kernel_size", "dilation", "padding", "stride"
)
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'col2im_backward',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_col2im_backward_out <- function(grad_input, grad_output, kernel_size, dilation, padding, stride) {
  args <- rlang::env_get_list(nms = c("grad_input", "grad_output", "kernel_size", "dilation", "padding", "stride"))
expected_types <- list(grad_input = "Tensor", grad_output = "Tensor", kernel_size = "IntArrayRef", 
    dilation = "IntArrayRef", padding = "IntArrayRef", stride = "IntArrayRef")
nd_args <- c("grad_input", "grad_output", "kernel_size", "dilation", "padding", 
"stride")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'col2im_backward_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_col2im_out <- function(out, self, output_size, kernel_size, dilation, padding, stride) {
  args <- rlang::env_get_list(nms = c("out", "self", "output_size", "kernel_size", "dilation", "padding", "stride"))
expected_types <- list(out = "Tensor", self = "Tensor", output_size = "IntArrayRef", 
    kernel_size = "IntArrayRef", dilation = "IntArrayRef", padding = "IntArrayRef", 
    stride = "IntArrayRef")
nd_args <- c("out", "self", "output_size", "kernel_size", "dilation", "padding", 
"stride")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'col2im_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_combinations <- function(self, r = 2, with_replacement = FALSE) {
  args <- rlang::env_get_list(nms = c("self", "r", "with_replacement"))
expected_types <- list(self = "Tensor", r = "int64_t", with_replacement = "bool")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'combinations',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_conj <- function(self) {
  args <- rlang::env_get_list(nms = c("self"))
expected_types <- list(self = "Tensor")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'conj',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_conj_out <- function(out, self) {
  args <- rlang::env_get_list(nms = c("out", "self"))
expected_types <- list(out = "Tensor", self = "Tensor")
nd_args <- c("out", "self")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'conj_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_constant_pad_nd <- function(self, pad, value = 0) {
  args <- rlang::env_get_list(nms = c("self", "pad", "value"))
expected_types <- list(self = "Tensor", pad = "IntArrayRef", value = "Scalar")
nd_args <- c("self", "pad")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'constant_pad_nd',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_conv_tbc <- function(self, weight, bias, pad = 0) {
  args <- rlang::env_get_list(nms = c("self", "weight", "bias", "pad"))
expected_types <- list(self = "Tensor", weight = "Tensor", bias = "Tensor", pad = "int64_t")
nd_args <- c("self", "weight", "bias")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'conv_tbc',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_conv_tbc_backward <- function(self, input, weight, bias, pad) {
  args <- rlang::env_get_list(nms = c("self", "input", "weight", "bias", "pad"))
expected_types <- list(self = "Tensor", input = "Tensor", weight = "Tensor", bias = "Tensor", 
    pad = "int64_t")
nd_args <- c("self", "input", "weight", "bias", "pad")
return_types <- list(list("Tensor", "Tensor", "Tensor"))
call_c_function(
fun_name = 'conv_tbc_backward',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_conv_transpose1d <- function(input, weight, bias = list(), stride = 1, padding = 0, output_padding = 0, groups = 1, dilation = 1) {
  args <- rlang::env_get_list(nms = c("input", "weight", "bias", "stride", "padding", "output_padding", "groups", "dilation"))
expected_types <- list(input = "Tensor", weight = "Tensor", bias = "Tensor", stride = "IntArrayRef", 
    padding = "IntArrayRef", output_padding = "IntArrayRef", 
    groups = "int64_t", dilation = "IntArrayRef")
nd_args <- c("input", "weight")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'conv_transpose1d',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_conv_transpose2d <- function(input, weight, bias = list(), stride = 1, padding = 0, output_padding = 0, groups = 1, dilation = 1) {
  args <- rlang::env_get_list(nms = c("input", "weight", "bias", "stride", "padding", "output_padding", "groups", "dilation"))
expected_types <- list(input = "Tensor", weight = "Tensor", bias = "Tensor", stride = "IntArrayRef", 
    padding = "IntArrayRef", output_padding = "IntArrayRef", 
    groups = "int64_t", dilation = "IntArrayRef")
nd_args <- c("input", "weight")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'conv_transpose2d',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_conv_transpose3d <- function(input, weight, bias = list(), stride = 1, padding = 0, output_padding = 0, groups = 1, dilation = 1) {
  args <- rlang::env_get_list(nms = c("input", "weight", "bias", "stride", "padding", "output_padding", "groups", "dilation"))
expected_types <- list(input = "Tensor", weight = "Tensor", bias = "Tensor", stride = "IntArrayRef", 
    padding = "IntArrayRef", output_padding = "IntArrayRef", 
    groups = "int64_t", dilation = "IntArrayRef")
nd_args <- c("input", "weight")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'conv_transpose3d',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_conv1d <- function(input, weight, bias = list(), stride = 1, padding = 0, dilation = 1, groups = 1) {
  args <- rlang::env_get_list(nms = c("input", "weight", "bias", "stride", "padding", "dilation", "groups"))
expected_types <- list(input = "Tensor", weight = "Tensor", bias = "Tensor", stride = "IntArrayRef", 
    padding = "IntArrayRef", dilation = "IntArrayRef", groups = "int64_t")
nd_args <- c("input", "weight")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'conv1d',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_conv2d <- function(input, weight, bias = list(), stride = 1, padding = 0, dilation = 1, groups = 1) {
  args <- rlang::env_get_list(nms = c("input", "weight", "bias", "stride", "padding", "dilation", "groups"))
expected_types <- list(input = "Tensor", weight = "Tensor", bias = "Tensor", stride = "IntArrayRef", 
    padding = "IntArrayRef", dilation = "IntArrayRef", groups = "int64_t")
nd_args <- c("input", "weight")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'conv2d',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_conv3d <- function(input, weight, bias = list(), stride = 1, padding = 0, dilation = 1, groups = 1) {
  args <- rlang::env_get_list(nms = c("input", "weight", "bias", "stride", "padding", "dilation", "groups"))
expected_types <- list(input = "Tensor", weight = "Tensor", bias = "Tensor", stride = "IntArrayRef", 
    padding = "IntArrayRef", dilation = "IntArrayRef", groups = "int64_t")
nd_args <- c("input", "weight")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'conv3d',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_convolution <- function(input, weight, bias, stride, padding, dilation, transposed, output_padding, groups) {
  args <- rlang::env_get_list(nms = c("input", "weight", "bias", "stride", "padding", "dilation", "transposed", "output_padding", "groups"))
expected_types <- list(input = "Tensor", weight = "Tensor", bias = "Tensor", stride = "IntArrayRef", 
    padding = "IntArrayRef", dilation = "IntArrayRef", transposed = "bool", 
    output_padding = "IntArrayRef", groups = "int64_t")
nd_args <- c("input", "weight", "bias", "stride", "padding", "dilation", 
"transposed", "output_padding", "groups")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'convolution',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_convolution_backward_overrideable <- function(grad_output, input, weight, stride, padding, dilation, transposed, output_padding, groups, output_mask) {
  args <- rlang::env_get_list(nms = c("grad_output", "input", "weight", "stride", "padding", "dilation", "transposed", "output_padding", "groups", "output_mask"))
expected_types <- list(grad_output = "Tensor", input = "Tensor", weight = "Tensor", 
    stride = "IntArrayRef", padding = "IntArrayRef", dilation = "IntArrayRef", 
    transposed = "bool", output_padding = "IntArrayRef", groups = "int64_t", 
    output_mask = "std::array<bool,3>")
nd_args <- c("grad_output", "input", "weight", "stride", "padding", "dilation", 
"transposed", "output_padding", "groups", "output_mask")
return_types <- list(list("Tensor", "Tensor", "Tensor"))
call_c_function(
fun_name = 'convolution_backward_overrideable',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_convolution_overrideable <- function(input, weight, bias, stride, padding, dilation, transposed, output_padding, groups) {
  args <- rlang::env_get_list(nms = c("input", "weight", "bias", "stride", "padding", "dilation", "transposed", "output_padding", "groups"))
expected_types <- list(input = "Tensor", weight = "Tensor", bias = "Tensor", stride = "IntArrayRef", 
    padding = "IntArrayRef", dilation = "IntArrayRef", transposed = "bool", 
    output_padding = "IntArrayRef", groups = "int64_t")
nd_args <- c("input", "weight", "bias", "stride", "padding", "dilation", 
"transposed", "output_padding", "groups")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'convolution_overrideable',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_copy_sparse_to_sparse_ <- function(self, src, non_blocking = FALSE) {
  args <- rlang::env_get_list(nms = c("self", "src", "non_blocking"))
expected_types <- list(self = "Tensor", src = "Tensor", non_blocking = "bool")
nd_args <- c("self", "src")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'copy_sparse_to_sparse_',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_cos <- function(self) {
  args <- rlang::env_get_list(nms = c("self"))
expected_types <- list(self = "Tensor")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'cos',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_cos_ <- function(self) {
  args <- rlang::env_get_list(nms = c("self"))
expected_types <- list(self = "Tensor")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'cos_',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_cos_out <- function(out, self) {
  args <- rlang::env_get_list(nms = c("out", "self"))
expected_types <- list(out = "Tensor", self = "Tensor")
nd_args <- c("out", "self")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'cos_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_cosh <- function(self) {
  args <- rlang::env_get_list(nms = c("self"))
expected_types <- list(self = "Tensor")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'cosh',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_cosh_ <- function(self) {
  args <- rlang::env_get_list(nms = c("self"))
expected_types <- list(self = "Tensor")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'cosh_',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_cosh_out <- function(out, self) {
  args <- rlang::env_get_list(nms = c("out", "self"))
expected_types <- list(out = "Tensor", self = "Tensor")
nd_args <- c("out", "self")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'cosh_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_cosine_embedding_loss <- function(input1, input2, target, margin = 0.000000, reduction = torch_reduction_mean()) {
  args <- rlang::env_get_list(nms = c("input1", "input2", "target", "margin", "reduction"))
expected_types <- list(input1 = "Tensor", input2 = "Tensor", target = "Tensor", 
    margin = "double", reduction = "int64_t")
nd_args <- c("input1", "input2", "target")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'cosine_embedding_loss',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_cosine_similarity <- function(x1, x2, dim = 1, eps = 0.000000) {
  args <- rlang::env_get_list(nms = c("x1", "x2", "dim", "eps"))
expected_types <- list(x1 = "Tensor", x2 = "Tensor", dim = "int64_t", eps = "double")
nd_args <- c("x1", "x2")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'cosine_similarity',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_cross <- function(self, other, dim = NULL) {
  args <- rlang::env_get_list(nms = c("self", "other", "dim"))
expected_types <- list(self = "Tensor", other = "Tensor", dim = "int64_t")
nd_args <- c("self", "other")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'cross',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_cross_out <- function(out, self, other, dim = NULL) {
  args <- rlang::env_get_list(nms = c("out", "self", "other", "dim"))
expected_types <- list(out = "Tensor", self = "Tensor", other = "Tensor", dim = "int64_t")
nd_args <- c("out", "self", "other")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'cross_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_ctc_loss <- function(log_probs, targets, input_lengths, target_lengths, blank = 0, reduction = torch_reduction_mean(), zero_infinity = FALSE) {
  args <- rlang::env_get_list(nms = c("log_probs", "targets", "input_lengths", "target_lengths", "blank", "reduction", "zero_infinity"))
expected_types <- list(log_probs = "Tensor", targets = "Tensor", input_lengths = c("IntArrayRef", 
"Tensor"), target_lengths = c("IntArrayRef", "Tensor"), blank = "int64_t", 
    reduction = "int64_t", zero_infinity = "bool")
nd_args <- c("log_probs", "targets", "input_lengths", "target_lengths")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'ctc_loss',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_cudnn_affine_grid_generator <- function(theta, False, C, H, W) {
  args <- rlang::env_get_list(nms = c("theta", "False", "C", "H", "W"))
expected_types <- list(theta = "Tensor", False = "int64_t", C = "int64_t", H = "int64_t", 
    W = "int64_t")
nd_args <- c("theta", "False", "C", "H", "W")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'cudnn_affine_grid_generator',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_cudnn_affine_grid_generator_backward <- function(grad, False, C, H, W) {
  args <- rlang::env_get_list(nms = c("grad", "False", "C", "H", "W"))
expected_types <- list(grad = "Tensor", False = "int64_t", C = "int64_t", H = "int64_t", 
    W = "int64_t")
nd_args <- c("grad", "False", "C", "H", "W")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'cudnn_affine_grid_generator_backward',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_cudnn_batch_norm <- function(input, weight, bias, running_mean, running_var, training, exponential_average_factor, epsilon) {
  args <- rlang::env_get_list(nms = c("input", "weight", "bias", "running_mean", "running_var", "training", "exponential_average_factor", "epsilon"))
expected_types <- list(input = "Tensor", weight = "Tensor", bias = "Tensor", running_mean = "Tensor", 
    running_var = "Tensor", training = "bool", exponential_average_factor = "double", 
    epsilon = "double")
nd_args <- c("input", "weight", "bias", "running_mean", "running_var", "training", 
"exponential_average_factor", "epsilon")
return_types <- list(list("Tensor", "Tensor", "Tensor", "Tensor"))
call_c_function(
fun_name = 'cudnn_batch_norm',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_cudnn_batch_norm_backward <- function(input, grad_output, weight, running_mean, running_var, save_mean, save_var, epsilon, reserveSpace) {
  args <- rlang::env_get_list(nms = c("input", "grad_output", "weight", "running_mean", "running_var", "save_mean", "save_var", "epsilon", "reserveSpace"))
expected_types <- list(input = "Tensor", grad_output = "Tensor", weight = "Tensor", 
    running_mean = "Tensor", running_var = "Tensor", save_mean = "Tensor", 
    save_var = "Tensor", epsilon = "double", reserveSpace = "Tensor")
nd_args <- c("input", "grad_output", "weight", "running_mean", "running_var", 
"save_mean", "save_var", "epsilon", "reserveSpace")
return_types <- list(list("Tensor", "Tensor", "Tensor"))
call_c_function(
fun_name = 'cudnn_batch_norm_backward',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_cudnn_convolution <- function(self, weight, bias, padding, stride, dilation, groups, benchmark, deterministic) {
  args <- rlang::env_get_list(nms = c("self", "weight", "bias", "padding", "stride", "dilation", "groups", "benchmark", "deterministic"))
expected_types <- list(self = "Tensor", weight = "Tensor", bias = "Tensor", padding = "IntArrayRef", 
    stride = "IntArrayRef", dilation = "IntArrayRef", groups = "int64_t", 
    benchmark = "bool", deterministic = "bool")
nd_args <- c("self", "weight", "bias", "padding", "stride", "dilation", 
"groups", "benchmark", "deterministic")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'cudnn_convolution',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_cudnn_convolution_backward <- function(self, grad_output, weight, padding, stride, dilation, groups, benchmark, deterministic, output_mask) {
  args <- rlang::env_get_list(nms = c("self", "grad_output", "weight", "padding", "stride", "dilation", "groups", "benchmark", "deterministic", "output_mask"))
expected_types <- list(self = "Tensor", grad_output = "Tensor", weight = "Tensor", 
    padding = "IntArrayRef", stride = "IntArrayRef", dilation = "IntArrayRef", 
    groups = "int64_t", benchmark = "bool", deterministic = "bool", 
    output_mask = "std::array<bool,2>")
nd_args <- c("self", "grad_output", "weight", "padding", "stride", "dilation", 
"groups", "benchmark", "deterministic", "output_mask")
return_types <- list(list("Tensor", "Tensor"))
call_c_function(
fun_name = 'cudnn_convolution_backward',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_cudnn_convolution_backward_input <- function(self_size, grad_output, weight, padding, stride, dilation, groups, benchmark, deterministic) {
  args <- rlang::env_get_list(nms = c("self_size", "grad_output", "weight", "padding", "stride", "dilation", "groups", "benchmark", "deterministic"))
expected_types <- list(self_size = "IntArrayRef", grad_output = "Tensor", weight = "Tensor", 
    padding = "IntArrayRef", stride = "IntArrayRef", dilation = "IntArrayRef", 
    groups = "int64_t", benchmark = "bool", deterministic = "bool")
nd_args <- c("self_size", "grad_output", "weight", "padding", "stride", 
"dilation", "groups", "benchmark", "deterministic")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'cudnn_convolution_backward_input',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_cudnn_convolution_backward_weight <- function(weight_size, grad_output, self, padding, stride, dilation, groups, benchmark, deterministic) {
  args <- rlang::env_get_list(nms = c("weight_size", "grad_output", "self", "padding", "stride", "dilation", "groups", "benchmark", "deterministic"))
expected_types <- list(weight_size = "IntArrayRef", grad_output = "Tensor", self = "Tensor", 
    padding = "IntArrayRef", stride = "IntArrayRef", dilation = "IntArrayRef", 
    groups = "int64_t", benchmark = "bool", deterministic = "bool")
nd_args <- c("weight_size", "grad_output", "self", "padding", "stride", 
"dilation", "groups", "benchmark", "deterministic")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'cudnn_convolution_backward_weight',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_cudnn_convolution_transpose <- function(self, weight, bias, padding, output_padding, stride, dilation, groups, benchmark, deterministic) {
  args <- rlang::env_get_list(nms = c("self", "weight", "bias", "padding", "output_padding", "stride", "dilation", "groups", "benchmark", "deterministic"))
expected_types <- list(self = "Tensor", weight = "Tensor", bias = "Tensor", padding = "IntArrayRef", 
    output_padding = "IntArrayRef", stride = "IntArrayRef", dilation = "IntArrayRef", 
    groups = "int64_t", benchmark = "bool", deterministic = "bool")
nd_args <- c("self", "weight", "bias", "padding", "output_padding", "stride", 
"dilation", "groups", "benchmark", "deterministic")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'cudnn_convolution_transpose',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_cudnn_convolution_transpose_backward <- function(self, grad_output, weight, padding, output_padding, stride, dilation, groups, benchmark, deterministic, output_mask) {
  args <- rlang::env_get_list(nms = c("self", "grad_output", "weight", "padding", "output_padding", "stride", "dilation", "groups", "benchmark", "deterministic", "output_mask"))
expected_types <- list(self = "Tensor", grad_output = "Tensor", weight = "Tensor", 
    padding = "IntArrayRef", output_padding = "IntArrayRef", 
    stride = "IntArrayRef", dilation = "IntArrayRef", groups = "int64_t", 
    benchmark = "bool", deterministic = "bool", output_mask = "std::array<bool,2>")
nd_args <- c("self", "grad_output", "weight", "padding", "output_padding", 
"stride", "dilation", "groups", "benchmark", "deterministic", 
"output_mask")
return_types <- list(list("Tensor", "Tensor"))
call_c_function(
fun_name = 'cudnn_convolution_transpose_backward',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_cudnn_convolution_transpose_backward_input <- function(grad_output, weight, padding, stride, dilation, groups, benchmark, deterministic) {
  args <- rlang::env_get_list(nms = c("grad_output", "weight", "padding", "stride", "dilation", "groups", "benchmark", "deterministic"))
expected_types <- list(grad_output = "Tensor", weight = "Tensor", padding = "IntArrayRef", 
    stride = "IntArrayRef", dilation = "IntArrayRef", groups = "int64_t", 
    benchmark = "bool", deterministic = "bool")
nd_args <- c("grad_output", "weight", "padding", "stride", "dilation", "groups", 
"benchmark", "deterministic")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'cudnn_convolution_transpose_backward_input',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_cudnn_convolution_transpose_backward_weight <- function(weight_size, grad_output, self, padding, stride, dilation, groups, benchmark, deterministic) {
  args <- rlang::env_get_list(nms = c("weight_size", "grad_output", "self", "padding", "stride", "dilation", "groups", "benchmark", "deterministic"))
expected_types <- list(weight_size = "IntArrayRef", grad_output = "Tensor", self = "Tensor", 
    padding = "IntArrayRef", stride = "IntArrayRef", dilation = "IntArrayRef", 
    groups = "int64_t", benchmark = "bool", deterministic = "bool")
nd_args <- c("weight_size", "grad_output", "self", "padding", "stride", 
"dilation", "groups", "benchmark", "deterministic")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'cudnn_convolution_transpose_backward_weight',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_cudnn_grid_sampler <- function(self, grid) {
  args <- rlang::env_get_list(nms = c("self", "grid"))
expected_types <- list(self = "Tensor", grid = "Tensor")
nd_args <- c("self", "grid")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'cudnn_grid_sampler',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_cudnn_grid_sampler_backward <- function(self, grid, grad_output) {
  args <- rlang::env_get_list(nms = c("self", "grid", "grad_output"))
expected_types <- list(self = "Tensor", grid = "Tensor", grad_output = "Tensor")
nd_args <- c("self", "grid", "grad_output")
return_types <- list(list("Tensor", "Tensor"))
call_c_function(
fun_name = 'cudnn_grid_sampler_backward',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_cudnn_is_acceptable <- function(self) {
  args <- rlang::env_get_list(nms = c("self"))
expected_types <- list(self = "Tensor")
nd_args <- "self"
return_types <- list(list('bool'))
call_c_function(
fun_name = 'cudnn_is_acceptable',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_cummax <- function(self, dim) {
  args <- rlang::env_get_list(nms = c("self", "dim"))
expected_types <- list(self = "Tensor", dim = c("int64_t", "Dimname"))
nd_args <- c("self", "dim")
return_types <- list(list("Tensor", "Tensor"))
call_c_function(
fun_name = 'cummax',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_cummax_out <- function(values, indices, self, dim) {
  args <- rlang::env_get_list(nms = c("values", "indices", "self", "dim"))
expected_types <- list(values = "Tensor", indices = "Tensor", self = "Tensor", 
    dim = c("int64_t", "Dimname"))
nd_args <- c("values", "indices", "self", "dim")
return_types <- list(list("Tensor", "Tensor"))
call_c_function(
fun_name = 'cummax_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_cummin <- function(self, dim) {
  args <- rlang::env_get_list(nms = c("self", "dim"))
expected_types <- list(self = "Tensor", dim = c("int64_t", "Dimname"))
nd_args <- c("self", "dim")
return_types <- list(list("Tensor", "Tensor"))
call_c_function(
fun_name = 'cummin',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_cummin_out <- function(values, indices, self, dim) {
  args <- rlang::env_get_list(nms = c("values", "indices", "self", "dim"))
expected_types <- list(values = "Tensor", indices = "Tensor", self = "Tensor", 
    dim = c("int64_t", "Dimname"))
nd_args <- c("values", "indices", "self", "dim")
return_types <- list(list("Tensor", "Tensor"))
call_c_function(
fun_name = 'cummin_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_cumprod <- function(self, dim, dtype = NULL) {
  args <- rlang::env_get_list(nms = c("self", "dim", "dtype"))
expected_types <- list(self = "Tensor", dim = c("int64_t", "Dimname"), dtype = "ScalarType")
nd_args <- c("self", "dim")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'cumprod',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_cumprod_out <- function(out, self, dim, dtype = NULL) {
  args <- rlang::env_get_list(nms = c("out", "self", "dim", "dtype"))
expected_types <- list(out = "Tensor", self = "Tensor", dim = c("int64_t", "Dimname"
), dtype = "ScalarType")
nd_args <- c("out", "self", "dim")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'cumprod_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_cumsum <- function(self, dim, dtype = NULL) {
  args <- rlang::env_get_list(nms = c("self", "dim", "dtype"))
expected_types <- list(self = "Tensor", dim = c("int64_t", "Dimname"), dtype = "ScalarType")
nd_args <- c("self", "dim")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'cumsum',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_cumsum_out <- function(out, self, dim, dtype = NULL) {
  args <- rlang::env_get_list(nms = c("out", "self", "dim", "dtype"))
expected_types <- list(out = "Tensor", self = "Tensor", dim = c("int64_t", "Dimname"
), dtype = "ScalarType")
nd_args <- c("out", "self", "dim")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'cumsum_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_dequantize <- function(self) {
  args <- rlang::env_get_list(nms = c("self"))
expected_types <- list(self = "Tensor")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'dequantize',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_det <- function(self) {
  args <- rlang::env_get_list(nms = c("self"))
expected_types <- list(self = "Tensor")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'det',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_detach <- function(self) {
  args <- rlang::env_get_list(nms = c("self"))
expected_types <- list(self = "Tensor")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'detach',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_detach_ <- function(self) {
  args <- rlang::env_get_list(nms = c("self"))
expected_types <- list(self = "Tensor")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'detach_',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_diag <- function(self, diagonal = 0) {
  args <- rlang::env_get_list(nms = c("self", "diagonal"))
expected_types <- list(self = "Tensor", diagonal = "int64_t")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'diag',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_diag_embed <- function(self, offset = 0, dim1 = -2, dim2 = -1) {
  args <- rlang::env_get_list(nms = c("self", "offset", "dim1", "dim2"))
expected_types <- list(self = "Tensor", offset = "int64_t", dim1 = "int64_t", dim2 = "int64_t")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'diag_embed',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_diag_out <- function(out, self, diagonal = 0) {
  args <- rlang::env_get_list(nms = c("out", "self", "diagonal"))
expected_types <- list(out = "Tensor", self = "Tensor", diagonal = "int64_t")
nd_args <- c("out", "self")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'diag_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_diagflat <- function(self, offset = 0) {
  args <- rlang::env_get_list(nms = c("self", "offset"))
expected_types <- list(self = "Tensor", offset = "int64_t")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'diagflat',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_diagonal <- function(self, outdim, dim1 = 0, dim2 = 1, offset = 0) {
  args <- rlang::env_get_list(nms = c("self", "outdim", "dim1", "dim2", "offset"))
expected_types <- list(self = "Tensor", outdim = "Dimname", dim1 = c("int64_t", 
"Dimname"), dim2 = c("int64_t", "Dimname"), offset = "int64_t")
nd_args <- c("self", "outdim")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'diagonal',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_digamma <- function(self) {
  args <- rlang::env_get_list(nms = c("self"))
expected_types <- list(self = "Tensor")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'digamma',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_digamma_out <- function(out, self) {
  args <- rlang::env_get_list(nms = c("out", "self"))
expected_types <- list(out = "Tensor", self = "Tensor")
nd_args <- c("out", "self")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'digamma_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_dist <- function(self, other, p = 2) {
  args <- rlang::env_get_list(nms = c("self", "other", "p"))
expected_types <- list(self = "Tensor", other = "Tensor", p = "Scalar")
nd_args <- c("self", "other")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'dist',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_div <- function(self, other) {
  args <- rlang::env_get_list(nms = c("self", "other"))
expected_types <- list(self = "Tensor", other = c("Tensor", "Scalar"))
nd_args <- c("self", "other")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'div',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_div_out <- function(out, self, other) {
  args <- rlang::env_get_list(nms = c("out", "self", "other"))
expected_types <- list(out = "Tensor", self = "Tensor", other = "Tensor")
nd_args <- c("out", "self", "other")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'div_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_dot <- function(self, tensor) {
  args <- rlang::env_get_list(nms = c("self", "tensor"))
expected_types <- list(self = "Tensor", tensor = "Tensor")
nd_args <- c("self", "tensor")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'dot',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_dot_out <- function(out, self, tensor) {
  args <- rlang::env_get_list(nms = c("out", "self", "tensor"))
expected_types <- list(out = "Tensor", self = "Tensor", tensor = "Tensor")
nd_args <- c("out", "self", "tensor")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'dot_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_dropout <- function(input, p, train) {
  args <- rlang::env_get_list(nms = c("input", "p", "train"))
expected_types <- list(input = "Tensor", p = "double", train = "bool")
nd_args <- c("input", "p", "train")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'dropout',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_dropout_ <- function(self, p, train) {
  args <- rlang::env_get_list(nms = c("self", "p", "train"))
expected_types <- list(self = "Tensor", p = "double", train = "bool")
nd_args <- c("self", "p", "train")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'dropout_',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_eig <- function(self, eigenvectors = FALSE) {
  args <- rlang::env_get_list(nms = c("self", "eigenvectors"))
expected_types <- list(self = "Tensor", eigenvectors = "bool")
nd_args <- "self"
return_types <- list(list("Tensor", "Tensor"))
call_c_function(
fun_name = 'eig',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_eig_out <- function(e, v, self, eigenvectors = FALSE) {
  args <- rlang::env_get_list(nms = c("e", "v", "self", "eigenvectors"))
expected_types <- list(e = "Tensor", v = "Tensor", self = "Tensor", eigenvectors = "bool")
nd_args <- c("e", "v", "self")
return_types <- list(list("Tensor", "Tensor"))
call_c_function(
fun_name = 'eig_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_einsum <- function(equation, tensors) {
  args <- rlang::env_get_list(nms = c("equation", "tensors"))
expected_types <- list(equation = "std::string", tensors = "TensorList")
nd_args <- c("equation", "tensors")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'einsum',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_elu <- function(self, alpha = 1, scale = 1, input_scale = 1) {
  args <- rlang::env_get_list(nms = c("self", "alpha", "scale", "input_scale"))
expected_types <- list(self = "Tensor", alpha = "Scalar", scale = "Scalar", input_scale = "Scalar")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'elu',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_elu_ <- function(self, alpha = 1, scale = 1, input_scale = 1) {
  args <- rlang::env_get_list(nms = c("self", "alpha", "scale", "input_scale"))
expected_types <- list(self = "Tensor", alpha = "Scalar", scale = "Scalar", input_scale = "Scalar")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'elu_',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_elu_backward <- function(grad_output, alpha, scale, input_scale, output) {
  args <- rlang::env_get_list(nms = c("grad_output", "alpha", "scale", "input_scale", "output"))
expected_types <- list(grad_output = "Tensor", alpha = "Scalar", scale = "Scalar", 
    input_scale = "Scalar", output = "Tensor")
nd_args <- c("grad_output", "alpha", "scale", "input_scale", "output")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'elu_backward',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_elu_backward_out <- function(grad_input, grad_output, alpha, scale, input_scale, output) {
  args <- rlang::env_get_list(nms = c("grad_input", "grad_output", "alpha", "scale", "input_scale", "output"))
expected_types <- list(grad_input = "Tensor", grad_output = "Tensor", alpha = "Scalar", 
    scale = "Scalar", input_scale = "Scalar", output = "Tensor")
nd_args <- c("grad_input", "grad_output", "alpha", "scale", "input_scale", 
"output")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'elu_backward_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_elu_out <- function(out, self, alpha = 1, scale = 1, input_scale = 1) {
  args <- rlang::env_get_list(nms = c("out", "self", "alpha", "scale", "input_scale"))
expected_types <- list(out = "Tensor", self = "Tensor", alpha = "Scalar", scale = "Scalar", 
    input_scale = "Scalar")
nd_args <- c("out", "self")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'elu_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_embedding <- function(weight, indices, padding_idx = -1, scale_grad_by_freq = FALSE, sparse = FALSE) {
  args <- rlang::env_get_list(nms = c("weight", "indices", "padding_idx", "scale_grad_by_freq", "sparse"))
expected_types <- list(weight = "Tensor", indices = "Tensor", padding_idx = "int64_t", 
    scale_grad_by_freq = "bool", sparse = "bool")
nd_args <- c("weight", "indices")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'embedding',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_embedding_backward <- function(grad, indices, num_weights, padding_idx, scale_grad_by_freq, sparse) {
  args <- rlang::env_get_list(nms = c("grad", "indices", "num_weights", "padding_idx", "scale_grad_by_freq", "sparse"))
expected_types <- list(grad = "Tensor", indices = "Tensor", num_weights = "int64_t", 
    padding_idx = "int64_t", scale_grad_by_freq = "bool", sparse = "bool")
nd_args <- c("grad", "indices", "num_weights", "padding_idx", "scale_grad_by_freq", 
"sparse")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'embedding_backward',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_embedding_bag <- function(weight, indices, offsets, scale_grad_by_freq = FALSE, mode = 0, sparse = FALSE, per_sample_weights = list(), include_last_offset = FALSE) {
  args <- rlang::env_get_list(nms = c("weight", "indices", "offsets", "scale_grad_by_freq", "mode", "sparse", "per_sample_weights", "include_last_offset"))
expected_types <- list(weight = "Tensor", indices = "Tensor", offsets = "Tensor", 
    scale_grad_by_freq = "bool", mode = "int64_t", sparse = "bool", 
    per_sample_weights = "Tensor", include_last_offset = "bool")
nd_args <- c("weight", "indices", "offsets")
return_types <- list(list("Tensor", "Tensor", "Tensor", "Tensor"))
call_c_function(
fun_name = 'embedding_bag',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_embedding_dense_backward <- function(grad_output, indices, num_weights, padding_idx, scale_grad_by_freq) {
  args <- rlang::env_get_list(nms = c("grad_output", "indices", "num_weights", "padding_idx", "scale_grad_by_freq"))
expected_types <- list(grad_output = "Tensor", indices = "Tensor", num_weights = "int64_t", 
    padding_idx = "int64_t", scale_grad_by_freq = "bool")
nd_args <- c("grad_output", "indices", "num_weights", "padding_idx", "scale_grad_by_freq"
)
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'embedding_dense_backward',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_embedding_renorm_ <- function(self, indices, max_norm, norm_type) {
  args <- rlang::env_get_list(nms = c("self", "indices", "max_norm", "norm_type"))
expected_types <- list(self = "Tensor", indices = "Tensor", max_norm = "double", 
    norm_type = "double")
nd_args <- c("self", "indices", "max_norm", "norm_type")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'embedding_renorm_',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_embedding_sparse_backward <- function(grad, indices, num_weights, padding_idx, scale_grad_by_freq) {
  args <- rlang::env_get_list(nms = c("grad", "indices", "num_weights", "padding_idx", "scale_grad_by_freq"))
expected_types <- list(grad = "Tensor", indices = "Tensor", num_weights = "int64_t", 
    padding_idx = "int64_t", scale_grad_by_freq = "bool")
nd_args <- c("grad", "indices", "num_weights", "padding_idx", "scale_grad_by_freq"
)
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'embedding_sparse_backward',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


.torch_empty <- function(size, names, options = list(), memory_format = NULL) {
  args <- rlang::env_get_list(nms = c("size", "names", "options", "memory_format"))
expected_types <- list(size = "IntArrayRef", names = "DimnameList", options = "TensorOptions", 
    memory_format = "MemoryFormat")
nd_args <- c("size", "names")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'empty',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


.torch_empty_like <- function(self, options = list(), memory_format = NULL) {
  args <- rlang::env_get_list(nms = c("self", "options", "memory_format"))
expected_types <- list(self = "Tensor", options = "TensorOptions", memory_format = "MemoryFormat")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'empty_like',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_empty_out <- function(out, size, memory_format = NULL) {
  args <- rlang::env_get_list(nms = c("out", "size", "memory_format"))
expected_types <- list(out = "Tensor", size = "IntArrayRef", memory_format = "MemoryFormat")
nd_args <- c("out", "size")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'empty_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


.torch_empty_strided <- function(size, stride, options = list()) {
  args <- rlang::env_get_list(nms = c("size", "stride", "options"))
expected_types <- list(size = "IntArrayRef", stride = "IntArrayRef", options = "TensorOptions")
nd_args <- c("size", "stride")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'empty_strided',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_eq <- function(self, other) {
  args <- rlang::env_get_list(nms = c("self", "other"))
expected_types <- list(self = "Tensor", other = c("Scalar", "Tensor"))
nd_args <- c("self", "other")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'eq',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_eq_out <- function(out, self, other) {
  args <- rlang::env_get_list(nms = c("out", "self", "other"))
expected_types <- list(out = "Tensor", self = "Tensor", other = c("Scalar", "Tensor"
))
nd_args <- c("out", "self", "other")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'eq_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_equal <- function(self, other) {
  args <- rlang::env_get_list(nms = c("self", "other"))
expected_types <- list(self = "Tensor", other = "Tensor")
nd_args <- c("self", "other")
return_types <- list(list('bool'))
call_c_function(
fun_name = 'equal',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_erf <- function(self) {
  args <- rlang::env_get_list(nms = c("self"))
expected_types <- list(self = "Tensor")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'erf',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_erf_ <- function(self) {
  args <- rlang::env_get_list(nms = c("self"))
expected_types <- list(self = "Tensor")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'erf_',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_erf_out <- function(out, self) {
  args <- rlang::env_get_list(nms = c("out", "self"))
expected_types <- list(out = "Tensor", self = "Tensor")
nd_args <- c("out", "self")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'erf_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_erfc <- function(self) {
  args <- rlang::env_get_list(nms = c("self"))
expected_types <- list(self = "Tensor")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'erfc',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_erfc_ <- function(self) {
  args <- rlang::env_get_list(nms = c("self"))
expected_types <- list(self = "Tensor")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'erfc_',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_erfc_out <- function(out, self) {
  args <- rlang::env_get_list(nms = c("out", "self"))
expected_types <- list(out = "Tensor", self = "Tensor")
nd_args <- c("out", "self")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'erfc_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_erfinv <- function(self) {
  args <- rlang::env_get_list(nms = c("self"))
expected_types <- list(self = "Tensor")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'erfinv',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_erfinv_out <- function(out, self) {
  args <- rlang::env_get_list(nms = c("out", "self"))
expected_types <- list(out = "Tensor", self = "Tensor")
nd_args <- c("out", "self")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'erfinv_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_exp <- function(self) {
  args <- rlang::env_get_list(nms = c("self"))
expected_types <- list(self = "Tensor")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'exp',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_exp_ <- function(self) {
  args <- rlang::env_get_list(nms = c("self"))
expected_types <- list(self = "Tensor")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'exp_',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_exp_out <- function(out, self) {
  args <- rlang::env_get_list(nms = c("out", "self"))
expected_types <- list(out = "Tensor", self = "Tensor")
nd_args <- c("out", "self")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'exp_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_expm1 <- function(self) {
  args <- rlang::env_get_list(nms = c("self"))
expected_types <- list(self = "Tensor")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'expm1',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_expm1_ <- function(self) {
  args <- rlang::env_get_list(nms = c("self"))
expected_types <- list(self = "Tensor")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'expm1_',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_expm1_out <- function(out, self) {
  args <- rlang::env_get_list(nms = c("out", "self"))
expected_types <- list(out = "Tensor", self = "Tensor")
nd_args <- c("out", "self")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'expm1_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


.torch_eye <- function(n, m, options = list()) {
  args <- rlang::env_get_list(nms = c("n", "m", "options"))
expected_types <- list(n = "int64_t", m = "int64_t", options = "TensorOptions")
nd_args <- c("n", "m")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'eye',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_eye_out <- function(out, n, m) {
  args <- rlang::env_get_list(nms = c("out", "n", "m"))
expected_types <- list(out = "Tensor", n = "int64_t", m = "int64_t")
nd_args <- c("out", "n", "m")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'eye_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_fake_quantize_per_channel_affine <- function(self, scale, zero_point, axis, quant_min, quant_max) {
  args <- rlang::env_get_list(nms = c("self", "scale", "zero_point", "axis", "quant_min", "quant_max"))
expected_types <- list(self = "Tensor", scale = "Tensor", zero_point = "Tensor", 
    axis = "int64_t", quant_min = "int64_t", quant_max = "int64_t")
nd_args <- c("self", "scale", "zero_point", "axis", "quant_min", "quant_max"
)
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'fake_quantize_per_channel_affine',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_fake_quantize_per_channel_affine_backward <- function(grad, self, scale, zero_point, axis, quant_min, quant_max) {
  args <- rlang::env_get_list(nms = c("grad", "self", "scale", "zero_point", "axis", "quant_min", "quant_max"))
expected_types <- list(grad = "Tensor", self = "Tensor", scale = "Tensor", zero_point = "Tensor", 
    axis = "int64_t", quant_min = "int64_t", quant_max = "int64_t")
nd_args <- c("grad", "self", "scale", "zero_point", "axis", "quant_min", 
"quant_max")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'fake_quantize_per_channel_affine_backward',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_fake_quantize_per_tensor_affine <- function(self, scale, zero_point, quant_min, quant_max) {
  args <- rlang::env_get_list(nms = c("self", "scale", "zero_point", "quant_min", "quant_max"))
expected_types <- list(self = "Tensor", scale = "double", zero_point = "int64_t", 
    quant_min = "int64_t", quant_max = "int64_t")
nd_args <- c("self", "scale", "zero_point", "quant_min", "quant_max")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'fake_quantize_per_tensor_affine',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_fake_quantize_per_tensor_affine_backward <- function(grad, self, scale, zero_point, quant_min, quant_max) {
  args <- rlang::env_get_list(nms = c("grad", "self", "scale", "zero_point", "quant_min", "quant_max"))
expected_types <- list(grad = "Tensor", self = "Tensor", scale = "double", zero_point = "int64_t", 
    quant_min = "int64_t", quant_max = "int64_t")
nd_args <- c("grad", "self", "scale", "zero_point", "quant_min", "quant_max"
)
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'fake_quantize_per_tensor_affine_backward',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_fbgemm_linear_fp16_weight <- function(input, packed_weight, bias) {
  args <- rlang::env_get_list(nms = c("input", "packed_weight", "bias"))
expected_types <- list(input = "Tensor", packed_weight = "Tensor", bias = "Tensor")
nd_args <- c("input", "packed_weight", "bias")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'fbgemm_linear_fp16_weight',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_fbgemm_linear_fp16_weight_fp32_activation <- function(input, packed_weight, bias) {
  args <- rlang::env_get_list(nms = c("input", "packed_weight", "bias"))
expected_types <- list(input = "Tensor", packed_weight = "Tensor", bias = "Tensor")
nd_args <- c("input", "packed_weight", "bias")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'fbgemm_linear_fp16_weight_fp32_activation',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_fbgemm_linear_int8_weight <- function(input, weight, packed, col_offsets, weight_scale, weight_zero_point, bias) {
  args <- rlang::env_get_list(nms = c("input", "weight", "packed", "col_offsets", "weight_scale", "weight_zero_point", "bias"))
expected_types <- list(input = "Tensor", weight = "Tensor", packed = "Tensor", 
    col_offsets = "Tensor", weight_scale = "Scalar", weight_zero_point = "Scalar", 
    bias = "Tensor")
nd_args <- c("input", "weight", "packed", "col_offsets", "weight_scale", 
"weight_zero_point", "bias")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'fbgemm_linear_int8_weight',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_fbgemm_linear_int8_weight_fp32_activation <- function(input, weight, packed, col_offsets, weight_scale, weight_zero_point, bias) {
  args <- rlang::env_get_list(nms = c("input", "weight", "packed", "col_offsets", "weight_scale", "weight_zero_point", "bias"))
expected_types <- list(input = "Tensor", weight = "Tensor", packed = "Tensor", 
    col_offsets = "Tensor", weight_scale = "Scalar", weight_zero_point = "Scalar", 
    bias = "Tensor")
nd_args <- c("input", "weight", "packed", "col_offsets", "weight_scale", 
"weight_zero_point", "bias")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'fbgemm_linear_int8_weight_fp32_activation',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_fbgemm_linear_quantize_weight <- function(input) {
  args <- rlang::env_get_list(nms = c("input"))
expected_types <- list(input = "Tensor")
nd_args <- "input"
return_types <- list(list("Tensor", "Tensor", "double", "int64_t"))
call_c_function(
fun_name = 'fbgemm_linear_quantize_weight',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_fbgemm_pack_gemm_matrix_fp16 <- function(input) {
  args <- rlang::env_get_list(nms = c("input"))
expected_types <- list(input = "Tensor")
nd_args <- "input"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'fbgemm_pack_gemm_matrix_fp16',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_fbgemm_pack_quantized_matrix <- function(input, K, False) {
  args <- rlang::env_get_list(nms = c("input", "K", "False"))
expected_types <- list(input = "Tensor", K = "int64_t", False = "int64_t")
nd_args <- c("input", "K", "False")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'fbgemm_pack_quantized_matrix',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_feature_alpha_dropout <- function(input, p, train) {
  args <- rlang::env_get_list(nms = c("input", "p", "train"))
expected_types <- list(input = "Tensor", p = "double", train = "bool")
nd_args <- c("input", "p", "train")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'feature_alpha_dropout',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_feature_alpha_dropout_ <- function(self, p, train) {
  args <- rlang::env_get_list(nms = c("self", "p", "train"))
expected_types <- list(self = "Tensor", p = "double", train = "bool")
nd_args <- c("self", "p", "train")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'feature_alpha_dropout_',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_feature_dropout <- function(input, p, train) {
  args <- rlang::env_get_list(nms = c("input", "p", "train"))
expected_types <- list(input = "Tensor", p = "double", train = "bool")
nd_args <- c("input", "p", "train")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'feature_dropout',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_feature_dropout_ <- function(self, p, train) {
  args <- rlang::env_get_list(nms = c("self", "p", "train"))
expected_types <- list(self = "Tensor", p = "double", train = "bool")
nd_args <- c("self", "p", "train")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'feature_dropout_',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_fft <- function(self, signal_ndim, normalized = FALSE) {
  args <- rlang::env_get_list(nms = c("self", "signal_ndim", "normalized"))
expected_types <- list(self = "Tensor", signal_ndim = "int64_t", normalized = "bool")
nd_args <- c("self", "signal_ndim")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'fft',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_fill_ <- function(self, value) {
  args <- rlang::env_get_list(nms = c("self", "value"))
expected_types <- list(self = "Tensor", value = c("Scalar", "Tensor"))
nd_args <- c("self", "value")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'fill_',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_flatten <- function(self, dims, start_dim = 0, end_dim = -1, out_dim) {
  args <- rlang::env_get_list(nms = c("self", "dims", "start_dim", "end_dim", "out_dim"))
expected_types <- list(self = "Tensor", dims = "DimnameList", start_dim = c("int64_t", 
"Dimname"), end_dim = c("int64_t", "Dimname"), out_dim = "Dimname")
nd_args <- c("self", "dims", "out_dim")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'flatten',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_flip <- function(self, dims) {
  args <- rlang::env_get_list(nms = c("self", "dims"))
expected_types <- list(self = "Tensor", dims = "IntArrayRef")
nd_args <- c("self", "dims")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'flip',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_floor <- function(self) {
  args <- rlang::env_get_list(nms = c("self"))
expected_types <- list(self = "Tensor")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'floor',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_floor_ <- function(self) {
  args <- rlang::env_get_list(nms = c("self"))
expected_types <- list(self = "Tensor")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'floor_',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_floor_divide <- function(self, other) {
  args <- rlang::env_get_list(nms = c("self", "other"))
expected_types <- list(self = "Tensor", other = c("Tensor", "Scalar"))
nd_args <- c("self", "other")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'floor_divide',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_floor_divide_out <- function(out, self, other) {
  args <- rlang::env_get_list(nms = c("out", "self", "other"))
expected_types <- list(out = "Tensor", self = "Tensor", other = "Tensor")
nd_args <- c("out", "self", "other")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'floor_divide_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_floor_out <- function(out, self) {
  args <- rlang::env_get_list(nms = c("out", "self"))
expected_types <- list(out = "Tensor", self = "Tensor")
nd_args <- c("out", "self")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'floor_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_fmod <- function(self, other) {
  args <- rlang::env_get_list(nms = c("self", "other"))
expected_types <- list(self = "Tensor", other = c("Scalar", "Tensor"))
nd_args <- c("self", "other")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'fmod',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_fmod_out <- function(out, self, other) {
  args <- rlang::env_get_list(nms = c("out", "self", "other"))
expected_types <- list(out = "Tensor", self = "Tensor", other = c("Scalar", "Tensor"
))
nd_args <- c("out", "self", "other")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'fmod_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_frac <- function(self) {
  args <- rlang::env_get_list(nms = c("self"))
expected_types <- list(self = "Tensor")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'frac',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_frac_ <- function(self) {
  args <- rlang::env_get_list(nms = c("self"))
expected_types <- list(self = "Tensor")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'frac_',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_frac_out <- function(out, self) {
  args <- rlang::env_get_list(nms = c("out", "self"))
expected_types <- list(out = "Tensor", self = "Tensor")
nd_args <- c("out", "self")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'frac_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_fractional_max_pool2d <- function(self, kernel_size, output_size, random_samples) {
  args <- rlang::env_get_list(nms = c("self", "kernel_size", "output_size", "random_samples"))
expected_types <- list(self = "Tensor", kernel_size = "IntArrayRef", output_size = "IntArrayRef", 
    random_samples = "Tensor")
nd_args <- c("self", "kernel_size", "output_size", "random_samples")
return_types <- list(list("Tensor", "Tensor"))
call_c_function(
fun_name = 'fractional_max_pool2d',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_fractional_max_pool2d_backward <- function(grad_output, self, kernel_size, output_size, indices) {
  args <- rlang::env_get_list(nms = c("grad_output", "self", "kernel_size", "output_size", "indices"))
expected_types <- list(grad_output = "Tensor", self = "Tensor", kernel_size = "IntArrayRef", 
    output_size = "IntArrayRef", indices = "Tensor")
nd_args <- c("grad_output", "self", "kernel_size", "output_size", "indices"
)
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'fractional_max_pool2d_backward',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_fractional_max_pool2d_backward_out <- function(grad_input, grad_output, self, kernel_size, output_size, indices) {
  args <- rlang::env_get_list(nms = c("grad_input", "grad_output", "self", "kernel_size", "output_size", "indices"))
expected_types <- list(grad_input = "Tensor", grad_output = "Tensor", self = "Tensor", 
    kernel_size = "IntArrayRef", output_size = "IntArrayRef", 
    indices = "Tensor")
nd_args <- c("grad_input", "grad_output", "self", "kernel_size", "output_size", 
"indices")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'fractional_max_pool2d_backward_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_fractional_max_pool2d_out <- function(output, indices, self, kernel_size, output_size, random_samples) {
  args <- rlang::env_get_list(nms = c("output", "indices", "self", "kernel_size", "output_size", "random_samples"))
expected_types <- list(output = "Tensor", indices = "Tensor", self = "Tensor", 
    kernel_size = "IntArrayRef", output_size = "IntArrayRef", 
    random_samples = "Tensor")
nd_args <- c("output", "indices", "self", "kernel_size", "output_size", 
"random_samples")
return_types <- list(list("Tensor", "Tensor"))
call_c_function(
fun_name = 'fractional_max_pool2d_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_fractional_max_pool3d <- function(self, kernel_size, output_size, random_samples) {
  args <- rlang::env_get_list(nms = c("self", "kernel_size", "output_size", "random_samples"))
expected_types <- list(self = "Tensor", kernel_size = "IntArrayRef", output_size = "IntArrayRef", 
    random_samples = "Tensor")
nd_args <- c("self", "kernel_size", "output_size", "random_samples")
return_types <- list(list("Tensor", "Tensor"))
call_c_function(
fun_name = 'fractional_max_pool3d',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_fractional_max_pool3d_backward <- function(grad_output, self, kernel_size, output_size, indices) {
  args <- rlang::env_get_list(nms = c("grad_output", "self", "kernel_size", "output_size", "indices"))
expected_types <- list(grad_output = "Tensor", self = "Tensor", kernel_size = "IntArrayRef", 
    output_size = "IntArrayRef", indices = "Tensor")
nd_args <- c("grad_output", "self", "kernel_size", "output_size", "indices"
)
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'fractional_max_pool3d_backward',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_fractional_max_pool3d_backward_out <- function(grad_input, grad_output, self, kernel_size, output_size, indices) {
  args <- rlang::env_get_list(nms = c("grad_input", "grad_output", "self", "kernel_size", "output_size", "indices"))
expected_types <- list(grad_input = "Tensor", grad_output = "Tensor", self = "Tensor", 
    kernel_size = "IntArrayRef", output_size = "IntArrayRef", 
    indices = "Tensor")
nd_args <- c("grad_input", "grad_output", "self", "kernel_size", "output_size", 
"indices")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'fractional_max_pool3d_backward_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_fractional_max_pool3d_out <- function(output, indices, self, kernel_size, output_size, random_samples) {
  args <- rlang::env_get_list(nms = c("output", "indices", "self", "kernel_size", "output_size", "random_samples"))
expected_types <- list(output = "Tensor", indices = "Tensor", self = "Tensor", 
    kernel_size = "IntArrayRef", output_size = "IntArrayRef", 
    random_samples = "Tensor")
nd_args <- c("output", "indices", "self", "kernel_size", "output_size", 
"random_samples")
return_types <- list(list("Tensor", "Tensor"))
call_c_function(
fun_name = 'fractional_max_pool3d_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_frobenius_norm <- function(self, dim, keepdim = FALSE) {
  args <- rlang::env_get_list(nms = c("self", "dim", "keepdim"))
expected_types <- list(self = "Tensor", dim = "IntArrayRef", keepdim = "bool")
nd_args <- c("self", "dim")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'frobenius_norm',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_frobenius_norm_out <- function(out, self, dim, keepdim = FALSE) {
  args <- rlang::env_get_list(nms = c("out", "self", "dim", "keepdim"))
expected_types <- list(out = "Tensor", self = "Tensor", dim = "IntArrayRef", keepdim = "bool")
nd_args <- c("out", "self", "dim")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'frobenius_norm_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_from_file <- function(filename, shared = NULL, size = 0, options = list()) {
  args <- rlang::env_get_list(nms = c("filename", "shared", "size", "options"))
expected_types <- list(filename = "std::string", shared = "bool", size = "int64_t", 
    options = "TensorOptions")
nd_args <- "filename"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'from_file',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


.torch_full <- function(size, fill_value, names, options = list()) {
  args <- rlang::env_get_list(nms = c("size", "fill_value", "names", "options"))
expected_types <- list(size = "IntArrayRef", fill_value = "Scalar", names = "DimnameList", 
    options = "TensorOptions")
nd_args <- c("size", "fill_value", "names")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'full',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


.torch_full_like <- function(self, fill_value, options = list(), memory_format = NULL) {
  args <- rlang::env_get_list(nms = c("self", "fill_value", "options", "memory_format"))
expected_types <- list(self = "Tensor", fill_value = "Scalar", options = "TensorOptions", 
    memory_format = "MemoryFormat")
nd_args <- c("self", "fill_value")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'full_like',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_full_out <- function(out, size, fill_value) {
  args <- rlang::env_get_list(nms = c("out", "size", "fill_value"))
expected_types <- list(out = "Tensor", size = "IntArrayRef", fill_value = "Scalar")
nd_args <- c("out", "size", "fill_value")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'full_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_gather <- function(self, dim, index, sparse_grad = FALSE) {
  args <- rlang::env_get_list(nms = c("self", "dim", "index", "sparse_grad"))
expected_types <- list(self = "Tensor", dim = c("int64_t", "Dimname"), index = "Tensor", 
    sparse_grad = "bool")
nd_args <- c("self", "dim", "index")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'gather',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_gather_out <- function(out, self, dim, index, sparse_grad = FALSE) {
  args <- rlang::env_get_list(nms = c("out", "self", "dim", "index", "sparse_grad"))
expected_types <- list(out = "Tensor", self = "Tensor", dim = c("int64_t", "Dimname"
), index = "Tensor", sparse_grad = "bool")
nd_args <- c("out", "self", "dim", "index")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'gather_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_ge <- function(self, other) {
  args <- rlang::env_get_list(nms = c("self", "other"))
expected_types <- list(self = "Tensor", other = c("Scalar", "Tensor"))
nd_args <- c("self", "other")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'ge',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_ge_out <- function(out, self, other) {
  args <- rlang::env_get_list(nms = c("out", "self", "other"))
expected_types <- list(out = "Tensor", self = "Tensor", other = c("Scalar", "Tensor"
))
nd_args <- c("out", "self", "other")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'ge_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_gelu <- function(self) {
  args <- rlang::env_get_list(nms = c("self"))
expected_types <- list(self = "Tensor")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'gelu',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_gelu_backward <- function(grad, self) {
  args <- rlang::env_get_list(nms = c("grad", "self"))
expected_types <- list(grad = "Tensor", self = "Tensor")
nd_args <- c("grad", "self")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'gelu_backward',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_geqrf <- function(self) {
  args <- rlang::env_get_list(nms = c("self"))
expected_types <- list(self = "Tensor")
nd_args <- "self"
return_types <- list(list("Tensor", "Tensor"))
call_c_function(
fun_name = 'geqrf',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_geqrf_out <- function(a, tau, self) {
  args <- rlang::env_get_list(nms = c("a", "tau", "self"))
expected_types <- list(a = "Tensor", tau = "Tensor", self = "Tensor")
nd_args <- c("a", "tau", "self")
return_types <- list(list("Tensor", "Tensor"))
call_c_function(
fun_name = 'geqrf_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_ger <- function(self, vec2) {
  args <- rlang::env_get_list(nms = c("self", "vec2"))
expected_types <- list(self = "Tensor", vec2 = "Tensor")
nd_args <- c("self", "vec2")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'ger',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_ger_out <- function(out, self, vec2) {
  args <- rlang::env_get_list(nms = c("out", "self", "vec2"))
expected_types <- list(out = "Tensor", self = "Tensor", vec2 = "Tensor")
nd_args <- c("out", "self", "vec2")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'ger_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_glu <- function(self, dim = -1) {
  args <- rlang::env_get_list(nms = c("self", "dim"))
expected_types <- list(self = "Tensor", dim = "int64_t")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'glu',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_glu_backward <- function(grad_output, self, dim) {
  args <- rlang::env_get_list(nms = c("grad_output", "self", "dim"))
expected_types <- list(grad_output = "Tensor", self = "Tensor", dim = "int64_t")
nd_args <- c("grad_output", "self", "dim")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'glu_backward',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_glu_backward_out <- function(grad_input, grad_output, self, dim) {
  args <- rlang::env_get_list(nms = c("grad_input", "grad_output", "self", "dim"))
expected_types <- list(grad_input = "Tensor", grad_output = "Tensor", self = "Tensor", 
    dim = "int64_t")
nd_args <- c("grad_input", "grad_output", "self", "dim")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'glu_backward_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_glu_out <- function(out, self, dim = -1) {
  args <- rlang::env_get_list(nms = c("out", "self", "dim"))
expected_types <- list(out = "Tensor", self = "Tensor", dim = "int64_t")
nd_args <- c("out", "self")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'glu_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_grid_sampler <- function(input, grid, interpolation_mode, padding_mode, align_corners) {
  args <- rlang::env_get_list(nms = c("input", "grid", "interpolation_mode", "padding_mode", "align_corners"))
expected_types <- list(input = "Tensor", grid = "Tensor", interpolation_mode = "int64_t", 
    padding_mode = "int64_t", align_corners = "bool")
nd_args <- c("input", "grid", "interpolation_mode", "padding_mode", "align_corners"
)
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'grid_sampler',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_grid_sampler_2d <- function(input, grid, interpolation_mode, padding_mode, align_corners) {
  args <- rlang::env_get_list(nms = c("input", "grid", "interpolation_mode", "padding_mode", "align_corners"))
expected_types <- list(input = "Tensor", grid = "Tensor", interpolation_mode = "int64_t", 
    padding_mode = "int64_t", align_corners = "bool")
nd_args <- c("input", "grid", "interpolation_mode", "padding_mode", "align_corners"
)
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'grid_sampler_2d',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_grid_sampler_2d_backward <- function(grad_output, input, grid, interpolation_mode, padding_mode, align_corners) {
  args <- rlang::env_get_list(nms = c("grad_output", "input", "grid", "interpolation_mode", "padding_mode", "align_corners"))
expected_types <- list(grad_output = "Tensor", input = "Tensor", grid = "Tensor", 
    interpolation_mode = "int64_t", padding_mode = "int64_t", 
    align_corners = "bool")
nd_args <- c("grad_output", "input", "grid", "interpolation_mode", "padding_mode", 
"align_corners")
return_types <- list(list("Tensor", "Tensor"))
call_c_function(
fun_name = 'grid_sampler_2d_backward',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_grid_sampler_3d <- function(input, grid, interpolation_mode, padding_mode, align_corners) {
  args <- rlang::env_get_list(nms = c("input", "grid", "interpolation_mode", "padding_mode", "align_corners"))
expected_types <- list(input = "Tensor", grid = "Tensor", interpolation_mode = "int64_t", 
    padding_mode = "int64_t", align_corners = "bool")
nd_args <- c("input", "grid", "interpolation_mode", "padding_mode", "align_corners"
)
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'grid_sampler_3d',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_grid_sampler_3d_backward <- function(grad_output, input, grid, interpolation_mode, padding_mode, align_corners) {
  args <- rlang::env_get_list(nms = c("grad_output", "input", "grid", "interpolation_mode", "padding_mode", "align_corners"))
expected_types <- list(grad_output = "Tensor", input = "Tensor", grid = "Tensor", 
    interpolation_mode = "int64_t", padding_mode = "int64_t", 
    align_corners = "bool")
nd_args <- c("grad_output", "input", "grid", "interpolation_mode", "padding_mode", 
"align_corners")
return_types <- list(list("Tensor", "Tensor"))
call_c_function(
fun_name = 'grid_sampler_3d_backward',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_group_norm <- function(input, num_groups, weight = list(), bias = list(), eps = 0.000010, cudnn_enabled = TRUE) {
  args <- rlang::env_get_list(nms = c("input", "num_groups", "weight", "bias", "eps", "cudnn_enabled"))
expected_types <- list(input = "Tensor", num_groups = "int64_t", weight = "Tensor", 
    bias = "Tensor", eps = "double", cudnn_enabled = "bool")
nd_args <- c("input", "num_groups")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'group_norm',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_gru <- function(data, input, batch_sizes, hx, params, has_biases, num_layers, dropout, train, batch_first, bidirectional) {
  args <- rlang::env_get_list(nms = c("data", "input", "batch_sizes", "hx", "params", "has_biases", "num_layers", "dropout", "train", "batch_first", "bidirectional"))
expected_types <- list(data = "Tensor", input = "Tensor", batch_sizes = "Tensor", 
    hx = "Tensor", params = "TensorList", has_biases = "bool", 
    num_layers = "int64_t", dropout = "double", train = "bool", 
    batch_first = "bool", bidirectional = "bool")
nd_args <- c("data", "input", "batch_sizes", "hx", "params", "has_biases", 
"num_layers", "dropout", "train", "batch_first", "bidirectional"
)
return_types <- list(list("Tensor", "Tensor"))
call_c_function(
fun_name = 'gru',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_gru_cell <- function(input, hx, w_ih, w_hh, b_ih = list(), b_hh = list()) {
  args <- rlang::env_get_list(nms = c("input", "hx", "w_ih", "w_hh", "b_ih", "b_hh"))
expected_types <- list(input = "Tensor", hx = "Tensor", w_ih = "Tensor", w_hh = "Tensor", 
    b_ih = "Tensor", b_hh = "Tensor")
nd_args <- c("input", "hx", "w_ih", "w_hh")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'gru_cell',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_gt <- function(self, other) {
  args <- rlang::env_get_list(nms = c("self", "other"))
expected_types <- list(self = "Tensor", other = c("Scalar", "Tensor"))
nd_args <- c("self", "other")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'gt',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_gt_out <- function(out, self, other) {
  args <- rlang::env_get_list(nms = c("out", "self", "other"))
expected_types <- list(out = "Tensor", self = "Tensor", other = c("Scalar", "Tensor"
))
nd_args <- c("out", "self", "other")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'gt_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_hamming_window <- function(window_length, periodic, alpha, beta, options = list()) {
  args <- rlang::env_get_list(nms = c("window_length", "periodic", "alpha", "beta", "options"))
expected_types <- list(window_length = "int64_t", periodic = "bool", alpha = "double", 
    beta = "double", options = "TensorOptions")
nd_args <- c("window_length", "periodic", "alpha", "beta")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'hamming_window',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_hann_window <- function(window_length, periodic, options = list()) {
  args <- rlang::env_get_list(nms = c("window_length", "periodic", "options"))
expected_types <- list(window_length = "int64_t", periodic = "bool", options = "TensorOptions")
nd_args <- c("window_length", "periodic")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'hann_window',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_hardshrink <- function(self, lambd = 0.500000) {
  args <- rlang::env_get_list(nms = c("self", "lambd"))
expected_types <- list(self = "Tensor", lambd = "Scalar")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'hardshrink',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_hardshrink_backward <- function(grad_out, self, lambd) {
  args <- rlang::env_get_list(nms = c("grad_out", "self", "lambd"))
expected_types <- list(grad_out = "Tensor", self = "Tensor", lambd = "Scalar")
nd_args <- c("grad_out", "self", "lambd")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'hardshrink_backward',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_hardsigmoid <- function(self) {
  args <- rlang::env_get_list(nms = c("self"))
expected_types <- list(self = "Tensor")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'hardsigmoid',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_hardsigmoid_ <- function(self) {
  args <- rlang::env_get_list(nms = c("self"))
expected_types <- list(self = "Tensor")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'hardsigmoid_',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_hardsigmoid_backward <- function(grad_output, self) {
  args <- rlang::env_get_list(nms = c("grad_output", "self"))
expected_types <- list(grad_output = "Tensor", self = "Tensor")
nd_args <- c("grad_output", "self")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'hardsigmoid_backward',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_hardsigmoid_out <- function(out, self) {
  args <- rlang::env_get_list(nms = c("out", "self"))
expected_types <- list(out = "Tensor", self = "Tensor")
nd_args <- c("out", "self")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'hardsigmoid_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_hardtanh <- function(self, min_val = -1, max_val = 1) {
  args <- rlang::env_get_list(nms = c("self", "min_val", "max_val"))
expected_types <- list(self = "Tensor", min_val = "Scalar", max_val = "Scalar")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'hardtanh',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_hardtanh_ <- function(self, min_val = -1, max_val = 1) {
  args <- rlang::env_get_list(nms = c("self", "min_val", "max_val"))
expected_types <- list(self = "Tensor", min_val = "Scalar", max_val = "Scalar")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'hardtanh_',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_hardtanh_backward <- function(grad_output, self, min_val, max_val) {
  args <- rlang::env_get_list(nms = c("grad_output", "self", "min_val", "max_val"))
expected_types <- list(grad_output = "Tensor", self = "Tensor", min_val = "Scalar", 
    max_val = "Scalar")
nd_args <- c("grad_output", "self", "min_val", "max_val")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'hardtanh_backward',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_hardtanh_backward_out <- function(grad_input, grad_output, self, min_val, max_val) {
  args <- rlang::env_get_list(nms = c("grad_input", "grad_output", "self", "min_val", "max_val"))
expected_types <- list(grad_input = "Tensor", grad_output = "Tensor", self = "Tensor", 
    min_val = "Scalar", max_val = "Scalar")
nd_args <- c("grad_input", "grad_output", "self", "min_val", "max_val")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'hardtanh_backward_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_hardtanh_out <- function(out, self, min_val = -1, max_val = 1) {
  args <- rlang::env_get_list(nms = c("out", "self", "min_val", "max_val"))
expected_types <- list(out = "Tensor", self = "Tensor", min_val = "Scalar", max_val = "Scalar")
nd_args <- c("out", "self")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'hardtanh_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_hinge_embedding_loss <- function(self, target, margin = 1.000000, reduction = torch_reduction_mean()) {
  args <- rlang::env_get_list(nms = c("self", "target", "margin", "reduction"))
expected_types <- list(self = "Tensor", target = "Tensor", margin = "double", reduction = "int64_t")
nd_args <- c("self", "target")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'hinge_embedding_loss',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_histc <- function(self, bins = 100, min = 0, max = 0) {
  args <- rlang::env_get_list(nms = c("self", "bins", "min", "max"))
expected_types <- list(self = "Tensor", bins = "int64_t", min = "Scalar", max = "Scalar")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'histc',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_histc_out <- function(out, self, bins = 100, min = 0, max = 0) {
  args <- rlang::env_get_list(nms = c("out", "self", "bins", "min", "max"))
expected_types <- list(out = "Tensor", self = "Tensor", bins = "int64_t", min = "Scalar", 
    max = "Scalar")
nd_args <- c("out", "self")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'histc_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_hspmm <- function(mat1, mat2) {
  args <- rlang::env_get_list(nms = c("mat1", "mat2"))
expected_types <- list(mat1 = "Tensor", mat2 = "Tensor")
nd_args <- c("mat1", "mat2")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'hspmm',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_hspmm_out <- function(out, mat1, mat2) {
  args <- rlang::env_get_list(nms = c("out", "mat1", "mat2"))
expected_types <- list(out = "Tensor", mat1 = "Tensor", mat2 = "Tensor")
nd_args <- c("out", "mat1", "mat2")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'hspmm_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_ifft <- function(self, signal_ndim, normalized = FALSE) {
  args <- rlang::env_get_list(nms = c("self", "signal_ndim", "normalized"))
expected_types <- list(self = "Tensor", signal_ndim = "int64_t", normalized = "bool")
nd_args <- c("self", "signal_ndim")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'ifft',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_im2col <- function(self, kernel_size, dilation, padding, stride) {
  args <- rlang::env_get_list(nms = c("self", "kernel_size", "dilation", "padding", "stride"))
expected_types <- list(self = "Tensor", kernel_size = "IntArrayRef", dilation = "IntArrayRef", 
    padding = "IntArrayRef", stride = "IntArrayRef")
nd_args <- c("self", "kernel_size", "dilation", "padding", "stride")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'im2col',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_im2col_backward <- function(grad_output, input_size, kernel_size, dilation, padding, stride) {
  args <- rlang::env_get_list(nms = c("grad_output", "input_size", "kernel_size", "dilation", "padding", "stride"))
expected_types <- list(grad_output = "Tensor", input_size = "IntArrayRef", kernel_size = "IntArrayRef", 
    dilation = "IntArrayRef", padding = "IntArrayRef", stride = "IntArrayRef")
nd_args <- c("grad_output", "input_size", "kernel_size", "dilation", "padding", 
"stride")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'im2col_backward',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_im2col_backward_out <- function(grad_input, grad_output, input_size, kernel_size, dilation, padding, stride) {
  args <- rlang::env_get_list(nms = c("grad_input", "grad_output", "input_size", "kernel_size", "dilation", "padding", "stride"))
expected_types <- list(grad_input = "Tensor", grad_output = "Tensor", input_size = "IntArrayRef", 
    kernel_size = "IntArrayRef", dilation = "IntArrayRef", padding = "IntArrayRef", 
    stride = "IntArrayRef")
nd_args <- c("grad_input", "grad_output", "input_size", "kernel_size", "dilation", 
"padding", "stride")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'im2col_backward_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_im2col_out <- function(out, self, kernel_size, dilation, padding, stride) {
  args <- rlang::env_get_list(nms = c("out", "self", "kernel_size", "dilation", "padding", "stride"))
expected_types <- list(out = "Tensor", self = "Tensor", kernel_size = "IntArrayRef", 
    dilation = "IntArrayRef", padding = "IntArrayRef", stride = "IntArrayRef")
nd_args <- c("out", "self", "kernel_size", "dilation", "padding", "stride"
)
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'im2col_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_imag <- function(self) {
  args <- rlang::env_get_list(nms = c("self"))
expected_types <- list(self = "Tensor")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'imag',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_index <- function(self, indices) {
  args <- rlang::env_get_list(nms = c("self", "indices"))
expected_types <- list(self = "Tensor", indices = "TensorList")
nd_args <- c("self", "indices")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'index',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_index_add <- function(self, dim, index, source) {
  args <- rlang::env_get_list(nms = c("self", "dim", "index", "source"))
expected_types <- list(self = "Tensor", dim = c("int64_t", "Dimname"), index = "Tensor", 
    source = "Tensor")
nd_args <- c("self", "dim", "index", "source")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'index_add',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_index_copy <- function(self, dim, index, source) {
  args <- rlang::env_get_list(nms = c("self", "dim", "index", "source"))
expected_types <- list(self = "Tensor", dim = c("int64_t", "Dimname"), index = "Tensor", 
    source = "Tensor")
nd_args <- c("self", "dim", "index", "source")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'index_copy',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_index_fill <- function(self, dim, index, value) {
  args <- rlang::env_get_list(nms = c("self", "dim", "index", "value"))
expected_types <- list(self = "Tensor", dim = c("int64_t", "Dimname"), index = "Tensor", 
    value = c("Scalar", "Tensor"))
nd_args <- c("self", "dim", "index", "value")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'index_fill',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_index_put <- function(self, indices, values, accumulate = FALSE) {
  args <- rlang::env_get_list(nms = c("self", "indices", "values", "accumulate"))
expected_types <- list(self = "Tensor", indices = "TensorList", values = "Tensor", 
    accumulate = "bool")
nd_args <- c("self", "indices", "values")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'index_put',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_index_put_ <- function(self, indices, values, accumulate = FALSE) {
  args <- rlang::env_get_list(nms = c("self", "indices", "values", "accumulate"))
expected_types <- list(self = "Tensor", indices = "TensorList", values = "Tensor", 
    accumulate = "bool")
nd_args <- c("self", "indices", "values")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'index_put_',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_index_select <- function(self, dim, index) {
  args <- rlang::env_get_list(nms = c("self", "dim", "index"))
expected_types <- list(self = "Tensor", dim = c("int64_t", "Dimname"), index = "Tensor")
nd_args <- c("self", "dim", "index")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'index_select',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_index_select_out <- function(out, self, dim, index) {
  args <- rlang::env_get_list(nms = c("out", "self", "dim", "index"))
expected_types <- list(out = "Tensor", self = "Tensor", dim = c("int64_t", "Dimname"
), index = "Tensor")
nd_args <- c("out", "self", "dim", "index")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'index_select_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_instance_norm <- function(input, weight, bias, running_mean, running_var, use_input_stats, momentum, eps, cudnn_enabled) {
  args <- rlang::env_get_list(nms = c("input", "weight", "bias", "running_mean", "running_var", "use_input_stats", "momentum", "eps", "cudnn_enabled"))
expected_types <- list(input = "Tensor", weight = "Tensor", bias = "Tensor", running_mean = "Tensor", 
    running_var = "Tensor", use_input_stats = "bool", momentum = "double", 
    eps = "double", cudnn_enabled = "bool")
nd_args <- c("input", "weight", "bias", "running_mean", "running_var", "use_input_stats", 
"momentum", "eps", "cudnn_enabled")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'instance_norm',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_int_repr <- function(self) {
  args <- rlang::env_get_list(nms = c("self"))
expected_types <- list(self = "Tensor")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'int_repr',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_inverse <- function(self) {
  args <- rlang::env_get_list(nms = c("self"))
expected_types <- list(self = "Tensor")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'inverse',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_inverse_out <- function(out, self) {
  args <- rlang::env_get_list(nms = c("out", "self"))
expected_types <- list(out = "Tensor", self = "Tensor")
nd_args <- c("out", "self")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'inverse_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_irfft <- function(self, signal_ndim, normalized = FALSE, onesided = TRUE, signal_sizes = list()) {
  args <- rlang::env_get_list(nms = c("self", "signal_ndim", "normalized", "onesided", "signal_sizes"))
expected_types <- list(self = "Tensor", signal_ndim = "int64_t", normalized = "bool", 
    onesided = "bool", signal_sizes = "IntArrayRef")
nd_args <- c("self", "signal_ndim")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'irfft',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_is_complex <- function(self) {
  args <- rlang::env_get_list(nms = c("self"))
expected_types <- list(self = "Tensor")
nd_args <- "self"
return_types <- list(list('bool'))
call_c_function(
fun_name = 'is_complex',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_is_distributed <- function(self) {
  args <- rlang::env_get_list(nms = c("self"))
expected_types <- list(self = "Tensor")
nd_args <- "self"
return_types <- list(list('bool'))
call_c_function(
fun_name = 'is_distributed',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_is_floating_point <- function(self) {
  args <- rlang::env_get_list(nms = c("self"))
expected_types <- list(self = "Tensor")
nd_args <- "self"
return_types <- list(list('bool'))
call_c_function(
fun_name = 'is_floating_point',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_is_nonzero <- function(self) {
  args <- rlang::env_get_list(nms = c("self"))
expected_types <- list(self = "Tensor")
nd_args <- "self"
return_types <- list(list('bool'))
call_c_function(
fun_name = 'is_nonzero',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_is_same_size <- function(self, other) {
  args <- rlang::env_get_list(nms = c("self", "other"))
expected_types <- list(self = "Tensor", other = "Tensor")
nd_args <- c("self", "other")
return_types <- list(list('bool'))
call_c_function(
fun_name = 'is_same_size',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_is_signed <- function(self) {
  args <- rlang::env_get_list(nms = c("self"))
expected_types <- list(self = "Tensor")
nd_args <- "self"
return_types <- list(list('bool'))
call_c_function(
fun_name = 'is_signed',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_isclose <- function(self, other, rtol = 0.000010, atol = 0.000000, equal_nan = FALSE) {
  args <- rlang::env_get_list(nms = c("self", "other", "rtol", "atol", "equal_nan"))
expected_types <- list(self = "Tensor", other = "Tensor", rtol = "double", atol = "double", 
    equal_nan = "bool")
nd_args <- c("self", "other")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'isclose',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_isfinite <- function(self) {
  args <- rlang::env_get_list(nms = c("self"))
expected_types <- list(self = "Tensor")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'isfinite',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_isinf <- function(self) {
  args <- rlang::env_get_list(nms = c("self"))
expected_types <- list(self = "Tensor")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'isinf',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_isnan <- function(self) {
  args <- rlang::env_get_list(nms = c("self"))
expected_types <- list(self = "Tensor")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'isnan',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_kl_div <- function(self, target, reduction = torch_reduction_mean()) {
  args <- rlang::env_get_list(nms = c("self", "target", "reduction"))
expected_types <- list(self = "Tensor", target = "Tensor", reduction = "int64_t")
nd_args <- c("self", "target")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'kl_div',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_kl_div_backward <- function(grad_output, self, target, reduction = torch_reduction_mean()) {
  args <- rlang::env_get_list(nms = c("grad_output", "self", "target", "reduction"))
expected_types <- list(grad_output = "Tensor", self = "Tensor", target = "Tensor", 
    reduction = "int64_t")
nd_args <- c("grad_output", "self", "target")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'kl_div_backward',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_kthvalue <- function(self, k, dim = -1, keepdim = FALSE) {
  args <- rlang::env_get_list(nms = c("self", "k", "dim", "keepdim"))
expected_types <- list(self = "Tensor", k = "int64_t", dim = c("int64_t", "Dimname"
), keepdim = "bool")
nd_args <- c("self", "k")
return_types <- list(list("Tensor", "Tensor"))
call_c_function(
fun_name = 'kthvalue',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_kthvalue_out <- function(values, indices, self, k, dim = -1, keepdim = FALSE) {
  args <- rlang::env_get_list(nms = c("values", "indices", "self", "k", "dim", "keepdim"))
expected_types <- list(values = "Tensor", indices = "Tensor", self = "Tensor", 
    k = "int64_t", dim = c("int64_t", "Dimname"), keepdim = "bool")
nd_args <- c("values", "indices", "self", "k")
return_types <- list(list("Tensor", "Tensor"))
call_c_function(
fun_name = 'kthvalue_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_l1_loss <- function(self, target, reduction = torch_reduction_mean()) {
  args <- rlang::env_get_list(nms = c("self", "target", "reduction"))
expected_types <- list(self = "Tensor", target = "Tensor", reduction = "int64_t")
nd_args <- c("self", "target")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'l1_loss',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_l1_loss_backward <- function(grad_output, self, target, reduction) {
  args <- rlang::env_get_list(nms = c("grad_output", "self", "target", "reduction"))
expected_types <- list(grad_output = "Tensor", self = "Tensor", target = "Tensor", 
    reduction = "int64_t")
nd_args <- c("grad_output", "self", "target", "reduction")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'l1_loss_backward',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_l1_loss_backward_out <- function(grad_input, grad_output, self, target, reduction) {
  args <- rlang::env_get_list(nms = c("grad_input", "grad_output", "self", "target", "reduction"))
expected_types <- list(grad_input = "Tensor", grad_output = "Tensor", self = "Tensor", 
    target = "Tensor", reduction = "int64_t")
nd_args <- c("grad_input", "grad_output", "self", "target", "reduction")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'l1_loss_backward_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_l1_loss_out <- function(out, self, target, reduction = torch_reduction_mean()) {
  args <- rlang::env_get_list(nms = c("out", "self", "target", "reduction"))
expected_types <- list(out = "Tensor", self = "Tensor", target = "Tensor", reduction = "int64_t")
nd_args <- c("out", "self", "target")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'l1_loss_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_layer_norm <- function(input, normalized_shape, weight = list(), bias = list(), eps = 0.000010, cudnn_enable = TRUE) {
  args <- rlang::env_get_list(nms = c("input", "normalized_shape", "weight", "bias", "eps", "cudnn_enable"))
expected_types <- list(input = "Tensor", normalized_shape = "IntArrayRef", weight = "Tensor", 
    bias = "Tensor", eps = "double", cudnn_enable = "bool")
nd_args <- c("input", "normalized_shape")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'layer_norm',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_le <- function(self, other) {
  args <- rlang::env_get_list(nms = c("self", "other"))
expected_types <- list(self = "Tensor", other = c("Scalar", "Tensor"))
nd_args <- c("self", "other")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'le',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_le_out <- function(out, self, other) {
  args <- rlang::env_get_list(nms = c("out", "self", "other"))
expected_types <- list(out = "Tensor", self = "Tensor", other = c("Scalar", "Tensor"
))
nd_args <- c("out", "self", "other")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'le_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_leaky_relu <- function(self, negative_slope = 0.010000) {
  args <- rlang::env_get_list(nms = c("self", "negative_slope"))
expected_types <- list(self = "Tensor", negative_slope = "Scalar")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'leaky_relu',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_leaky_relu_ <- function(self, negative_slope = 0.010000) {
  args <- rlang::env_get_list(nms = c("self", "negative_slope"))
expected_types <- list(self = "Tensor", negative_slope = "Scalar")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'leaky_relu_',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_leaky_relu_backward <- function(grad_output, self, negative_slope, self_is_result) {
  args <- rlang::env_get_list(nms = c("grad_output", "self", "negative_slope", "self_is_result"))
expected_types <- list(grad_output = "Tensor", self = "Tensor", negative_slope = "Scalar", 
    self_is_result = "bool")
nd_args <- c("grad_output", "self", "negative_slope", "self_is_result")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'leaky_relu_backward',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_leaky_relu_out <- function(out, self, negative_slope = 0.010000) {
  args <- rlang::env_get_list(nms = c("out", "self", "negative_slope"))
expected_types <- list(out = "Tensor", self = "Tensor", negative_slope = "Scalar")
nd_args <- c("out", "self")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'leaky_relu_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_lerp <- function(self, end, weight) {
  args <- rlang::env_get_list(nms = c("self", "end", "weight"))
expected_types <- list(self = "Tensor", end = "Tensor", weight = c("Scalar", "Tensor"
))
nd_args <- c("self", "end", "weight")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'lerp',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_lerp_out <- function(out, self, end, weight) {
  args <- rlang::env_get_list(nms = c("out", "self", "end", "weight"))
expected_types <- list(out = "Tensor", self = "Tensor", end = "Tensor", weight = c("Scalar", 
"Tensor"))
nd_args <- c("out", "self", "end", "weight")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'lerp_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_lgamma <- function(self) {
  args <- rlang::env_get_list(nms = c("self"))
expected_types <- list(self = "Tensor")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'lgamma',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_lgamma_out <- function(out, self) {
  args <- rlang::env_get_list(nms = c("out", "self"))
expected_types <- list(out = "Tensor", self = "Tensor")
nd_args <- c("out", "self")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'lgamma_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_linear <- function(input, weight, bias = list()) {
  args <- rlang::env_get_list(nms = c("input", "weight", "bias"))
expected_types <- list(input = "Tensor", weight = "Tensor", bias = "Tensor")
nd_args <- c("input", "weight")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'linear',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


.torch_linspace <- function(start, end, steps = 100, options = list()) {
  args <- rlang::env_get_list(nms = c("start", "end", "steps", "options"))
expected_types <- list(start = "Scalar", end = "Scalar", steps = "int64_t", options = "TensorOptions")
nd_args <- c("start", "end")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'linspace',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_linspace_out <- function(out, start, end, steps = 100) {
  args <- rlang::env_get_list(nms = c("out", "start", "end", "steps"))
expected_types <- list(out = "Tensor", start = "Scalar", end = "Scalar", steps = "int64_t")
nd_args <- c("out", "start", "end")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'linspace_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_log <- function(self) {
  args <- rlang::env_get_list(nms = c("self"))
expected_types <- list(self = "Tensor")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'log',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_log_ <- function(self) {
  args <- rlang::env_get_list(nms = c("self"))
expected_types <- list(self = "Tensor")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'log_',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_log_out <- function(out, self) {
  args <- rlang::env_get_list(nms = c("out", "self"))
expected_types <- list(out = "Tensor", self = "Tensor")
nd_args <- c("out", "self")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'log_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_log_sigmoid <- function(self) {
  args <- rlang::env_get_list(nms = c("self"))
expected_types <- list(self = "Tensor")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'log_sigmoid',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_log_sigmoid_backward <- function(grad_output, self, buffer) {
  args <- rlang::env_get_list(nms = c("grad_output", "self", "buffer"))
expected_types <- list(grad_output = "Tensor", self = "Tensor", buffer = "Tensor")
nd_args <- c("grad_output", "self", "buffer")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'log_sigmoid_backward',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_log_sigmoid_backward_out <- function(grad_input, grad_output, self, buffer) {
  args <- rlang::env_get_list(nms = c("grad_input", "grad_output", "self", "buffer"))
expected_types <- list(grad_input = "Tensor", grad_output = "Tensor", self = "Tensor", 
    buffer = "Tensor")
nd_args <- c("grad_input", "grad_output", "self", "buffer")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'log_sigmoid_backward_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_log_sigmoid_forward <- function(self) {
  args <- rlang::env_get_list(nms = c("self"))
expected_types <- list(self = "Tensor")
nd_args <- "self"
return_types <- list(list("Tensor", "Tensor"))
call_c_function(
fun_name = 'log_sigmoid_forward',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_log_sigmoid_forward_out <- function(output, buffer, self) {
  args <- rlang::env_get_list(nms = c("output", "buffer", "self"))
expected_types <- list(output = "Tensor", buffer = "Tensor", self = "Tensor")
nd_args <- c("output", "buffer", "self")
return_types <- list(list("Tensor", "Tensor"))
call_c_function(
fun_name = 'log_sigmoid_forward_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_log_sigmoid_out <- function(out, self) {
  args <- rlang::env_get_list(nms = c("out", "self"))
expected_types <- list(out = "Tensor", self = "Tensor")
nd_args <- c("out", "self")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'log_sigmoid_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_log_softmax <- function(self, dim, dtype = NULL) {
  args <- rlang::env_get_list(nms = c("self", "dim", "dtype"))
expected_types <- list(self = "Tensor", dim = c("int64_t", "Dimname"), dtype = "ScalarType")
nd_args <- c("self", "dim")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'log_softmax',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_log10 <- function(self) {
  args <- rlang::env_get_list(nms = c("self"))
expected_types <- list(self = "Tensor")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'log10',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_log10_ <- function(self) {
  args <- rlang::env_get_list(nms = c("self"))
expected_types <- list(self = "Tensor")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'log10_',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_log10_out <- function(out, self) {
  args <- rlang::env_get_list(nms = c("out", "self"))
expected_types <- list(out = "Tensor", self = "Tensor")
nd_args <- c("out", "self")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'log10_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_log1p <- function(self) {
  args <- rlang::env_get_list(nms = c("self"))
expected_types <- list(self = "Tensor")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'log1p',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_log1p_ <- function(self) {
  args <- rlang::env_get_list(nms = c("self"))
expected_types <- list(self = "Tensor")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'log1p_',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_log1p_out <- function(out, self) {
  args <- rlang::env_get_list(nms = c("out", "self"))
expected_types <- list(out = "Tensor", self = "Tensor")
nd_args <- c("out", "self")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'log1p_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_log2 <- function(self) {
  args <- rlang::env_get_list(nms = c("self"))
expected_types <- list(self = "Tensor")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'log2',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_log2_ <- function(self) {
  args <- rlang::env_get_list(nms = c("self"))
expected_types <- list(self = "Tensor")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'log2_',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_log2_out <- function(out, self) {
  args <- rlang::env_get_list(nms = c("out", "self"))
expected_types <- list(out = "Tensor", self = "Tensor")
nd_args <- c("out", "self")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'log2_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_logdet <- function(self) {
  args <- rlang::env_get_list(nms = c("self"))
expected_types <- list(self = "Tensor")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'logdet',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_logical_and <- function(self, other) {
  args <- rlang::env_get_list(nms = c("self", "other"))
expected_types <- list(self = "Tensor", other = "Tensor")
nd_args <- c("self", "other")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'logical_and',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_logical_and_out <- function(out, self, other) {
  args <- rlang::env_get_list(nms = c("out", "self", "other"))
expected_types <- list(out = "Tensor", self = "Tensor", other = "Tensor")
nd_args <- c("out", "self", "other")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'logical_and_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


.torch_logical_not <- function(self) {
  args <- rlang::env_get_list(nms = c("self"))
expected_types <- list(self = "Tensor")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'logical_not',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_logical_not_out <- function(out, self) {
  args <- rlang::env_get_list(nms = c("out", "self"))
expected_types <- list(out = "Tensor", self = "Tensor")
nd_args <- c("out", "self")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'logical_not_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_logical_or <- function(self, other) {
  args <- rlang::env_get_list(nms = c("self", "other"))
expected_types <- list(self = "Tensor", other = "Tensor")
nd_args <- c("self", "other")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'logical_or',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_logical_or_out <- function(out, self, other) {
  args <- rlang::env_get_list(nms = c("out", "self", "other"))
expected_types <- list(out = "Tensor", self = "Tensor", other = "Tensor")
nd_args <- c("out", "self", "other")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'logical_or_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_logical_xor <- function(self, other) {
  args <- rlang::env_get_list(nms = c("self", "other"))
expected_types <- list(self = "Tensor", other = "Tensor")
nd_args <- c("self", "other")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'logical_xor',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_logical_xor_out <- function(out, self, other) {
  args <- rlang::env_get_list(nms = c("out", "self", "other"))
expected_types <- list(out = "Tensor", self = "Tensor", other = "Tensor")
nd_args <- c("out", "self", "other")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'logical_xor_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


.torch_logspace <- function(start, end, steps = 100, base = 10.000000, options = list()) {
  args <- rlang::env_get_list(nms = c("start", "end", "steps", "base", "options"))
expected_types <- list(start = "Scalar", end = "Scalar", steps = "int64_t", base = "double", 
    options = "TensorOptions")
nd_args <- c("start", "end")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'logspace',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_logspace_out <- function(out, start, end, steps = 100, base = 10.000000) {
  args <- rlang::env_get_list(nms = c("out", "start", "end", "steps", "base"))
expected_types <- list(out = "Tensor", start = "Scalar", end = "Scalar", steps = "int64_t", 
    base = "double")
nd_args <- c("out", "start", "end")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'logspace_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_logsumexp <- function(self, dim, keepdim = FALSE) {
  args <- rlang::env_get_list(nms = c("self", "dim", "keepdim"))
expected_types <- list(self = "Tensor", dim = c("IntArrayRef", "DimnameList"), 
    keepdim = "bool")
nd_args <- c("self", "dim")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'logsumexp',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_logsumexp_out <- function(out, self, dim, keepdim = FALSE) {
  args <- rlang::env_get_list(nms = c("out", "self", "dim", "keepdim"))
expected_types <- list(out = "Tensor", self = "Tensor", dim = c("IntArrayRef", 
"DimnameList"), keepdim = "bool")
nd_args <- c("out", "self", "dim")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'logsumexp_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_lstm <- function(data, input, batch_sizes, hx, params, has_biases, num_layers, dropout, train, batch_first, bidirectional) {
  args <- rlang::env_get_list(nms = c("data", "input", "batch_sizes", "hx", "params", "has_biases", "num_layers", "dropout", "train", "batch_first", "bidirectional"))
expected_types <- list(data = "Tensor", input = "Tensor", batch_sizes = "Tensor", 
    hx = "TensorList", params = "TensorList", has_biases = "bool", 
    num_layers = "int64_t", dropout = "double", train = "bool", 
    batch_first = "bool", bidirectional = "bool")
nd_args <- c("data", "input", "batch_sizes", "hx", "params", "has_biases", 
"num_layers", "dropout", "train", "batch_first", "bidirectional"
)
return_types <- list(list("Tensor", "Tensor", "Tensor"))
call_c_function(
fun_name = 'lstm',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_lstm_cell <- function(input, hx, w_ih, w_hh, b_ih = list(), b_hh = list()) {
  args <- rlang::env_get_list(nms = c("input", "hx", "w_ih", "w_hh", "b_ih", "b_hh"))
expected_types <- list(input = "Tensor", hx = "TensorList", w_ih = "Tensor", w_hh = "Tensor", 
    b_ih = "Tensor", b_hh = "Tensor")
nd_args <- c("input", "hx", "w_ih", "w_hh")
return_types <- list(list("Tensor", "Tensor"))
call_c_function(
fun_name = 'lstm_cell',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_lstsq <- function(self, A) {
  args <- rlang::env_get_list(nms = c("self", "A"))
expected_types <- list(self = "Tensor", A = "Tensor")
nd_args <- c("self", "A")
return_types <- list(list("Tensor", "Tensor"))
call_c_function(
fun_name = 'lstsq',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_lstsq_out <- function(X, qr, self, A) {
  args <- rlang::env_get_list(nms = c("X", "qr", "self", "A"))
expected_types <- list(X = "Tensor", qr = "Tensor", self = "Tensor", A = "Tensor")
nd_args <- c("X", "qr", "self", "A")
return_types <- list(list("Tensor", "Tensor"))
call_c_function(
fun_name = 'lstsq_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_lt <- function(self, other) {
  args <- rlang::env_get_list(nms = c("self", "other"))
expected_types <- list(self = "Tensor", other = c("Scalar", "Tensor"))
nd_args <- c("self", "other")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'lt',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_lt_out <- function(out, self, other) {
  args <- rlang::env_get_list(nms = c("out", "self", "other"))
expected_types <- list(out = "Tensor", self = "Tensor", other = c("Scalar", "Tensor"
))
nd_args <- c("out", "self", "other")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'lt_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_lu_solve <- function(self, LU_data, LU_pivots) {
  args <- rlang::env_get_list(nms = c("self", "LU_data", "LU_pivots"))
expected_types <- list(self = "Tensor", LU_data = "Tensor", LU_pivots = "Tensor")
nd_args <- c("self", "LU_data", "LU_pivots")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'lu_solve',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_lu_solve_out <- function(out, self, LU_data, LU_pivots) {
  args <- rlang::env_get_list(nms = c("out", "self", "LU_data", "LU_pivots"))
expected_types <- list(out = "Tensor", self = "Tensor", LU_data = "Tensor", LU_pivots = "Tensor")
nd_args <- c("out", "self", "LU_data", "LU_pivots")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'lu_solve_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_margin_ranking_loss <- function(input1, input2, target, margin = 0.000000, reduction = torch_reduction_mean()) {
  args <- rlang::env_get_list(nms = c("input1", "input2", "target", "margin", "reduction"))
expected_types <- list(input1 = "Tensor", input2 = "Tensor", target = "Tensor", 
    margin = "double", reduction = "int64_t")
nd_args <- c("input1", "input2", "target")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'margin_ranking_loss',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_masked_fill <- function(self, mask, value) {
  args <- rlang::env_get_list(nms = c("self", "mask", "value"))
expected_types <- list(self = "Tensor", mask = "Tensor", value = c("Scalar", "Tensor"
))
nd_args <- c("self", "mask", "value")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'masked_fill',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_masked_scatter <- function(self, mask, source) {
  args <- rlang::env_get_list(nms = c("self", "mask", "source"))
expected_types <- list(self = "Tensor", mask = "Tensor", source = "Tensor")
nd_args <- c("self", "mask", "source")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'masked_scatter',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_masked_select <- function(self, mask) {
  args <- rlang::env_get_list(nms = c("self", "mask"))
expected_types <- list(self = "Tensor", mask = "Tensor")
nd_args <- c("self", "mask")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'masked_select',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_masked_select_out <- function(out, self, mask) {
  args <- rlang::env_get_list(nms = c("out", "self", "mask"))
expected_types <- list(out = "Tensor", self = "Tensor", mask = "Tensor")
nd_args <- c("out", "self", "mask")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'masked_select_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_matmul <- function(self, other) {
  args <- rlang::env_get_list(nms = c("self", "other"))
expected_types <- list(self = "Tensor", other = "Tensor")
nd_args <- c("self", "other")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'matmul',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_matmul_out <- function(out, self, other) {
  args <- rlang::env_get_list(nms = c("out", "self", "other"))
expected_types <- list(out = "Tensor", self = "Tensor", other = "Tensor")
nd_args <- c("out", "self", "other")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'matmul_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_matrix_power <- function(self, n) {
  args <- rlang::env_get_list(nms = c("self", "n"))
expected_types <- list(self = "Tensor", n = "int64_t")
nd_args <- c("self", "n")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'matrix_power',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_matrix_rank <- function(self, tol, symmetric = FALSE) {
  args <- rlang::env_get_list(nms = c("self", "tol", "symmetric"))
expected_types <- list(self = "Tensor", tol = "double", symmetric = "bool")
nd_args <- c("self", "tol")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'matrix_rank',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_max <- function(self, dim, other, keepdim = FALSE) {
  args <- rlang::env_get_list(nms = c("self", "dim", "other", "keepdim"))
expected_types <- list(self = "Tensor", dim = c("int64_t", "Dimname"), other = "Tensor", 
    keepdim = "bool")
nd_args <- c("self", "dim", "other")
return_types <- list(list("Tensor", "Tensor"), list('Tensor'))
call_c_function(
fun_name = 'max',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_max_out <- function(max, out, max_values, other, self, dim, keepdim = FALSE) {
  args <- rlang::env_get_list(nms = c("max", "out", "max_values", "other", "self", "dim", "keepdim"))
expected_types <- list(max = "Tensor", out = "Tensor", max_values = "Tensor", other = "Tensor", 
    self = "Tensor", dim = c("int64_t", "Dimname"), keepdim = "bool")
nd_args <- c("max", "out", "max_values", "other", "self", "dim")
return_types <- list(list("Tensor", "Tensor"), list('Tensor'))
call_c_function(
fun_name = 'max_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_max_pool1d <- function(self, kernel_size, stride = list(), padding = 0, dilation = 1, ceil_mode = FALSE) {
  args <- rlang::env_get_list(nms = c("self", "kernel_size", "stride", "padding", "dilation", "ceil_mode"))
expected_types <- list(self = "Tensor", kernel_size = "IntArrayRef", stride = "IntArrayRef", 
    padding = "IntArrayRef", dilation = "IntArrayRef", ceil_mode = "bool")
nd_args <- c("self", "kernel_size")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'max_pool1d',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_max_pool1d_with_indices <- function(self, kernel_size, stride = list(), padding = 0, dilation = 1, ceil_mode = FALSE) {
  args <- rlang::env_get_list(nms = c("self", "kernel_size", "stride", "padding", "dilation", "ceil_mode"))
expected_types <- list(self = "Tensor", kernel_size = "IntArrayRef", stride = "IntArrayRef", 
    padding = "IntArrayRef", dilation = "IntArrayRef", ceil_mode = "bool")
nd_args <- c("self", "kernel_size")
return_types <- list(list("Tensor", "Tensor"))
call_c_function(
fun_name = 'max_pool1d_with_indices',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_max_pool2d <- function(self, kernel_size, stride = list(), padding = 0, dilation = 1, ceil_mode = FALSE) {
  args <- rlang::env_get_list(nms = c("self", "kernel_size", "stride", "padding", "dilation", "ceil_mode"))
expected_types <- list(self = "Tensor", kernel_size = "IntArrayRef", stride = "IntArrayRef", 
    padding = "IntArrayRef", dilation = "IntArrayRef", ceil_mode = "bool")
nd_args <- c("self", "kernel_size")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'max_pool2d',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_max_pool2d_with_indices <- function(self, kernel_size, stride = list(), padding = 0, dilation = 1, ceil_mode = FALSE) {
  args <- rlang::env_get_list(nms = c("self", "kernel_size", "stride", "padding", "dilation", "ceil_mode"))
expected_types <- list(self = "Tensor", kernel_size = "IntArrayRef", stride = "IntArrayRef", 
    padding = "IntArrayRef", dilation = "IntArrayRef", ceil_mode = "bool")
nd_args <- c("self", "kernel_size")
return_types <- list(list("Tensor", "Tensor"))
call_c_function(
fun_name = 'max_pool2d_with_indices',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_max_pool2d_with_indices_backward <- function(grad_output, self, kernel_size, stride, padding, dilation, ceil_mode, indices) {
  args <- rlang::env_get_list(nms = c("grad_output", "self", "kernel_size", "stride", "padding", "dilation", "ceil_mode", "indices"))
expected_types <- list(grad_output = "Tensor", self = "Tensor", kernel_size = "IntArrayRef", 
    stride = "IntArrayRef", padding = "IntArrayRef", dilation = "IntArrayRef", 
    ceil_mode = "bool", indices = "Tensor")
nd_args <- c("grad_output", "self", "kernel_size", "stride", "padding", 
"dilation", "ceil_mode", "indices")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'max_pool2d_with_indices_backward',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_max_pool2d_with_indices_backward_out <- function(grad_input, grad_output, self, kernel_size, stride, padding, dilation, ceil_mode, indices) {
  args <- rlang::env_get_list(nms = c("grad_input", "grad_output", "self", "kernel_size", "stride", "padding", "dilation", "ceil_mode", "indices"))
expected_types <- list(grad_input = "Tensor", grad_output = "Tensor", self = "Tensor", 
    kernel_size = "IntArrayRef", stride = "IntArrayRef", padding = "IntArrayRef", 
    dilation = "IntArrayRef", ceil_mode = "bool", indices = "Tensor")
nd_args <- c("grad_input", "grad_output", "self", "kernel_size", "stride", 
"padding", "dilation", "ceil_mode", "indices")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'max_pool2d_with_indices_backward_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_max_pool2d_with_indices_out <- function(out, indices, self, kernel_size, stride = list(), padding = 0, dilation = 1, ceil_mode = FALSE) {
  args <- rlang::env_get_list(nms = c("out", "indices", "self", "kernel_size", "stride", "padding", "dilation", "ceil_mode"))
expected_types <- list(out = "Tensor", indices = "Tensor", self = "Tensor", kernel_size = "IntArrayRef", 
    stride = "IntArrayRef", padding = "IntArrayRef", dilation = "IntArrayRef", 
    ceil_mode = "bool")
nd_args <- c("out", "indices", "self", "kernel_size")
return_types <- list(list("Tensor", "Tensor"))
call_c_function(
fun_name = 'max_pool2d_with_indices_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_max_pool3d <- function(self, kernel_size, stride = list(), padding = 0, dilation = 1, ceil_mode = FALSE) {
  args <- rlang::env_get_list(nms = c("self", "kernel_size", "stride", "padding", "dilation", "ceil_mode"))
expected_types <- list(self = "Tensor", kernel_size = "IntArrayRef", stride = "IntArrayRef", 
    padding = "IntArrayRef", dilation = "IntArrayRef", ceil_mode = "bool")
nd_args <- c("self", "kernel_size")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'max_pool3d',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_max_pool3d_with_indices <- function(self, kernel_size, stride = list(), padding = 0, dilation = 1, ceil_mode = FALSE) {
  args <- rlang::env_get_list(nms = c("self", "kernel_size", "stride", "padding", "dilation", "ceil_mode"))
expected_types <- list(self = "Tensor", kernel_size = "IntArrayRef", stride = "IntArrayRef", 
    padding = "IntArrayRef", dilation = "IntArrayRef", ceil_mode = "bool")
nd_args <- c("self", "kernel_size")
return_types <- list(list("Tensor", "Tensor"))
call_c_function(
fun_name = 'max_pool3d_with_indices',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_max_pool3d_with_indices_backward <- function(grad_output, self, kernel_size, stride, padding, dilation, ceil_mode, indices) {
  args <- rlang::env_get_list(nms = c("grad_output", "self", "kernel_size", "stride", "padding", "dilation", "ceil_mode", "indices"))
expected_types <- list(grad_output = "Tensor", self = "Tensor", kernel_size = "IntArrayRef", 
    stride = "IntArrayRef", padding = "IntArrayRef", dilation = "IntArrayRef", 
    ceil_mode = "bool", indices = "Tensor")
nd_args <- c("grad_output", "self", "kernel_size", "stride", "padding", 
"dilation", "ceil_mode", "indices")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'max_pool3d_with_indices_backward',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_max_pool3d_with_indices_backward_out <- function(grad_input, grad_output, self, kernel_size, stride, padding, dilation, ceil_mode, indices) {
  args <- rlang::env_get_list(nms = c("grad_input", "grad_output", "self", "kernel_size", "stride", "padding", "dilation", "ceil_mode", "indices"))
expected_types <- list(grad_input = "Tensor", grad_output = "Tensor", self = "Tensor", 
    kernel_size = "IntArrayRef", stride = "IntArrayRef", padding = "IntArrayRef", 
    dilation = "IntArrayRef", ceil_mode = "bool", indices = "Tensor")
nd_args <- c("grad_input", "grad_output", "self", "kernel_size", "stride", 
"padding", "dilation", "ceil_mode", "indices")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'max_pool3d_with_indices_backward_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_max_pool3d_with_indices_out <- function(out, indices, self, kernel_size, stride = list(), padding = 0, dilation = 1, ceil_mode = FALSE) {
  args <- rlang::env_get_list(nms = c("out", "indices", "self", "kernel_size", "stride", "padding", "dilation", "ceil_mode"))
expected_types <- list(out = "Tensor", indices = "Tensor", self = "Tensor", kernel_size = "IntArrayRef", 
    stride = "IntArrayRef", padding = "IntArrayRef", dilation = "IntArrayRef", 
    ceil_mode = "bool")
nd_args <- c("out", "indices", "self", "kernel_size")
return_types <- list(list("Tensor", "Tensor"))
call_c_function(
fun_name = 'max_pool3d_with_indices_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_max_unpool2d <- function(self, indices, output_size) {
  args <- rlang::env_get_list(nms = c("self", "indices", "output_size"))
expected_types <- list(self = "Tensor", indices = "Tensor", output_size = "IntArrayRef")
nd_args <- c("self", "indices", "output_size")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'max_unpool2d',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_max_unpool2d_backward <- function(grad_output, self, indices, output_size) {
  args <- rlang::env_get_list(nms = c("grad_output", "self", "indices", "output_size"))
expected_types <- list(grad_output = "Tensor", self = "Tensor", indices = "Tensor", 
    output_size = "IntArrayRef")
nd_args <- c("grad_output", "self", "indices", "output_size")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'max_unpool2d_backward',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_max_unpool2d_backward_out <- function(grad_input, grad_output, self, indices, output_size) {
  args <- rlang::env_get_list(nms = c("grad_input", "grad_output", "self", "indices", "output_size"))
expected_types <- list(grad_input = "Tensor", grad_output = "Tensor", self = "Tensor", 
    indices = "Tensor", output_size = "IntArrayRef")
nd_args <- c("grad_input", "grad_output", "self", "indices", "output_size"
)
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'max_unpool2d_backward_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_max_unpool2d_out <- function(out, self, indices, output_size) {
  args <- rlang::env_get_list(nms = c("out", "self", "indices", "output_size"))
expected_types <- list(out = "Tensor", self = "Tensor", indices = "Tensor", output_size = "IntArrayRef")
nd_args <- c("out", "self", "indices", "output_size")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'max_unpool2d_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_max_unpool3d <- function(self, indices, output_size, stride, padding) {
  args <- rlang::env_get_list(nms = c("self", "indices", "output_size", "stride", "padding"))
expected_types <- list(self = "Tensor", indices = "Tensor", output_size = "IntArrayRef", 
    stride = "IntArrayRef", padding = "IntArrayRef")
nd_args <- c("self", "indices", "output_size", "stride", "padding")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'max_unpool3d',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_max_unpool3d_backward <- function(grad_output, self, indices, output_size, stride, padding) {
  args <- rlang::env_get_list(nms = c("grad_output", "self", "indices", "output_size", "stride", "padding"))
expected_types <- list(grad_output = "Tensor", self = "Tensor", indices = "Tensor", 
    output_size = "IntArrayRef", stride = "IntArrayRef", padding = "IntArrayRef")
nd_args <- c("grad_output", "self", "indices", "output_size", "stride", 
"padding")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'max_unpool3d_backward',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_max_unpool3d_backward_out <- function(grad_input, grad_output, self, indices, output_size, stride, padding) {
  args <- rlang::env_get_list(nms = c("grad_input", "grad_output", "self", "indices", "output_size", "stride", "padding"))
expected_types <- list(grad_input = "Tensor", grad_output = "Tensor", self = "Tensor", 
    indices = "Tensor", output_size = "IntArrayRef", stride = "IntArrayRef", 
    padding = "IntArrayRef")
nd_args <- c("grad_input", "grad_output", "self", "indices", "output_size", 
"stride", "padding")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'max_unpool3d_backward_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_max_unpool3d_out <- function(out, self, indices, output_size, stride, padding) {
  args <- rlang::env_get_list(nms = c("out", "self", "indices", "output_size", "stride", "padding"))
expected_types <- list(out = "Tensor", self = "Tensor", indices = "Tensor", output_size = "IntArrayRef", 
    stride = "IntArrayRef", padding = "IntArrayRef")
nd_args <- c("out", "self", "indices", "output_size", "stride", "padding"
)
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'max_unpool3d_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_max_values <- function(self, dim, keepdim = FALSE) {
  args <- rlang::env_get_list(nms = c("self", "dim", "keepdim"))
expected_types <- list(self = "Tensor", dim = c("IntArrayRef", "DimnameList"), 
    keepdim = "bool")
nd_args <- c("self", "dim")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'max_values',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_mean <- function(self, dim, keepdim = FALSE, dtype = NULL) {
  args <- rlang::env_get_list(nms = c("self", "dim", "keepdim", "dtype"))
expected_types <- list(self = "Tensor", dim = c("IntArrayRef", "DimnameList"), 
    keepdim = "bool", dtype = "ScalarType")
nd_args <- c("self", "dim")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'mean',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_mean_out <- function(out, self, dim, keepdim = FALSE, dtype = NULL) {
  args <- rlang::env_get_list(nms = c("out", "self", "dim", "keepdim", "dtype"))
expected_types <- list(out = "Tensor", self = "Tensor", dim = c("IntArrayRef", 
"DimnameList"), keepdim = "bool", dtype = "ScalarType")
nd_args <- c("out", "self", "dim")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'mean_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_median <- function(self, dim, keepdim = FALSE) {
  args <- rlang::env_get_list(nms = c("self", "dim", "keepdim"))
expected_types <- list(self = "Tensor", dim = c("int64_t", "Dimname"), keepdim = "bool")
nd_args <- c("self", "dim")
return_types <- list(list("Tensor", "Tensor"), list('Tensor'))
call_c_function(
fun_name = 'median',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_median_out <- function(values, indices, self, dim, keepdim = FALSE) {
  args <- rlang::env_get_list(nms = c("values", "indices", "self", "dim", "keepdim"))
expected_types <- list(values = "Tensor", indices = "Tensor", self = "Tensor", 
    dim = c("int64_t", "Dimname"), keepdim = "bool")
nd_args <- c("values", "indices", "self", "dim")
return_types <- list(list("Tensor", "Tensor"))
call_c_function(
fun_name = 'median_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_meshgrid <- function(tensors) {
  args <- rlang::env_get_list(nms = c("tensors"))
expected_types <- list(tensors = "TensorList")
nd_args <- "tensors"
return_types <- list(list('TensorList'))
call_c_function(
fun_name = 'meshgrid',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_min <- function(self, dim, other, keepdim = FALSE) {
  args <- rlang::env_get_list(nms = c("self", "dim", "other", "keepdim"))
expected_types <- list(self = "Tensor", dim = c("int64_t", "Dimname"), other = "Tensor", 
    keepdim = "bool")
nd_args <- c("self", "dim", "other")
return_types <- list(list("Tensor", "Tensor"), list('Tensor'))
call_c_function(
fun_name = 'min',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_min_out <- function(min, out, min_indices, other, self, dim, keepdim = FALSE) {
  args <- rlang::env_get_list(nms = c("min", "out", "min_indices", "other", "self", "dim", "keepdim"))
expected_types <- list(min = "Tensor", out = "Tensor", min_indices = "Tensor", 
    other = "Tensor", self = "Tensor", dim = c("int64_t", "Dimname"
    ), keepdim = "bool")
nd_args <- c("min", "out", "min_indices", "other", "self", "dim")
return_types <- list(list("Tensor", "Tensor"), list('Tensor'))
call_c_function(
fun_name = 'min_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_min_values <- function(self, dim, keepdim = FALSE) {
  args <- rlang::env_get_list(nms = c("self", "dim", "keepdim"))
expected_types <- list(self = "Tensor", dim = c("IntArrayRef", "DimnameList"), 
    keepdim = "bool")
nd_args <- c("self", "dim")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'min_values',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_miopen_batch_norm <- function(input, weight, bias, running_mean, running_var, training, exponential_average_factor, epsilon) {
  args <- rlang::env_get_list(nms = c("input", "weight", "bias", "running_mean", "running_var", "training", "exponential_average_factor", "epsilon"))
expected_types <- list(input = "Tensor", weight = "Tensor", bias = "Tensor", running_mean = "Tensor", 
    running_var = "Tensor", training = "bool", exponential_average_factor = "double", 
    epsilon = "double")
nd_args <- c("input", "weight", "bias", "running_mean", "running_var", "training", 
"exponential_average_factor", "epsilon")
return_types <- list(list("Tensor", "Tensor", "Tensor"))
call_c_function(
fun_name = 'miopen_batch_norm',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_miopen_batch_norm_backward <- function(input, grad_output, weight, running_mean, running_var, save_mean, save_var, epsilon) {
  args <- rlang::env_get_list(nms = c("input", "grad_output", "weight", "running_mean", "running_var", "save_mean", "save_var", "epsilon"))
expected_types <- list(input = "Tensor", grad_output = "Tensor", weight = "Tensor", 
    running_mean = "Tensor", running_var = "Tensor", save_mean = "Tensor", 
    save_var = "Tensor", epsilon = "double")
nd_args <- c("input", "grad_output", "weight", "running_mean", "running_var", 
"save_mean", "save_var", "epsilon")
return_types <- list(list("Tensor", "Tensor", "Tensor"))
call_c_function(
fun_name = 'miopen_batch_norm_backward',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_miopen_convolution <- function(self, weight, bias, padding, stride, dilation, groups, benchmark, deterministic) {
  args <- rlang::env_get_list(nms = c("self", "weight", "bias", "padding", "stride", "dilation", "groups", "benchmark", "deterministic"))
expected_types <- list(self = "Tensor", weight = "Tensor", bias = "Tensor", padding = "IntArrayRef", 
    stride = "IntArrayRef", dilation = "IntArrayRef", groups = "int64_t", 
    benchmark = "bool", deterministic = "bool")
nd_args <- c("self", "weight", "bias", "padding", "stride", "dilation", 
"groups", "benchmark", "deterministic")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'miopen_convolution',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_miopen_convolution_backward <- function(self, grad_output, weight, padding, stride, dilation, groups, benchmark, deterministic, output_mask) {
  args <- rlang::env_get_list(nms = c("self", "grad_output", "weight", "padding", "stride", "dilation", "groups", "benchmark", "deterministic", "output_mask"))
expected_types <- list(self = "Tensor", grad_output = "Tensor", weight = "Tensor", 
    padding = "IntArrayRef", stride = "IntArrayRef", dilation = "IntArrayRef", 
    groups = "int64_t", benchmark = "bool", deterministic = "bool", 
    output_mask = "std::array<bool,3>")
nd_args <- c("self", "grad_output", "weight", "padding", "stride", "dilation", 
"groups", "benchmark", "deterministic", "output_mask")
return_types <- list(list("Tensor", "Tensor", "Tensor"))
call_c_function(
fun_name = 'miopen_convolution_backward',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_miopen_convolution_backward_bias <- function(grad_output) {
  args <- rlang::env_get_list(nms = c("grad_output"))
expected_types <- list(grad_output = "Tensor")
nd_args <- "grad_output"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'miopen_convolution_backward_bias',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_miopen_convolution_backward_input <- function(self_size, grad_output, weight, padding, stride, dilation, groups, benchmark, deterministic) {
  args <- rlang::env_get_list(nms = c("self_size", "grad_output", "weight", "padding", "stride", "dilation", "groups", "benchmark", "deterministic"))
expected_types <- list(self_size = "IntArrayRef", grad_output = "Tensor", weight = "Tensor", 
    padding = "IntArrayRef", stride = "IntArrayRef", dilation = "IntArrayRef", 
    groups = "int64_t", benchmark = "bool", deterministic = "bool")
nd_args <- c("self_size", "grad_output", "weight", "padding", "stride", 
"dilation", "groups", "benchmark", "deterministic")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'miopen_convolution_backward_input',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_miopen_convolution_backward_weight <- function(weight_size, grad_output, self, padding, stride, dilation, groups, benchmark, deterministic) {
  args <- rlang::env_get_list(nms = c("weight_size", "grad_output", "self", "padding", "stride", "dilation", "groups", "benchmark", "deterministic"))
expected_types <- list(weight_size = "IntArrayRef", grad_output = "Tensor", self = "Tensor", 
    padding = "IntArrayRef", stride = "IntArrayRef", dilation = "IntArrayRef", 
    groups = "int64_t", benchmark = "bool", deterministic = "bool")
nd_args <- c("weight_size", "grad_output", "self", "padding", "stride", 
"dilation", "groups", "benchmark", "deterministic")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'miopen_convolution_backward_weight',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_miopen_convolution_transpose <- function(self, weight, bias, padding, output_padding, stride, dilation, groups, benchmark, deterministic) {
  args <- rlang::env_get_list(nms = c("self", "weight", "bias", "padding", "output_padding", "stride", "dilation", "groups", "benchmark", "deterministic"))
expected_types <- list(self = "Tensor", weight = "Tensor", bias = "Tensor", padding = "IntArrayRef", 
    output_padding = "IntArrayRef", stride = "IntArrayRef", dilation = "IntArrayRef", 
    groups = "int64_t", benchmark = "bool", deterministic = "bool")
nd_args <- c("self", "weight", "bias", "padding", "output_padding", "stride", 
"dilation", "groups", "benchmark", "deterministic")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'miopen_convolution_transpose',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_miopen_convolution_transpose_backward <- function(self, grad_output, weight, padding, output_padding, stride, dilation, groups, benchmark, deterministic, output_mask) {
  args <- rlang::env_get_list(nms = c("self", "grad_output", "weight", "padding", "output_padding", "stride", "dilation", "groups", "benchmark", "deterministic", "output_mask"))
expected_types <- list(self = "Tensor", grad_output = "Tensor", weight = "Tensor", 
    padding = "IntArrayRef", output_padding = "IntArrayRef", 
    stride = "IntArrayRef", dilation = "IntArrayRef", groups = "int64_t", 
    benchmark = "bool", deterministic = "bool", output_mask = "std::array<bool,3>")
nd_args <- c("self", "grad_output", "weight", "padding", "output_padding", 
"stride", "dilation", "groups", "benchmark", "deterministic", 
"output_mask")
return_types <- list(list("Tensor", "Tensor", "Tensor"))
call_c_function(
fun_name = 'miopen_convolution_transpose_backward',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_miopen_convolution_transpose_backward_input <- function(grad_output, weight, padding, stride, dilation, groups, benchmark, deterministic) {
  args <- rlang::env_get_list(nms = c("grad_output", "weight", "padding", "stride", "dilation", "groups", "benchmark", "deterministic"))
expected_types <- list(grad_output = "Tensor", weight = "Tensor", padding = "IntArrayRef", 
    stride = "IntArrayRef", dilation = "IntArrayRef", groups = "int64_t", 
    benchmark = "bool", deterministic = "bool")
nd_args <- c("grad_output", "weight", "padding", "stride", "dilation", "groups", 
"benchmark", "deterministic")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'miopen_convolution_transpose_backward_input',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_miopen_convolution_transpose_backward_weight <- function(weight_size, grad_output, self, padding, stride, dilation, groups, benchmark, deterministic) {
  args <- rlang::env_get_list(nms = c("weight_size", "grad_output", "self", "padding", "stride", "dilation", "groups", "benchmark", "deterministic"))
expected_types <- list(weight_size = "IntArrayRef", grad_output = "Tensor", self = "Tensor", 
    padding = "IntArrayRef", stride = "IntArrayRef", dilation = "IntArrayRef", 
    groups = "int64_t", benchmark = "bool", deterministic = "bool")
nd_args <- c("weight_size", "grad_output", "self", "padding", "stride", 
"dilation", "groups", "benchmark", "deterministic")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'miopen_convolution_transpose_backward_weight',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_miopen_depthwise_convolution <- function(self, weight, bias, padding, stride, dilation, groups, benchmark, deterministic) {
  args <- rlang::env_get_list(nms = c("self", "weight", "bias", "padding", "stride", "dilation", "groups", "benchmark", "deterministic"))
expected_types <- list(self = "Tensor", weight = "Tensor", bias = "Tensor", padding = "IntArrayRef", 
    stride = "IntArrayRef", dilation = "IntArrayRef", groups = "int64_t", 
    benchmark = "bool", deterministic = "bool")
nd_args <- c("self", "weight", "bias", "padding", "stride", "dilation", 
"groups", "benchmark", "deterministic")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'miopen_depthwise_convolution',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_miopen_depthwise_convolution_backward <- function(self, grad_output, weight, padding, stride, dilation, groups, benchmark, deterministic, output_mask) {
  args <- rlang::env_get_list(nms = c("self", "grad_output", "weight", "padding", "stride", "dilation", "groups", "benchmark", "deterministic", "output_mask"))
expected_types <- list(self = "Tensor", grad_output = "Tensor", weight = "Tensor", 
    padding = "IntArrayRef", stride = "IntArrayRef", dilation = "IntArrayRef", 
    groups = "int64_t", benchmark = "bool", deterministic = "bool", 
    output_mask = "std::array<bool,3>")
nd_args <- c("self", "grad_output", "weight", "padding", "stride", "dilation", 
"groups", "benchmark", "deterministic", "output_mask")
return_types <- list(list("Tensor", "Tensor", "Tensor"))
call_c_function(
fun_name = 'miopen_depthwise_convolution_backward',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_miopen_depthwise_convolution_backward_input <- function(self_size, grad_output, weight, padding, stride, dilation, groups, benchmark, deterministic) {
  args <- rlang::env_get_list(nms = c("self_size", "grad_output", "weight", "padding", "stride", "dilation", "groups", "benchmark", "deterministic"))
expected_types <- list(self_size = "IntArrayRef", grad_output = "Tensor", weight = "Tensor", 
    padding = "IntArrayRef", stride = "IntArrayRef", dilation = "IntArrayRef", 
    groups = "int64_t", benchmark = "bool", deterministic = "bool")
nd_args <- c("self_size", "grad_output", "weight", "padding", "stride", 
"dilation", "groups", "benchmark", "deterministic")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'miopen_depthwise_convolution_backward_input',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_miopen_depthwise_convolution_backward_weight <- function(weight_size, grad_output, self, padding, stride, dilation, groups, benchmark, deterministic) {
  args <- rlang::env_get_list(nms = c("weight_size", "grad_output", "self", "padding", "stride", "dilation", "groups", "benchmark", "deterministic"))
expected_types <- list(weight_size = "IntArrayRef", grad_output = "Tensor", self = "Tensor", 
    padding = "IntArrayRef", stride = "IntArrayRef", dilation = "IntArrayRef", 
    groups = "int64_t", benchmark = "bool", deterministic = "bool")
nd_args <- c("weight_size", "grad_output", "self", "padding", "stride", 
"dilation", "groups", "benchmark", "deterministic")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'miopen_depthwise_convolution_backward_weight',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_miopen_rnn <- function(input, weight, weight_stride0, hx, cx, mode, hidden_size, num_layers, batch_first, dropout, train, bidirectional, batch_sizes, dropout_state) {
  args <- rlang::env_get_list(nms = c("input", "weight", "weight_stride0", "hx", "cx", "mode", "hidden_size", "num_layers", "batch_first", "dropout", "train", "bidirectional", "batch_sizes", "dropout_state"))
expected_types <- list(input = "Tensor", weight = "TensorList", weight_stride0 = "int64_t", 
    hx = "Tensor", cx = "Tensor", mode = "int64_t", hidden_size = "int64_t", 
    num_layers = "int64_t", batch_first = "bool", dropout = "double", 
    train = "bool", bidirectional = "bool", batch_sizes = "IntArrayRef", 
    dropout_state = "Tensor")
nd_args <- c("input", "weight", "weight_stride0", "hx", "cx", "mode", "hidden_size", 
"num_layers", "batch_first", "dropout", "train", "bidirectional", 
"batch_sizes", "dropout_state")
return_types <- list(list("Tensor", "Tensor", "Tensor", "Tensor", "Tensor"))
call_c_function(
fun_name = 'miopen_rnn',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_miopen_rnn_backward <- function(input, weight, weight_stride0, weight_buf, hx, cx, output, grad_output, grad_hy, grad_cy, mode, hidden_size, num_layers, batch_first, dropout, train, bidirectional, batch_sizes, dropout_state, reserve, output_mask) {
  args <- rlang::env_get_list(nms = c("input", "weight", "weight_stride0", "weight_buf", "hx", "cx", "output", "grad_output", "grad_hy", "grad_cy", "mode", "hidden_size", "num_layers", "batch_first", "dropout", "train", "bidirectional", "batch_sizes", "dropout_state", "reserve", "output_mask"))
expected_types <- list(input = "Tensor", weight = "TensorList", weight_stride0 = "int64_t", 
    weight_buf = "Tensor", hx = "Tensor", cx = "Tensor", output = "Tensor", 
    grad_output = "Tensor", grad_hy = "Tensor", grad_cy = "Tensor", 
    mode = "int64_t", hidden_size = "int64_t", num_layers = "int64_t", 
    batch_first = "bool", dropout = "double", train = "bool", 
    bidirectional = "bool", batch_sizes = "IntArrayRef", dropout_state = "Tensor", 
    reserve = "Tensor", output_mask = "std::array<bool,4>")
nd_args <- c("input", "weight", "weight_stride0", "weight_buf", "hx", "cx", 
"output", "grad_output", "grad_hy", "grad_cy", "mode", "hidden_size", 
"num_layers", "batch_first", "dropout", "train", "bidirectional", 
"batch_sizes", "dropout_state", "reserve", "output_mask")
return_types <- list(list("Tensor", "Tensor", "Tensor", "TensorList"))
call_c_function(
fun_name = 'miopen_rnn_backward',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_mkldnn_adaptive_avg_pool2d <- function(self, output_size) {
  args <- rlang::env_get_list(nms = c("self", "output_size"))
expected_types <- list(self = "Tensor", output_size = "IntArrayRef")
nd_args <- c("self", "output_size")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'mkldnn_adaptive_avg_pool2d',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_mkldnn_convolution <- function(self, weight, bias, padding, stride, dilation, groups) {
  args <- rlang::env_get_list(nms = c("self", "weight", "bias", "padding", "stride", "dilation", "groups"))
expected_types <- list(self = "Tensor", weight = "Tensor", bias = "Tensor", padding = "IntArrayRef", 
    stride = "IntArrayRef", dilation = "IntArrayRef", groups = "int64_t")
nd_args <- c("self", "weight", "bias", "padding", "stride", "dilation", 
"groups")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'mkldnn_convolution',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_mkldnn_convolution_backward <- function(self, grad_output, weight, padding, stride, dilation, groups, output_mask) {
  args <- rlang::env_get_list(nms = c("self", "grad_output", "weight", "padding", "stride", "dilation", "groups", "output_mask"))
expected_types <- list(self = "Tensor", grad_output = "Tensor", weight = "Tensor", 
    padding = "IntArrayRef", stride = "IntArrayRef", dilation = "IntArrayRef", 
    groups = "int64_t", output_mask = "std::array<bool,3>")
nd_args <- c("self", "grad_output", "weight", "padding", "stride", "dilation", 
"groups", "output_mask")
return_types <- list(list("Tensor", "Tensor", "Tensor"))
call_c_function(
fun_name = 'mkldnn_convolution_backward',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_mkldnn_convolution_backward_input <- function(self_size, grad_output, weight, padding, stride, dilation, groups, bias_defined) {
  args <- rlang::env_get_list(nms = c("self_size", "grad_output", "weight", "padding", "stride", "dilation", "groups", "bias_defined"))
expected_types <- list(self_size = "IntArrayRef", grad_output = "Tensor", weight = "Tensor", 
    padding = "IntArrayRef", stride = "IntArrayRef", dilation = "IntArrayRef", 
    groups = "int64_t", bias_defined = "bool")
nd_args <- c("self_size", "grad_output", "weight", "padding", "stride", 
"dilation", "groups", "bias_defined")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'mkldnn_convolution_backward_input',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_mkldnn_convolution_backward_weights <- function(weight_size, grad_output, self, padding, stride, dilation, groups, bias_defined) {
  args <- rlang::env_get_list(nms = c("weight_size", "grad_output", "self", "padding", "stride", "dilation", "groups", "bias_defined"))
expected_types <- list(weight_size = "IntArrayRef", grad_output = "Tensor", self = "Tensor", 
    padding = "IntArrayRef", stride = "IntArrayRef", dilation = "IntArrayRef", 
    groups = "int64_t", bias_defined = "bool")
nd_args <- c("weight_size", "grad_output", "self", "padding", "stride", 
"dilation", "groups", "bias_defined")
return_types <- list(list("Tensor", "Tensor"))
call_c_function(
fun_name = 'mkldnn_convolution_backward_weights',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_mkldnn_linear <- function(input, weight, bias = list()) {
  args <- rlang::env_get_list(nms = c("input", "weight", "bias"))
expected_types <- list(input = "Tensor", weight = "Tensor", bias = "Tensor")
nd_args <- c("input", "weight")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'mkldnn_linear',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_mkldnn_max_pool2d <- function(self, kernel_size, stride = list(), padding = 0, dilation = 1, ceil_mode = FALSE) {
  args <- rlang::env_get_list(nms = c("self", "kernel_size", "stride", "padding", "dilation", "ceil_mode"))
expected_types <- list(self = "Tensor", kernel_size = "IntArrayRef", stride = "IntArrayRef", 
    padding = "IntArrayRef", dilation = "IntArrayRef", ceil_mode = "bool")
nd_args <- c("self", "kernel_size")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'mkldnn_max_pool2d',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_mkldnn_reorder_conv2d_weight <- function(self, padding = 0, stride = 1, dilation = 1, groups = 1) {
  args <- rlang::env_get_list(nms = c("self", "padding", "stride", "dilation", "groups"))
expected_types <- list(self = "Tensor", padding = "IntArrayRef", stride = "IntArrayRef", 
    dilation = "IntArrayRef", groups = "int64_t")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'mkldnn_reorder_conv2d_weight',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_mm <- function(self, mat2) {
  args <- rlang::env_get_list(nms = c("self", "mat2"))
expected_types <- list(self = "Tensor", mat2 = "Tensor")
nd_args <- c("self", "mat2")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'mm',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_mm_out <- function(out, self, mat2) {
  args <- rlang::env_get_list(nms = c("out", "self", "mat2"))
expected_types <- list(out = "Tensor", self = "Tensor", mat2 = "Tensor")
nd_args <- c("out", "self", "mat2")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'mm_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_mode <- function(self, dim = -1, keepdim = FALSE) {
  args <- rlang::env_get_list(nms = c("self", "dim", "keepdim"))
expected_types <- list(self = "Tensor", dim = c("int64_t", "Dimname"), keepdim = "bool")
nd_args <- "self"
return_types <- list(list("Tensor", "Tensor"))
call_c_function(
fun_name = 'mode',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_mode_out <- function(values, indices, self, dim = -1, keepdim = FALSE) {
  args <- rlang::env_get_list(nms = c("values", "indices", "self", "dim", "keepdim"))
expected_types <- list(values = "Tensor", indices = "Tensor", self = "Tensor", 
    dim = c("int64_t", "Dimname"), keepdim = "bool")
nd_args <- c("values", "indices", "self")
return_types <- list(list("Tensor", "Tensor"))
call_c_function(
fun_name = 'mode_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_mse_loss <- function(self, target, reduction = torch_reduction_mean()) {
  args <- rlang::env_get_list(nms = c("self", "target", "reduction"))
expected_types <- list(self = "Tensor", target = "Tensor", reduction = "int64_t")
nd_args <- c("self", "target")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'mse_loss',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_mse_loss_backward <- function(grad_output, self, target, reduction) {
  args <- rlang::env_get_list(nms = c("grad_output", "self", "target", "reduction"))
expected_types <- list(grad_output = "Tensor", self = "Tensor", target = "Tensor", 
    reduction = "int64_t")
nd_args <- c("grad_output", "self", "target", "reduction")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'mse_loss_backward',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_mse_loss_backward_out <- function(grad_input, grad_output, self, target, reduction) {
  args <- rlang::env_get_list(nms = c("grad_input", "grad_output", "self", "target", "reduction"))
expected_types <- list(grad_input = "Tensor", grad_output = "Tensor", self = "Tensor", 
    target = "Tensor", reduction = "int64_t")
nd_args <- c("grad_input", "grad_output", "self", "target", "reduction")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'mse_loss_backward_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_mse_loss_out <- function(out, self, target, reduction = torch_reduction_mean()) {
  args <- rlang::env_get_list(nms = c("out", "self", "target", "reduction"))
expected_types <- list(out = "Tensor", self = "Tensor", target = "Tensor", reduction = "int64_t")
nd_args <- c("out", "self", "target")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'mse_loss_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_mul <- function(self, other) {
  args <- rlang::env_get_list(nms = c("self", "other"))
expected_types <- list(self = "Tensor", other = c("Tensor", "Scalar"))
nd_args <- c("self", "other")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'mul',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_mul_out <- function(out, self, other) {
  args <- rlang::env_get_list(nms = c("out", "self", "other"))
expected_types <- list(out = "Tensor", self = "Tensor", other = "Tensor")
nd_args <- c("out", "self", "other")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'mul_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_multi_margin_loss <- function(self, target, p = 1, margin = 1, weight = list(), reduction = torch_reduction_mean()) {
  args <- rlang::env_get_list(nms = c("self", "target", "p", "margin", "weight", "reduction"))
expected_types <- list(self = "Tensor", target = "Tensor", p = "Scalar", margin = "Scalar", 
    weight = "Tensor", reduction = "int64_t")
nd_args <- c("self", "target")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'multi_margin_loss',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_multi_margin_loss_backward <- function(grad_output, self, target, p, margin, weight = list(), reduction = torch_reduction_mean()) {
  args <- rlang::env_get_list(nms = c("grad_output", "self", "target", "p", "margin", "weight", "reduction"))
expected_types <- list(grad_output = "Tensor", self = "Tensor", target = "Tensor", 
    p = "Scalar", margin = "Scalar", weight = "Tensor", reduction = "int64_t")
nd_args <- c("grad_output", "self", "target", "p", "margin")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'multi_margin_loss_backward',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_multi_margin_loss_backward_out <- function(grad_input, grad_output, self, target, p, margin, weight = list(), reduction = torch_reduction_mean()) {
  args <- rlang::env_get_list(nms = c("grad_input", "grad_output", "self", "target", "p", "margin", "weight", "reduction"))
expected_types <- list(grad_input = "Tensor", grad_output = "Tensor", self = "Tensor", 
    target = "Tensor", p = "Scalar", margin = "Scalar", weight = "Tensor", 
    reduction = "int64_t")
nd_args <- c("grad_input", "grad_output", "self", "target", "p", "margin"
)
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'multi_margin_loss_backward_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_multi_margin_loss_out <- function(out, self, target, p = 1, margin = 1, weight = list(), reduction = torch_reduction_mean()) {
  args <- rlang::env_get_list(nms = c("out", "self", "target", "p", "margin", "weight", "reduction"))
expected_types <- list(out = "Tensor", self = "Tensor", target = "Tensor", p = "Scalar", 
    margin = "Scalar", weight = "Tensor", reduction = "int64_t")
nd_args <- c("out", "self", "target")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'multi_margin_loss_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_multilabel_margin_loss <- function(self, target, reduction = torch_reduction_mean()) {
  args <- rlang::env_get_list(nms = c("self", "target", "reduction"))
expected_types <- list(self = "Tensor", target = "Tensor", reduction = "int64_t")
nd_args <- c("self", "target")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'multilabel_margin_loss',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_multilabel_margin_loss_backward <- function(grad_output, self, target, reduction, is_target) {
  args <- rlang::env_get_list(nms = c("grad_output", "self", "target", "reduction", "is_target"))
expected_types <- list(grad_output = "Tensor", self = "Tensor", target = "Tensor", 
    reduction = "int64_t", is_target = "Tensor")
nd_args <- c("grad_output", "self", "target", "reduction", "is_target")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'multilabel_margin_loss_backward',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_multilabel_margin_loss_backward_out <- function(grad_input, grad_output, self, target, reduction, is_target) {
  args <- rlang::env_get_list(nms = c("grad_input", "grad_output", "self", "target", "reduction", "is_target"))
expected_types <- list(grad_input = "Tensor", grad_output = "Tensor", self = "Tensor", 
    target = "Tensor", reduction = "int64_t", is_target = "Tensor")
nd_args <- c("grad_input", "grad_output", "self", "target", "reduction", 
"is_target")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'multilabel_margin_loss_backward_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_multilabel_margin_loss_forward <- function(self, target, reduction) {
  args <- rlang::env_get_list(nms = c("self", "target", "reduction"))
expected_types <- list(self = "Tensor", target = "Tensor", reduction = "int64_t")
nd_args <- c("self", "target", "reduction")
return_types <- list(list("Tensor", "Tensor"))
call_c_function(
fun_name = 'multilabel_margin_loss_forward',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_multilabel_margin_loss_forward_out <- function(output, is_target, self, target, reduction) {
  args <- rlang::env_get_list(nms = c("output", "is_target", "self", "target", "reduction"))
expected_types <- list(output = "Tensor", is_target = "Tensor", self = "Tensor", 
    target = "Tensor", reduction = "int64_t")
nd_args <- c("output", "is_target", "self", "target", "reduction")
return_types <- list(list("Tensor", "Tensor"))
call_c_function(
fun_name = 'multilabel_margin_loss_forward_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_multilabel_margin_loss_out <- function(out, self, target, reduction = torch_reduction_mean()) {
  args <- rlang::env_get_list(nms = c("out", "self", "target", "reduction"))
expected_types <- list(out = "Tensor", self = "Tensor", target = "Tensor", reduction = "int64_t")
nd_args <- c("out", "self", "target")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'multilabel_margin_loss_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_multinomial <- function(self, num_samples, replacement = FALSE, generator = NULL) {
  args <- rlang::env_get_list(nms = c("self", "num_samples", "replacement", "generator"))
expected_types <- list(self = "Tensor", num_samples = "int64_t", replacement = "bool", 
    generator = "Generator *")
nd_args <- c("self", "num_samples")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'multinomial',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_multinomial_out <- function(out, self, num_samples, replacement = FALSE, generator = NULL) {
  args <- rlang::env_get_list(nms = c("out", "self", "num_samples", "replacement", "generator"))
expected_types <- list(out = "Tensor", self = "Tensor", num_samples = "int64_t", 
    replacement = "bool", generator = "Generator *")
nd_args <- c("out", "self", "num_samples")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'multinomial_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_mv <- function(self, vec) {
  args <- rlang::env_get_list(nms = c("self", "vec"))
expected_types <- list(self = "Tensor", vec = "Tensor")
nd_args <- c("self", "vec")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'mv',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_mv_out <- function(out, self, vec) {
  args <- rlang::env_get_list(nms = c("out", "self", "vec"))
expected_types <- list(out = "Tensor", self = "Tensor", vec = "Tensor")
nd_args <- c("out", "self", "vec")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'mv_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_mvlgamma <- function(self, p) {
  args <- rlang::env_get_list(nms = c("self", "p"))
expected_types <- list(self = "Tensor", p = "int64_t")
nd_args <- c("self", "p")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'mvlgamma',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_narrow <- function(self, dim, start, length) {
  args <- rlang::env_get_list(nms = c("self", "dim", "start", "length"))
expected_types <- list(self = "Tensor", dim = "int64_t", start = c("int64_t", "Tensor"
), length = "int64_t")
nd_args <- c("self", "dim", "start", "length")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'narrow',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_native_batch_norm <- function(input, weight, bias, running_mean, running_var, training, momentum, eps) {
  args <- rlang::env_get_list(nms = c("input", "weight", "bias", "running_mean", "running_var", "training", "momentum", "eps"))
expected_types <- list(input = "Tensor", weight = "Tensor", bias = "Tensor", running_mean = "Tensor", 
    running_var = "Tensor", training = "bool", momentum = "double", 
    eps = "double")
nd_args <- c("input", "weight", "bias", "running_mean", "running_var", "training", 
"momentum", "eps")
return_types <- list(list("Tensor", "Tensor", "Tensor"))
call_c_function(
fun_name = 'native_batch_norm',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_native_batch_norm_backward <- function(grad_out, input, weight, running_mean, running_var, save_mean, save_invstd, train, eps, output_mask) {
  args <- rlang::env_get_list(nms = c("grad_out", "input", "weight", "running_mean", "running_var", "save_mean", "save_invstd", "train", "eps", "output_mask"))
expected_types <- list(grad_out = "Tensor", input = "Tensor", weight = "Tensor", 
    running_mean = "Tensor", running_var = "Tensor", save_mean = "Tensor", 
    save_invstd = "Tensor", train = "bool", eps = "double", output_mask = "std::array<bool,3>")
nd_args <- c("grad_out", "input", "weight", "running_mean", "running_var", 
"save_mean", "save_invstd", "train", "eps", "output_mask")
return_types <- list(list("Tensor", "Tensor", "Tensor"))
call_c_function(
fun_name = 'native_batch_norm_backward',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_native_batch_norm_out <- function(out, save_mean, save_invstd, input, weight, bias, running_mean, running_var, training, momentum, eps) {
  args <- rlang::env_get_list(nms = c("out", "save_mean", "save_invstd", "input", "weight", "bias", "running_mean", "running_var", "training", "momentum", "eps"))
expected_types <- list(out = "Tensor", save_mean = "Tensor", save_invstd = "Tensor", 
    input = "Tensor", weight = "Tensor", bias = "Tensor", running_mean = "Tensor", 
    running_var = "Tensor", training = "bool", momentum = "double", 
    eps = "double")
nd_args <- c("out", "save_mean", "save_invstd", "input", "weight", "bias", 
"running_mean", "running_var", "training", "momentum", "eps")
return_types <- list(list("Tensor", "Tensor", "Tensor"))
call_c_function(
fun_name = 'native_batch_norm_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_native_layer_norm <- function(input, weight, bias, M, False, eps) {
  args <- rlang::env_get_list(nms = c("input", "weight", "bias", "M", "False", "eps"))
expected_types <- list(input = "Tensor", weight = "Tensor", bias = "Tensor", M = "int64_t", 
    False = "int64_t", eps = "double")
nd_args <- c("input", "weight", "bias", "M", "False", "eps")
return_types <- list(list("Tensor", "Tensor", "Tensor"))
call_c_function(
fun_name = 'native_layer_norm',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_native_layer_norm_backward <- function(grad_out, input, mean, rstd, weight, M, False, output_mask) {
  args <- rlang::env_get_list(nms = c("grad_out", "input", "mean", "rstd", "weight", "M", "False", "output_mask"))
expected_types <- list(grad_out = "Tensor", input = "Tensor", mean = "Tensor", 
    rstd = "Tensor", weight = "Tensor", M = "int64_t", False = "int64_t", 
    output_mask = "std::array<bool,3>")
nd_args <- c("grad_out", "input", "mean", "rstd", "weight", "M", "False", 
"output_mask")
return_types <- list(list("Tensor", "Tensor", "Tensor"))
call_c_function(
fun_name = 'native_layer_norm_backward',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_native_norm <- function(self, p = 2) {
  args <- rlang::env_get_list(nms = c("self", "p"))
expected_types <- list(self = "Tensor", p = "Scalar")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'native_norm',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_ne <- function(self, other) {
  args <- rlang::env_get_list(nms = c("self", "other"))
expected_types <- list(self = "Tensor", other = c("Scalar", "Tensor"))
nd_args <- c("self", "other")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'ne',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_ne_out <- function(out, self, other) {
  args <- rlang::env_get_list(nms = c("out", "self", "other"))
expected_types <- list(out = "Tensor", self = "Tensor", other = c("Scalar", "Tensor"
))
nd_args <- c("out", "self", "other")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'ne_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_neg <- function(self) {
  args <- rlang::env_get_list(nms = c("self"))
expected_types <- list(self = "Tensor")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'neg',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_neg_ <- function(self) {
  args <- rlang::env_get_list(nms = c("self"))
expected_types <- list(self = "Tensor")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'neg_',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_neg_out <- function(out, self) {
  args <- rlang::env_get_list(nms = c("out", "self"))
expected_types <- list(out = "Tensor", self = "Tensor")
nd_args <- c("out", "self")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'neg_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_nll_loss <- function(self, target, weight = list(), reduction = torch_reduction_mean(), ignore_index = -100) {
  args <- rlang::env_get_list(nms = c("self", "target", "weight", "reduction", "ignore_index"))
expected_types <- list(self = "Tensor", target = "Tensor", weight = "Tensor", reduction = "int64_t", 
    ignore_index = "int64_t")
nd_args <- c("self", "target")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'nll_loss',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_nll_loss_backward <- function(grad_output, self, target, weight, reduction, ignore_index, total_weight) {
  args <- rlang::env_get_list(nms = c("grad_output", "self", "target", "weight", "reduction", "ignore_index", "total_weight"))
expected_types <- list(grad_output = "Tensor", self = "Tensor", target = "Tensor", 
    weight = "Tensor", reduction = "int64_t", ignore_index = "int64_t", 
    total_weight = "Tensor")
nd_args <- c("grad_output", "self", "target", "weight", "reduction", "ignore_index", 
"total_weight")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'nll_loss_backward',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_nll_loss_backward_out <- function(grad_input, grad_output, self, target, weight, reduction, ignore_index, total_weight) {
  args <- rlang::env_get_list(nms = c("grad_input", "grad_output", "self", "target", "weight", "reduction", "ignore_index", "total_weight"))
expected_types <- list(grad_input = "Tensor", grad_output = "Tensor", self = "Tensor", 
    target = "Tensor", weight = "Tensor", reduction = "int64_t", 
    ignore_index = "int64_t", total_weight = "Tensor")
nd_args <- c("grad_input", "grad_output", "self", "target", "weight", "reduction", 
"ignore_index", "total_weight")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'nll_loss_backward_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_nll_loss_forward <- function(self, target, weight, reduction, ignore_index) {
  args <- rlang::env_get_list(nms = c("self", "target", "weight", "reduction", "ignore_index"))
expected_types <- list(self = "Tensor", target = "Tensor", weight = "Tensor", reduction = "int64_t", 
    ignore_index = "int64_t")
nd_args <- c("self", "target", "weight", "reduction", "ignore_index")
return_types <- list(list("Tensor", "Tensor"))
call_c_function(
fun_name = 'nll_loss_forward',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_nll_loss_forward_out <- function(output, total_weight, self, target, weight, reduction, ignore_index) {
  args <- rlang::env_get_list(nms = c("output", "total_weight", "self", "target", "weight", "reduction", "ignore_index"))
expected_types <- list(output = "Tensor", total_weight = "Tensor", self = "Tensor", 
    target = "Tensor", weight = "Tensor", reduction = "int64_t", 
    ignore_index = "int64_t")
nd_args <- c("output", "total_weight", "self", "target", "weight", "reduction", 
"ignore_index")
return_types <- list(list("Tensor", "Tensor"))
call_c_function(
fun_name = 'nll_loss_forward_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_nll_loss_out <- function(out, self, target, weight = list(), reduction = torch_reduction_mean(), ignore_index = -100) {
  args <- rlang::env_get_list(nms = c("out", "self", "target", "weight", "reduction", "ignore_index"))
expected_types <- list(out = "Tensor", self = "Tensor", target = "Tensor", weight = "Tensor", 
    reduction = "int64_t", ignore_index = "int64_t")
nd_args <- c("out", "self", "target")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'nll_loss_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_nll_loss2d <- function(self, target, weight = list(), reduction = torch_reduction_mean(), ignore_index = -100) {
  args <- rlang::env_get_list(nms = c("self", "target", "weight", "reduction", "ignore_index"))
expected_types <- list(self = "Tensor", target = "Tensor", weight = "Tensor", reduction = "int64_t", 
    ignore_index = "int64_t")
nd_args <- c("self", "target")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'nll_loss2d',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_nll_loss2d_backward <- function(grad_output, self, target, weight, reduction, ignore_index, total_weight) {
  args <- rlang::env_get_list(nms = c("grad_output", "self", "target", "weight", "reduction", "ignore_index", "total_weight"))
expected_types <- list(grad_output = "Tensor", self = "Tensor", target = "Tensor", 
    weight = "Tensor", reduction = "int64_t", ignore_index = "int64_t", 
    total_weight = "Tensor")
nd_args <- c("grad_output", "self", "target", "weight", "reduction", "ignore_index", 
"total_weight")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'nll_loss2d_backward',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_nll_loss2d_backward_out <- function(grad_input, grad_output, self, target, weight, reduction, ignore_index, total_weight) {
  args <- rlang::env_get_list(nms = c("grad_input", "grad_output", "self", "target", "weight", "reduction", "ignore_index", "total_weight"))
expected_types <- list(grad_input = "Tensor", grad_output = "Tensor", self = "Tensor", 
    target = "Tensor", weight = "Tensor", reduction = "int64_t", 
    ignore_index = "int64_t", total_weight = "Tensor")
nd_args <- c("grad_input", "grad_output", "self", "target", "weight", "reduction", 
"ignore_index", "total_weight")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'nll_loss2d_backward_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_nll_loss2d_forward <- function(self, target, weight, reduction, ignore_index) {
  args <- rlang::env_get_list(nms = c("self", "target", "weight", "reduction", "ignore_index"))
expected_types <- list(self = "Tensor", target = "Tensor", weight = "Tensor", reduction = "int64_t", 
    ignore_index = "int64_t")
nd_args <- c("self", "target", "weight", "reduction", "ignore_index")
return_types <- list(list("Tensor", "Tensor"))
call_c_function(
fun_name = 'nll_loss2d_forward',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_nll_loss2d_forward_out <- function(output, total_weight, self, target, weight, reduction, ignore_index) {
  args <- rlang::env_get_list(nms = c("output", "total_weight", "self", "target", "weight", "reduction", "ignore_index"))
expected_types <- list(output = "Tensor", total_weight = "Tensor", self = "Tensor", 
    target = "Tensor", weight = "Tensor", reduction = "int64_t", 
    ignore_index = "int64_t")
nd_args <- c("output", "total_weight", "self", "target", "weight", "reduction", 
"ignore_index")
return_types <- list(list("Tensor", "Tensor"))
call_c_function(
fun_name = 'nll_loss2d_forward_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_nll_loss2d_out <- function(out, self, target, weight = list(), reduction = torch_reduction_mean(), ignore_index = -100) {
  args <- rlang::env_get_list(nms = c("out", "self", "target", "weight", "reduction", "ignore_index"))
expected_types <- list(out = "Tensor", self = "Tensor", target = "Tensor", weight = "Tensor", 
    reduction = "int64_t", ignore_index = "int64_t")
nd_args <- c("out", "self", "target")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'nll_loss2d_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_nonzero <- function(self) {
  args <- rlang::env_get_list(nms = c("self"))
expected_types <- list(self = "Tensor")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'nonzero',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_nonzero_numpy <- function(self) {
  args <- rlang::env_get_list(nms = c("self"))
expected_types <- list(self = "Tensor")
nd_args <- "self"
return_types <- list(list('TensorList'))
call_c_function(
fun_name = 'nonzero_numpy',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_nonzero_out <- function(out, self) {
  args <- rlang::env_get_list(nms = c("out", "self"))
expected_types <- list(out = "Tensor", self = "Tensor")
nd_args <- c("out", "self")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'nonzero_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_norm <- function(self, p = 2, dim, keepdim = FALSE, dtype) {
  args <- rlang::env_get_list(nms = c("self", "p", "dim", "keepdim", "dtype"))
expected_types <- list(self = "Tensor", p = "Scalar", dim = c("IntArrayRef", "DimnameList"
), keepdim = "bool", dtype = "ScalarType")
nd_args <- c("self", "dim", "dtype")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'norm',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_norm_except_dim <- function(v, pow = 2, dim = 0) {
  args <- rlang::env_get_list(nms = c("v", "pow", "dim"))
expected_types <- list(v = "Tensor", pow = "int64_t", dim = "int64_t")
nd_args <- "v"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'norm_except_dim',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_norm_out <- function(out, self, p, dim, keepdim = FALSE, dtype) {
  args <- rlang::env_get_list(nms = c("out", "self", "p", "dim", "keepdim", "dtype"))
expected_types <- list(out = "Tensor", self = "Tensor", p = "Scalar", dim = c("IntArrayRef", 
"DimnameList"), keepdim = "bool", dtype = "ScalarType")
nd_args <- c("out", "self", "p", "dim", "dtype")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'norm_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_normal <- function(mean, std = 1, size, generator = NULL, options = list()) {
  args <- rlang::env_get_list(nms = c("mean", "std", "size", "generator", "options"))
expected_types <- list(mean = c("Tensor", "double"), std = c("double", "Tensor"
), size = "IntArrayRef", generator = "Generator *", options = "TensorOptions")
nd_args <- c("mean", "size")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'normal',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_normal_out <- function(out, mean, std = 1, size, generator = NULL) {
  args <- rlang::env_get_list(nms = c("out", "mean", "std", "size", "generator"))
expected_types <- list(out = "Tensor", mean = c("Tensor", "double"), std = c("double", 
"Tensor"), size = "IntArrayRef", generator = "Generator *")
nd_args <- c("out", "mean", "size")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'normal_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_nuclear_norm <- function(self, dim, keepdim = FALSE) {
  args <- rlang::env_get_list(nms = c("self", "dim", "keepdim"))
expected_types <- list(self = "Tensor", dim = "IntArrayRef", keepdim = "bool")
nd_args <- c("self", "dim")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'nuclear_norm',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_nuclear_norm_out <- function(out, self, dim, keepdim = FALSE) {
  args <- rlang::env_get_list(nms = c("out", "self", "dim", "keepdim"))
expected_types <- list(out = "Tensor", self = "Tensor", dim = "IntArrayRef", keepdim = "bool")
nd_args <- c("out", "self", "dim")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'nuclear_norm_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_one_hot <- function(self, num_classes = -1) {
  args <- rlang::env_get_list(nms = c("self", "num_classes"))
expected_types <- list(self = "Tensor", num_classes = "int64_t")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'one_hot',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


.torch_ones <- function(size, names, options = list()) {
  args <- rlang::env_get_list(nms = c("size", "names", "options"))
expected_types <- list(size = "IntArrayRef", names = "DimnameList", options = "TensorOptions")
nd_args <- c("size", "names")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'ones',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


.torch_ones_like <- function(self, options = list(), memory_format = NULL) {
  args <- rlang::env_get_list(nms = c("self", "options", "memory_format"))
expected_types <- list(self = "Tensor", options = "TensorOptions", memory_format = "MemoryFormat")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'ones_like',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_ones_out <- function(out, size) {
  args <- rlang::env_get_list(nms = c("out", "size"))
expected_types <- list(out = "Tensor", size = "IntArrayRef")
nd_args <- c("out", "size")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'ones_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_orgqr <- function(self, input2) {
  args <- rlang::env_get_list(nms = c("self", "input2"))
expected_types <- list(self = "Tensor", input2 = "Tensor")
nd_args <- c("self", "input2")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'orgqr',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_orgqr_out <- function(out, self, input2) {
  args <- rlang::env_get_list(nms = c("out", "self", "input2"))
expected_types <- list(out = "Tensor", self = "Tensor", input2 = "Tensor")
nd_args <- c("out", "self", "input2")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'orgqr_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_ormqr <- function(self, input2, input3, left = TRUE, transpose = FALSE) {
  args <- rlang::env_get_list(nms = c("self", "input2", "input3", "left", "transpose"))
expected_types <- list(self = "Tensor", input2 = "Tensor", input3 = "Tensor", left = "bool", 
    transpose = "bool")
nd_args <- c("self", "input2", "input3")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'ormqr',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_ormqr_out <- function(out, self, input2, input3, left = TRUE, transpose = FALSE) {
  args <- rlang::env_get_list(nms = c("out", "self", "input2", "input3", "left", "transpose"))
expected_types <- list(out = "Tensor", self = "Tensor", input2 = "Tensor", input3 = "Tensor", 
    left = "bool", transpose = "bool")
nd_args <- c("out", "self", "input2", "input3")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'ormqr_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_pairwise_distance <- function(x1, x2, p = 2, eps = 0.000001, keepdim = FALSE) {
  args <- rlang::env_get_list(nms = c("x1", "x2", "p", "eps", "keepdim"))
expected_types <- list(x1 = "Tensor", x2 = "Tensor", p = "double", eps = "double", 
    keepdim = "bool")
nd_args <- c("x1", "x2")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'pairwise_distance',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_pdist <- function(self, p = 2) {
  args <- rlang::env_get_list(nms = c("self", "p"))
expected_types <- list(self = "Tensor", p = "double")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'pdist',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_pinverse <- function(self, rcond = 0.000000) {
  args <- rlang::env_get_list(nms = c("self", "rcond"))
expected_types <- list(self = "Tensor", rcond = "double")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'pinverse',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_pixel_shuffle <- function(self, upscale_factor) {
  args <- rlang::env_get_list(nms = c("self", "upscale_factor"))
expected_types <- list(self = "Tensor", upscale_factor = "int64_t")
nd_args <- c("self", "upscale_factor")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'pixel_shuffle',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_poisson <- function(self, generator = NULL) {
  args <- rlang::env_get_list(nms = c("self", "generator"))
expected_types <- list(self = "Tensor", generator = "Generator *")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'poisson',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_poisson_nll_loss <- function(input, target, log_input, full, eps, reduction) {
  args <- rlang::env_get_list(nms = c("input", "target", "log_input", "full", "eps", "reduction"))
expected_types <- list(input = "Tensor", target = "Tensor", log_input = "bool", 
    full = "bool", eps = "double", reduction = "int64_t")
nd_args <- c("input", "target", "log_input", "full", "eps", "reduction")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'poisson_nll_loss',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_polygamma <- function(n, self) {
  args <- rlang::env_get_list(nms = c("n", "self"))
expected_types <- list(n = "int64_t", self = "Tensor")
nd_args <- c("n", "self")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'polygamma',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_polygamma_out <- function(out, n, self) {
  args <- rlang::env_get_list(nms = c("out", "n", "self"))
expected_types <- list(out = "Tensor", n = "int64_t", self = "Tensor")
nd_args <- c("out", "n", "self")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'polygamma_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_pow <- function(self, exponent) {
  args <- rlang::env_get_list(nms = c("self", "exponent"))
expected_types <- list(self = c("Tensor", "Scalar"), exponent = c("Scalar", "Tensor"
))
nd_args <- c("self", "exponent")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'pow',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_pow_out <- function(out, self, exponent) {
  args <- rlang::env_get_list(nms = c("out", "self", "exponent"))
expected_types <- list(out = "Tensor", self = c("Tensor", "Scalar"), exponent = c("Scalar", 
"Tensor"))
nd_args <- c("out", "self", "exponent")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'pow_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_prelu <- function(self, weight) {
  args <- rlang::env_get_list(nms = c("self", "weight"))
expected_types <- list(self = "Tensor", weight = "Tensor")
nd_args <- c("self", "weight")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'prelu',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_prelu_backward <- function(grad_output, self, weight) {
  args <- rlang::env_get_list(nms = c("grad_output", "self", "weight"))
expected_types <- list(grad_output = "Tensor", self = "Tensor", weight = "Tensor")
nd_args <- c("grad_output", "self", "weight")
return_types <- list(list("Tensor", "Tensor"))
call_c_function(
fun_name = 'prelu_backward',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_prod <- function(self, dim, keepdim = FALSE, dtype = NULL) {
  args <- rlang::env_get_list(nms = c("self", "dim", "keepdim", "dtype"))
expected_types <- list(self = "Tensor", dim = c("int64_t", "Dimname"), keepdim = "bool", 
    dtype = "ScalarType")
nd_args <- c("self", "dim")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'prod',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_prod_out <- function(out, self, dim, keepdim = FALSE, dtype = NULL) {
  args <- rlang::env_get_list(nms = c("out", "self", "dim", "keepdim", "dtype"))
expected_types <- list(out = "Tensor", self = "Tensor", dim = c("int64_t", "Dimname"
), keepdim = "bool", dtype = "ScalarType")
nd_args <- c("out", "self", "dim")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'prod_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_promote_types <- function(type1, type2) {
  args <- rlang::env_get_list(nms = c("type1", "type2"))
expected_types <- list(type1 = "ScalarType", type2 = "ScalarType")
nd_args <- c("type1", "type2")
return_types <- list(list('ScalarType'))
call_c_function(
fun_name = 'promote_types',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_q_per_channel_axis <- function(self) {
  args <- rlang::env_get_list(nms = c("self"))
expected_types <- list(self = "Tensor")
nd_args <- "self"
return_types <- list(list('int64_t'))
call_c_function(
fun_name = 'q_per_channel_axis',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_q_per_channel_scales <- function(self) {
  args <- rlang::env_get_list(nms = c("self"))
expected_types <- list(self = "Tensor")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'q_per_channel_scales',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_q_per_channel_zero_points <- function(self) {
  args <- rlang::env_get_list(nms = c("self"))
expected_types <- list(self = "Tensor")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'q_per_channel_zero_points',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_q_scale <- function(self) {
  args <- rlang::env_get_list(nms = c("self"))
expected_types <- list(self = "Tensor")
nd_args <- "self"
return_types <- list(list('double'))
call_c_function(
fun_name = 'q_scale',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_q_zero_point <- function(self) {
  args <- rlang::env_get_list(nms = c("self"))
expected_types <- list(self = "Tensor")
nd_args <- "self"
return_types <- list(list('int64_t'))
call_c_function(
fun_name = 'q_zero_point',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_qr <- function(self, some = TRUE) {
  args <- rlang::env_get_list(nms = c("self", "some"))
expected_types <- list(self = "Tensor", some = "bool")
nd_args <- "self"
return_types <- list(list("Tensor", "Tensor"))
call_c_function(
fun_name = 'qr',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_qr_out <- function(Q, R, self, some = TRUE) {
  args <- rlang::env_get_list(nms = c("Q", "R", "self", "some"))
expected_types <- list(Q = "Tensor", R = "Tensor", self = "Tensor", some = "bool")
nd_args <- c("Q", "R", "self")
return_types <- list(list("Tensor", "Tensor"))
call_c_function(
fun_name = 'qr_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_quantize_per_channel <- function(self, scales, zero_points, axis, dtype) {
  args <- rlang::env_get_list(nms = c("self", "scales", "zero_points", "axis", "dtype"))
expected_types <- list(self = "Tensor", scales = "Tensor", zero_points = "Tensor", 
    axis = "int64_t", dtype = "ScalarType")
nd_args <- c("self", "scales", "zero_points", "axis", "dtype")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'quantize_per_channel',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_quantize_per_tensor <- function(self, scale, zero_point, dtype) {
  args <- rlang::env_get_list(nms = c("self", "scale", "zero_point", "dtype"))
expected_types <- list(self = "Tensor", scale = "double", zero_point = "int64_t", 
    dtype = "ScalarType")
nd_args <- c("self", "scale", "zero_point", "dtype")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'quantize_per_tensor',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_quantized_batch_norm <- function(input, weight, bias, mean, var, eps, output_scale, output_zero_point) {
  args <- rlang::env_get_list(nms = c("input", "weight", "bias", "mean", "var", "eps", "output_scale", "output_zero_point"))
expected_types <- list(input = "Tensor", weight = "Tensor", bias = "Tensor", mean = "Tensor", 
    var = "Tensor", eps = "double", output_scale = "double", 
    output_zero_point = "int64_t")
nd_args <- c("input", "weight", "bias", "mean", "var", "eps", "output_scale", 
"output_zero_point")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'quantized_batch_norm',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_quantized_gru <- function(data, input, batch_sizes, hx, params, has_biases, num_layers, dropout, train, batch_first, bidirectional) {
  args <- rlang::env_get_list(nms = c("data", "input", "batch_sizes", "hx", "params", "has_biases", "num_layers", "dropout", "train", "batch_first", "bidirectional"))
expected_types <- list(data = "Tensor", input = "Tensor", batch_sizes = "Tensor", 
    hx = "Tensor", params = "TensorList", has_biases = "bool", 
    num_layers = "int64_t", dropout = "double", train = "bool", 
    batch_first = "bool", bidirectional = "bool")
nd_args <- c("data", "input", "batch_sizes", "hx", "params", "has_biases", 
"num_layers", "dropout", "train", "batch_first", "bidirectional"
)
return_types <- list(list("Tensor", "Tensor"))
call_c_function(
fun_name = 'quantized_gru',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_quantized_gru_cell <- function(input, hx, w_ih, w_hh, b_ih, b_hh, packed_ih, packed_hh, col_offsets_ih, col_offsets_hh, scale_ih, scale_hh, zero_point_ih, zero_point_hh) {
  args <- rlang::env_get_list(nms = c("input", "hx", "w_ih", "w_hh", "b_ih", "b_hh", "packed_ih", "packed_hh", "col_offsets_ih", "col_offsets_hh", "scale_ih", "scale_hh", "zero_point_ih", "zero_point_hh"))
expected_types <- list(input = "Tensor", hx = "Tensor", w_ih = "Tensor", w_hh = "Tensor", 
    b_ih = "Tensor", b_hh = "Tensor", packed_ih = "Tensor", packed_hh = "Tensor", 
    col_offsets_ih = "Tensor", col_offsets_hh = "Tensor", scale_ih = "Scalar", 
    scale_hh = "Scalar", zero_point_ih = "Scalar", zero_point_hh = "Scalar")
nd_args <- c("input", "hx", "w_ih", "w_hh", "b_ih", "b_hh", "packed_ih", 
"packed_hh", "col_offsets_ih", "col_offsets_hh", "scale_ih", 
"scale_hh", "zero_point_ih", "zero_point_hh")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'quantized_gru_cell',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_quantized_lstm <- function(data, input, batch_sizes, hx, params, has_biases, num_layers, dropout, train, batch_first, bidirectional, dtype = NULL, use_dynamic = FALSE) {
  args <- rlang::env_get_list(nms = c("data", "input", "batch_sizes", "hx", "params", "has_biases", "num_layers", "dropout", "train", "batch_first", "bidirectional", "dtype", "use_dynamic"))
expected_types <- list(data = "Tensor", input = "Tensor", batch_sizes = "Tensor", 
    hx = "TensorList", params = "TensorList", has_biases = "bool", 
    num_layers = "int64_t", dropout = "double", train = "bool", 
    batch_first = "bool", bidirectional = "bool", dtype = "ScalarType", 
    use_dynamic = "bool")
nd_args <- c("data", "input", "batch_sizes", "hx", "params", "has_biases", 
"num_layers", "dropout", "train", "batch_first", "bidirectional"
)
return_types <- list(list("Tensor", "Tensor", "Tensor"))
call_c_function(
fun_name = 'quantized_lstm',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_quantized_lstm_cell <- function(input, hx, w_ih, w_hh, b_ih, b_hh, packed_ih, packed_hh, col_offsets_ih, col_offsets_hh, scale_ih, scale_hh, zero_point_ih, zero_point_hh) {
  args <- rlang::env_get_list(nms = c("input", "hx", "w_ih", "w_hh", "b_ih", "b_hh", "packed_ih", "packed_hh", "col_offsets_ih", "col_offsets_hh", "scale_ih", "scale_hh", "zero_point_ih", "zero_point_hh"))
expected_types <- list(input = "Tensor", hx = "TensorList", w_ih = "Tensor", w_hh = "Tensor", 
    b_ih = "Tensor", b_hh = "Tensor", packed_ih = "Tensor", packed_hh = "Tensor", 
    col_offsets_ih = "Tensor", col_offsets_hh = "Tensor", scale_ih = "Scalar", 
    scale_hh = "Scalar", zero_point_ih = "Scalar", zero_point_hh = "Scalar")
nd_args <- c("input", "hx", "w_ih", "w_hh", "b_ih", "b_hh", "packed_ih", 
"packed_hh", "col_offsets_ih", "col_offsets_hh", "scale_ih", 
"scale_hh", "zero_point_ih", "zero_point_hh")
return_types <- list(list("Tensor", "Tensor"))
call_c_function(
fun_name = 'quantized_lstm_cell',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_quantized_max_pool2d <- function(self, kernel_size, stride = list(), padding = 0, dilation = 1, ceil_mode = FALSE) {
  args <- rlang::env_get_list(nms = c("self", "kernel_size", "stride", "padding", "dilation", "ceil_mode"))
expected_types <- list(self = "Tensor", kernel_size = "IntArrayRef", stride = "IntArrayRef", 
    padding = "IntArrayRef", dilation = "IntArrayRef", ceil_mode = "bool")
nd_args <- c("self", "kernel_size")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'quantized_max_pool2d',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_quantized_rnn_relu_cell <- function(input, hx, w_ih, w_hh, b_ih, b_hh, packed_ih, packed_hh, col_offsets_ih, col_offsets_hh, scale_ih, scale_hh, zero_point_ih, zero_point_hh) {
  args <- rlang::env_get_list(nms = c("input", "hx", "w_ih", "w_hh", "b_ih", "b_hh", "packed_ih", "packed_hh", "col_offsets_ih", "col_offsets_hh", "scale_ih", "scale_hh", "zero_point_ih", "zero_point_hh"))
expected_types <- list(input = "Tensor", hx = "Tensor", w_ih = "Tensor", w_hh = "Tensor", 
    b_ih = "Tensor", b_hh = "Tensor", packed_ih = "Tensor", packed_hh = "Tensor", 
    col_offsets_ih = "Tensor", col_offsets_hh = "Tensor", scale_ih = "Scalar", 
    scale_hh = "Scalar", zero_point_ih = "Scalar", zero_point_hh = "Scalar")
nd_args <- c("input", "hx", "w_ih", "w_hh", "b_ih", "b_hh", "packed_ih", 
"packed_hh", "col_offsets_ih", "col_offsets_hh", "scale_ih", 
"scale_hh", "zero_point_ih", "zero_point_hh")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'quantized_rnn_relu_cell',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_quantized_rnn_tanh_cell <- function(input, hx, w_ih, w_hh, b_ih, b_hh, packed_ih, packed_hh, col_offsets_ih, col_offsets_hh, scale_ih, scale_hh, zero_point_ih, zero_point_hh) {
  args <- rlang::env_get_list(nms = c("input", "hx", "w_ih", "w_hh", "b_ih", "b_hh", "packed_ih", "packed_hh", "col_offsets_ih", "col_offsets_hh", "scale_ih", "scale_hh", "zero_point_ih", "zero_point_hh"))
expected_types <- list(input = "Tensor", hx = "Tensor", w_ih = "Tensor", w_hh = "Tensor", 
    b_ih = "Tensor", b_hh = "Tensor", packed_ih = "Tensor", packed_hh = "Tensor", 
    col_offsets_ih = "Tensor", col_offsets_hh = "Tensor", scale_ih = "Scalar", 
    scale_hh = "Scalar", zero_point_ih = "Scalar", zero_point_hh = "Scalar")
nd_args <- c("input", "hx", "w_ih", "w_hh", "b_ih", "b_hh", "packed_ih", 
"packed_hh", "col_offsets_ih", "col_offsets_hh", "scale_ih", 
"scale_hh", "zero_point_ih", "zero_point_hh")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'quantized_rnn_tanh_cell',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


.torch_rand <- function(size, generator, names, options = list()) {
  args <- rlang::env_get_list(nms = c("size", "generator", "names", "options"))
expected_types <- list(size = "IntArrayRef", generator = "Generator *", names = "DimnameList", 
    options = "TensorOptions")
nd_args <- c("size", "generator", "names")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'rand',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


.torch_rand_like <- function(self, options = list(), memory_format = NULL) {
  args <- rlang::env_get_list(nms = c("self", "options", "memory_format"))
expected_types <- list(self = "Tensor", options = "TensorOptions", memory_format = "MemoryFormat")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'rand_like',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_rand_out <- function(out, size, generator) {
  args <- rlang::env_get_list(nms = c("out", "size", "generator"))
expected_types <- list(out = "Tensor", size = "IntArrayRef", generator = "Generator *")
nd_args <- c("out", "size", "generator")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'rand_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


.torch_randint <- function(low, high, size, generator, options = list()) {
  args <- rlang::env_get_list(nms = c("low", "high", "size", "generator", "options"))
expected_types <- list(low = "int64_t", high = "int64_t", size = "IntArrayRef", 
    generator = "Generator *", options = "TensorOptions")
nd_args <- c("low", "high", "size", "generator")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'randint',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


.torch_randint_like <- function(self, low, high, options = list(), memory_format = NULL) {
  args <- rlang::env_get_list(nms = c("self", "low", "high", "options", "memory_format"))
expected_types <- list(self = "Tensor", low = "int64_t", high = "int64_t", options = "TensorOptions", 
    memory_format = "MemoryFormat")
nd_args <- c("self", "low", "high")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'randint_like',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_randint_out <- function(out, low, high, size, generator) {
  args <- rlang::env_get_list(nms = c("out", "low", "high", "size", "generator"))
expected_types <- list(out = "Tensor", low = "int64_t", high = "int64_t", size = "IntArrayRef", 
    generator = "Generator *")
nd_args <- c("out", "low", "high", "size", "generator")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'randint_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


.torch_randn <- function(size, generator, names, options = list()) {
  args <- rlang::env_get_list(nms = c("size", "generator", "names", "options"))
expected_types <- list(size = "IntArrayRef", generator = "Generator *", names = "DimnameList", 
    options = "TensorOptions")
nd_args <- c("size", "generator", "names")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'randn',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


.torch_randn_like <- function(self, options = list(), memory_format = NULL) {
  args <- rlang::env_get_list(nms = c("self", "options", "memory_format"))
expected_types <- list(self = "Tensor", options = "TensorOptions", memory_format = "MemoryFormat")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'randn_like',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_randn_out <- function(out, size, generator) {
  args <- rlang::env_get_list(nms = c("out", "size", "generator"))
expected_types <- list(out = "Tensor", size = "IntArrayRef", generator = "Generator *")
nd_args <- c("out", "size", "generator")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'randn_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


.torch_randperm <- function(n, generator, options = list()) {
  args <- rlang::env_get_list(nms = c("n", "generator", "options"))
expected_types <- list(n = "int64_t", generator = "Generator *", options = "TensorOptions")
nd_args <- c("n", "generator")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'randperm',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_randperm_out <- function(out, n, generator) {
  args <- rlang::env_get_list(nms = c("out", "n", "generator"))
expected_types <- list(out = "Tensor", n = "int64_t", generator = "Generator *")
nd_args <- c("out", "n", "generator")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'randperm_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


.torch_range <- function(start, end, step = 1, options = list()) {
  args <- rlang::env_get_list(nms = c("start", "end", "step", "options"))
expected_types <- list(start = "Scalar", end = "Scalar", step = "Scalar", options = "TensorOptions")
nd_args <- c("start", "end")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'range',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_range_out <- function(out, start, end, step = 1) {
  args <- rlang::env_get_list(nms = c("out", "start", "end", "step"))
expected_types <- list(out = "Tensor", start = "Scalar", end = "Scalar", step = "Scalar")
nd_args <- c("out", "start", "end")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'range_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_real <- function(self) {
  args <- rlang::env_get_list(nms = c("self"))
expected_types <- list(self = "Tensor")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'real',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_reciprocal <- function(self) {
  args <- rlang::env_get_list(nms = c("self"))
expected_types <- list(self = "Tensor")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'reciprocal',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_reciprocal_ <- function(self) {
  args <- rlang::env_get_list(nms = c("self"))
expected_types <- list(self = "Tensor")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'reciprocal_',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_reciprocal_out <- function(out, self) {
  args <- rlang::env_get_list(nms = c("out", "self"))
expected_types <- list(out = "Tensor", self = "Tensor")
nd_args <- c("out", "self")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'reciprocal_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_reflection_pad1d <- function(self, padding) {
  args <- rlang::env_get_list(nms = c("self", "padding"))
expected_types <- list(self = "Tensor", padding = "IntArrayRef")
nd_args <- c("self", "padding")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'reflection_pad1d',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_reflection_pad1d_backward <- function(grad_output, self, padding) {
  args <- rlang::env_get_list(nms = c("grad_output", "self", "padding"))
expected_types <- list(grad_output = "Tensor", self = "Tensor", padding = "IntArrayRef")
nd_args <- c("grad_output", "self", "padding")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'reflection_pad1d_backward',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_reflection_pad1d_backward_out <- function(grad_input, grad_output, self, padding) {
  args <- rlang::env_get_list(nms = c("grad_input", "grad_output", "self", "padding"))
expected_types <- list(grad_input = "Tensor", grad_output = "Tensor", self = "Tensor", 
    padding = "IntArrayRef")
nd_args <- c("grad_input", "grad_output", "self", "padding")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'reflection_pad1d_backward_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_reflection_pad1d_out <- function(out, self, padding) {
  args <- rlang::env_get_list(nms = c("out", "self", "padding"))
expected_types <- list(out = "Tensor", self = "Tensor", padding = "IntArrayRef")
nd_args <- c("out", "self", "padding")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'reflection_pad1d_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_reflection_pad2d <- function(self, padding) {
  args <- rlang::env_get_list(nms = c("self", "padding"))
expected_types <- list(self = "Tensor", padding = "IntArrayRef")
nd_args <- c("self", "padding")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'reflection_pad2d',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_reflection_pad2d_backward <- function(grad_output, self, padding) {
  args <- rlang::env_get_list(nms = c("grad_output", "self", "padding"))
expected_types <- list(grad_output = "Tensor", self = "Tensor", padding = "IntArrayRef")
nd_args <- c("grad_output", "self", "padding")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'reflection_pad2d_backward',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_reflection_pad2d_backward_out <- function(grad_input, grad_output, self, padding) {
  args <- rlang::env_get_list(nms = c("grad_input", "grad_output", "self", "padding"))
expected_types <- list(grad_input = "Tensor", grad_output = "Tensor", self = "Tensor", 
    padding = "IntArrayRef")
nd_args <- c("grad_input", "grad_output", "self", "padding")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'reflection_pad2d_backward_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_reflection_pad2d_out <- function(out, self, padding) {
  args <- rlang::env_get_list(nms = c("out", "self", "padding"))
expected_types <- list(out = "Tensor", self = "Tensor", padding = "IntArrayRef")
nd_args <- c("out", "self", "padding")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'reflection_pad2d_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_relu <- function(self) {
  args <- rlang::env_get_list(nms = c("self"))
expected_types <- list(self = "Tensor")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'relu',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_relu_ <- function(self) {
  args <- rlang::env_get_list(nms = c("self"))
expected_types <- list(self = "Tensor")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'relu_',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_remainder <- function(self, other) {
  args <- rlang::env_get_list(nms = c("self", "other"))
expected_types <- list(self = "Tensor", other = c("Scalar", "Tensor"))
nd_args <- c("self", "other")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'remainder',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_remainder_out <- function(out, self, other) {
  args <- rlang::env_get_list(nms = c("out", "self", "other"))
expected_types <- list(out = "Tensor", self = "Tensor", other = c("Scalar", "Tensor"
))
nd_args <- c("out", "self", "other")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'remainder_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_renorm <- function(self, p, dim, maxnorm) {
  args <- rlang::env_get_list(nms = c("self", "p", "dim", "maxnorm"))
expected_types <- list(self = "Tensor", p = "Scalar", dim = "int64_t", maxnorm = "Scalar")
nd_args <- c("self", "p", "dim", "maxnorm")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'renorm',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_renorm_out <- function(out, self, p, dim, maxnorm) {
  args <- rlang::env_get_list(nms = c("out", "self", "p", "dim", "maxnorm"))
expected_types <- list(out = "Tensor", self = "Tensor", p = "Scalar", dim = "int64_t", 
    maxnorm = "Scalar")
nd_args <- c("out", "self", "p", "dim", "maxnorm")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'renorm_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_repeat_interleave <- function(self, repeats, dim = NULL) {
  args <- rlang::env_get_list(nms = c("self", "repeats", "dim"))
expected_types <- list(self = "Tensor", repeats = c("Tensor", "int64_t"), dim = "int64_t")
nd_args <- c("self", "repeats")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'repeat_interleave',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_replication_pad1d <- function(self, padding) {
  args <- rlang::env_get_list(nms = c("self", "padding"))
expected_types <- list(self = "Tensor", padding = "IntArrayRef")
nd_args <- c("self", "padding")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'replication_pad1d',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_replication_pad1d_backward <- function(grad_output, self, padding) {
  args <- rlang::env_get_list(nms = c("grad_output", "self", "padding"))
expected_types <- list(grad_output = "Tensor", self = "Tensor", padding = "IntArrayRef")
nd_args <- c("grad_output", "self", "padding")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'replication_pad1d_backward',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_replication_pad1d_backward_out <- function(grad_input, grad_output, self, padding) {
  args <- rlang::env_get_list(nms = c("grad_input", "grad_output", "self", "padding"))
expected_types <- list(grad_input = "Tensor", grad_output = "Tensor", self = "Tensor", 
    padding = "IntArrayRef")
nd_args <- c("grad_input", "grad_output", "self", "padding")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'replication_pad1d_backward_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_replication_pad1d_out <- function(out, self, padding) {
  args <- rlang::env_get_list(nms = c("out", "self", "padding"))
expected_types <- list(out = "Tensor", self = "Tensor", padding = "IntArrayRef")
nd_args <- c("out", "self", "padding")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'replication_pad1d_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_replication_pad2d <- function(self, padding) {
  args <- rlang::env_get_list(nms = c("self", "padding"))
expected_types <- list(self = "Tensor", padding = "IntArrayRef")
nd_args <- c("self", "padding")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'replication_pad2d',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_replication_pad2d_backward <- function(grad_output, self, padding) {
  args <- rlang::env_get_list(nms = c("grad_output", "self", "padding"))
expected_types <- list(grad_output = "Tensor", self = "Tensor", padding = "IntArrayRef")
nd_args <- c("grad_output", "self", "padding")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'replication_pad2d_backward',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_replication_pad2d_backward_out <- function(grad_input, grad_output, self, padding) {
  args <- rlang::env_get_list(nms = c("grad_input", "grad_output", "self", "padding"))
expected_types <- list(grad_input = "Tensor", grad_output = "Tensor", self = "Tensor", 
    padding = "IntArrayRef")
nd_args <- c("grad_input", "grad_output", "self", "padding")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'replication_pad2d_backward_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_replication_pad2d_out <- function(out, self, padding) {
  args <- rlang::env_get_list(nms = c("out", "self", "padding"))
expected_types <- list(out = "Tensor", self = "Tensor", padding = "IntArrayRef")
nd_args <- c("out", "self", "padding")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'replication_pad2d_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_replication_pad3d <- function(self, padding) {
  args <- rlang::env_get_list(nms = c("self", "padding"))
expected_types <- list(self = "Tensor", padding = "IntArrayRef")
nd_args <- c("self", "padding")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'replication_pad3d',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_replication_pad3d_backward <- function(grad_output, self, padding) {
  args <- rlang::env_get_list(nms = c("grad_output", "self", "padding"))
expected_types <- list(grad_output = "Tensor", self = "Tensor", padding = "IntArrayRef")
nd_args <- c("grad_output", "self", "padding")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'replication_pad3d_backward',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_replication_pad3d_backward_out <- function(grad_input, grad_output, self, padding) {
  args <- rlang::env_get_list(nms = c("grad_input", "grad_output", "self", "padding"))
expected_types <- list(grad_input = "Tensor", grad_output = "Tensor", self = "Tensor", 
    padding = "IntArrayRef")
nd_args <- c("grad_input", "grad_output", "self", "padding")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'replication_pad3d_backward_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_replication_pad3d_out <- function(out, self, padding) {
  args <- rlang::env_get_list(nms = c("out", "self", "padding"))
expected_types <- list(out = "Tensor", self = "Tensor", padding = "IntArrayRef")
nd_args <- c("out", "self", "padding")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'replication_pad3d_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_reshape <- function(self, shape) {
  args <- rlang::env_get_list(nms = c("self", "shape"))
expected_types <- list(self = "Tensor", shape = "IntArrayRef")
nd_args <- c("self", "shape")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'reshape',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_resize_as_ <- function(self, the_template, memory_format = NULL) {
  args <- rlang::env_get_list(nms = c("self", "the_template", "memory_format"))
expected_types <- list(self = "Tensor", the_template = "Tensor", memory_format = "MemoryFormat")
nd_args <- c("self", "the_template")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'resize_as_',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_result_type <- function(scalar, scalar1, other, scalar2, tensor) {
  args <- rlang::env_get_list(nms = c("scalar", "scalar1", "other", "scalar2", "tensor"))
expected_types <- list(scalar = "Scalar", scalar1 = "Scalar", other = c("Tensor", 
"Scalar"), scalar2 = "Scalar", tensor = "Tensor")
nd_args <- c("scalar", "scalar1", "other", "scalar2", "tensor")
return_types <- list(list('ScalarType'))
call_c_function(
fun_name = 'result_type',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_rfft <- function(self, signal_ndim, normalized = FALSE, onesided = TRUE) {
  args <- rlang::env_get_list(nms = c("self", "signal_ndim", "normalized", "onesided"))
expected_types <- list(self = "Tensor", signal_ndim = "int64_t", normalized = "bool", 
    onesided = "bool")
nd_args <- c("self", "signal_ndim")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'rfft',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_rnn_relu <- function(data, input, batch_sizes, hx, params, has_biases, num_layers, dropout, train, batch_first, bidirectional) {
  args <- rlang::env_get_list(nms = c("data", "input", "batch_sizes", "hx", "params", "has_biases", "num_layers", "dropout", "train", "batch_first", "bidirectional"))
expected_types <- list(data = "Tensor", input = "Tensor", batch_sizes = "Tensor", 
    hx = "Tensor", params = "TensorList", has_biases = "bool", 
    num_layers = "int64_t", dropout = "double", train = "bool", 
    batch_first = "bool", bidirectional = "bool")
nd_args <- c("data", "input", "batch_sizes", "hx", "params", "has_biases", 
"num_layers", "dropout", "train", "batch_first", "bidirectional"
)
return_types <- list(list("Tensor", "Tensor"))
call_c_function(
fun_name = 'rnn_relu',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_rnn_relu_cell <- function(input, hx, w_ih, w_hh, b_ih = list(), b_hh = list()) {
  args <- rlang::env_get_list(nms = c("input", "hx", "w_ih", "w_hh", "b_ih", "b_hh"))
expected_types <- list(input = "Tensor", hx = "Tensor", w_ih = "Tensor", w_hh = "Tensor", 
    b_ih = "Tensor", b_hh = "Tensor")
nd_args <- c("input", "hx", "w_ih", "w_hh")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'rnn_relu_cell',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_rnn_tanh <- function(data, input, batch_sizes, hx, params, has_biases, num_layers, dropout, train, batch_first, bidirectional) {
  args <- rlang::env_get_list(nms = c("data", "input", "batch_sizes", "hx", "params", "has_biases", "num_layers", "dropout", "train", "batch_first", "bidirectional"))
expected_types <- list(data = "Tensor", input = "Tensor", batch_sizes = "Tensor", 
    hx = "Tensor", params = "TensorList", has_biases = "bool", 
    num_layers = "int64_t", dropout = "double", train = "bool", 
    batch_first = "bool", bidirectional = "bool")
nd_args <- c("data", "input", "batch_sizes", "hx", "params", "has_biases", 
"num_layers", "dropout", "train", "batch_first", "bidirectional"
)
return_types <- list(list("Tensor", "Tensor"))
call_c_function(
fun_name = 'rnn_tanh',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_rnn_tanh_cell <- function(input, hx, w_ih, w_hh, b_ih = list(), b_hh = list()) {
  args <- rlang::env_get_list(nms = c("input", "hx", "w_ih", "w_hh", "b_ih", "b_hh"))
expected_types <- list(input = "Tensor", hx = "Tensor", w_ih = "Tensor", w_hh = "Tensor", 
    b_ih = "Tensor", b_hh = "Tensor")
nd_args <- c("input", "hx", "w_ih", "w_hh")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'rnn_tanh_cell',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_roll <- function(self, shifts, dims = list()) {
  args <- rlang::env_get_list(nms = c("self", "shifts", "dims"))
expected_types <- list(self = "Tensor", shifts = "IntArrayRef", dims = "IntArrayRef")
nd_args <- c("self", "shifts")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'roll',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_rot90 <- function(self, k = 1, dims = c(0,1)) {
  args <- rlang::env_get_list(nms = c("self", "k", "dims"))
expected_types <- list(self = "Tensor", k = "int64_t", dims = "IntArrayRef")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'rot90',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_round <- function(self) {
  args <- rlang::env_get_list(nms = c("self"))
expected_types <- list(self = "Tensor")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'round',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_round_ <- function(self) {
  args <- rlang::env_get_list(nms = c("self"))
expected_types <- list(self = "Tensor")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'round_',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_round_out <- function(out, self) {
  args <- rlang::env_get_list(nms = c("out", "self"))
expected_types <- list(out = "Tensor", self = "Tensor")
nd_args <- c("out", "self")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'round_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_rrelu <- function(self, lower = 0.125000, upper = 0.333333, training = FALSE, generator = NULL) {
  args <- rlang::env_get_list(nms = c("self", "lower", "upper", "training", "generator"))
expected_types <- list(self = "Tensor", lower = "Scalar", upper = "Scalar", training = "bool", 
    generator = "Generator *")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'rrelu',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_rrelu_ <- function(self, lower = 0.125000, upper = 0.333333, training = FALSE, generator = NULL) {
  args <- rlang::env_get_list(nms = c("self", "lower", "upper", "training", "generator"))
expected_types <- list(self = "Tensor", lower = "Scalar", upper = "Scalar", training = "bool", 
    generator = "Generator *")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'rrelu_',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_rrelu_with_noise <- function(self, noise, lower = 0.125000, upper = 0.333333, training = FALSE, generator = NULL) {
  args <- rlang::env_get_list(nms = c("self", "noise", "lower", "upper", "training", "generator"))
expected_types <- list(self = "Tensor", noise = "Tensor", lower = "Scalar", upper = "Scalar", 
    training = "bool", generator = "Generator *")
nd_args <- c("self", "noise")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'rrelu_with_noise',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_rrelu_with_noise_ <- function(self, noise, lower = 0.125000, upper = 0.333333, training = FALSE, generator = NULL) {
  args <- rlang::env_get_list(nms = c("self", "noise", "lower", "upper", "training", "generator"))
expected_types <- list(self = "Tensor", noise = "Tensor", lower = "Scalar", upper = "Scalar", 
    training = "bool", generator = "Generator *")
nd_args <- c("self", "noise")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'rrelu_with_noise_',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_rrelu_with_noise_backward <- function(grad_output, self, noise, lower, upper, training, self_is_result) {
  args <- rlang::env_get_list(nms = c("grad_output", "self", "noise", "lower", "upper", "training", "self_is_result"))
expected_types <- list(grad_output = "Tensor", self = "Tensor", noise = "Tensor", 
    lower = "Scalar", upper = "Scalar", training = "bool", self_is_result = "bool")
nd_args <- c("grad_output", "self", "noise", "lower", "upper", "training", 
"self_is_result")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'rrelu_with_noise_backward',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_rrelu_with_noise_out <- function(out, self, noise, lower = 0.125000, upper = 0.333333, training = FALSE, generator = NULL) {
  args <- rlang::env_get_list(nms = c("out", "self", "noise", "lower", "upper", "training", "generator"))
expected_types <- list(out = "Tensor", self = "Tensor", noise = "Tensor", lower = "Scalar", 
    upper = "Scalar", training = "bool", generator = "Generator *")
nd_args <- c("out", "self", "noise")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'rrelu_with_noise_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_rsqrt <- function(self) {
  args <- rlang::env_get_list(nms = c("self"))
expected_types <- list(self = "Tensor")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'rsqrt',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_rsqrt_ <- function(self) {
  args <- rlang::env_get_list(nms = c("self"))
expected_types <- list(self = "Tensor")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'rsqrt_',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_rsqrt_out <- function(out, self) {
  args <- rlang::env_get_list(nms = c("out", "self"))
expected_types <- list(out = "Tensor", self = "Tensor")
nd_args <- c("out", "self")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'rsqrt_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_rsub <- function(self, other, alpha = 1) {
  args <- rlang::env_get_list(nms = c("self", "other", "alpha"))
expected_types <- list(self = "Tensor", other = c("Tensor", "Scalar"), alpha = "Scalar")
nd_args <- c("self", "other")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'rsub',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_scalar_tensor <- function(s, options = list()) {
  args <- rlang::env_get_list(nms = c("s", "options"))
expected_types <- list(s = "Scalar", options = "TensorOptions")
nd_args <- "s"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'scalar_tensor',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_scatter <- function(self, dim, index, src, value) {
  args <- rlang::env_get_list(nms = c("self", "dim", "index", "src", "value"))
expected_types <- list(self = "Tensor", dim = c("int64_t", "Dimname"), index = "Tensor", 
    src = "Tensor", value = "Scalar")
nd_args <- c("self", "dim", "index", "src", "value")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'scatter',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_scatter_add <- function(self, dim, index, src) {
  args <- rlang::env_get_list(nms = c("self", "dim", "index", "src"))
expected_types <- list(self = "Tensor", dim = c("int64_t", "Dimname"), index = "Tensor", 
    src = "Tensor")
nd_args <- c("self", "dim", "index", "src")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'scatter_add',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_select <- function(self, dim, index) {
  args <- rlang::env_get_list(nms = c("self", "dim", "index"))
expected_types <- list(self = "Tensor", dim = c("Dimname", "int64_t"), index = "int64_t")
nd_args <- c("self", "dim", "index")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'select',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_selu <- function(self) {
  args <- rlang::env_get_list(nms = c("self"))
expected_types <- list(self = "Tensor")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'selu',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_selu_ <- function(self) {
  args <- rlang::env_get_list(nms = c("self"))
expected_types <- list(self = "Tensor")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'selu_',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_sigmoid <- function(self) {
  args <- rlang::env_get_list(nms = c("self"))
expected_types <- list(self = "Tensor")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'sigmoid',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_sigmoid_ <- function(self) {
  args <- rlang::env_get_list(nms = c("self"))
expected_types <- list(self = "Tensor")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'sigmoid_',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_sigmoid_backward <- function(grad_output, output) {
  args <- rlang::env_get_list(nms = c("grad_output", "output"))
expected_types <- list(grad_output = "Tensor", output = "Tensor")
nd_args <- c("grad_output", "output")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'sigmoid_backward',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_sigmoid_backward_out <- function(grad_input, grad_output, output) {
  args <- rlang::env_get_list(nms = c("grad_input", "grad_output", "output"))
expected_types <- list(grad_input = "Tensor", grad_output = "Tensor", output = "Tensor")
nd_args <- c("grad_input", "grad_output", "output")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'sigmoid_backward_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_sigmoid_out <- function(out, self) {
  args <- rlang::env_get_list(nms = c("out", "self"))
expected_types <- list(out = "Tensor", self = "Tensor")
nd_args <- c("out", "self")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'sigmoid_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_sign <- function(self) {
  args <- rlang::env_get_list(nms = c("self"))
expected_types <- list(self = "Tensor")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'sign',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_sign_out <- function(out, self) {
  args <- rlang::env_get_list(nms = c("out", "self"))
expected_types <- list(out = "Tensor", self = "Tensor")
nd_args <- c("out", "self")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'sign_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_sin <- function(self) {
  args <- rlang::env_get_list(nms = c("self"))
expected_types <- list(self = "Tensor")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'sin',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_sin_ <- function(self) {
  args <- rlang::env_get_list(nms = c("self"))
expected_types <- list(self = "Tensor")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'sin_',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_sin_out <- function(out, self) {
  args <- rlang::env_get_list(nms = c("out", "self"))
expected_types <- list(out = "Tensor", self = "Tensor")
nd_args <- c("out", "self")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'sin_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_sinh <- function(self) {
  args <- rlang::env_get_list(nms = c("self"))
expected_types <- list(self = "Tensor")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'sinh',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_sinh_ <- function(self) {
  args <- rlang::env_get_list(nms = c("self"))
expected_types <- list(self = "Tensor")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'sinh_',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_sinh_out <- function(out, self) {
  args <- rlang::env_get_list(nms = c("out", "self"))
expected_types <- list(out = "Tensor", self = "Tensor")
nd_args <- c("out", "self")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'sinh_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_size <- function(self, dim) {
  args <- rlang::env_get_list(nms = c("self", "dim"))
expected_types <- list(self = "Tensor", dim = c("int64_t", "Dimname"))
nd_args <- c("self", "dim")
return_types <- list(list('int64_t'))
call_c_function(
fun_name = 'size',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_slice <- function(self, dim = 0, start = 0, end = 9223372036854775807, step = 1) {
  args <- rlang::env_get_list(nms = c("self", "dim", "start", "end", "step"))
expected_types <- list(self = "Tensor", dim = "int64_t", start = "int64_t", end = "int64_t", 
    step = "int64_t")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'slice',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_slogdet <- function(self) {
  args <- rlang::env_get_list(nms = c("self"))
expected_types <- list(self = "Tensor")
nd_args <- "self"
return_types <- list(list("Tensor", "Tensor"))
call_c_function(
fun_name = 'slogdet',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_slow_conv_dilated2d <- function(self, weight, kernel_size, bias = list(), stride = 1, padding = 0, dilation = 1) {
  args <- rlang::env_get_list(nms = c("self", "weight", "kernel_size", "bias", "stride", "padding", "dilation"))
expected_types <- list(self = "Tensor", weight = "Tensor", kernel_size = "IntArrayRef", 
    bias = "Tensor", stride = "IntArrayRef", padding = "IntArrayRef", 
    dilation = "IntArrayRef")
nd_args <- c("self", "weight", "kernel_size")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'slow_conv_dilated2d',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_slow_conv_dilated2d_backward <- function(grad_output, self, weight, kernel_size, stride, padding, dilation, output_mask) {
  args <- rlang::env_get_list(nms = c("grad_output", "self", "weight", "kernel_size", "stride", "padding", "dilation", "output_mask"))
expected_types <- list(grad_output = "Tensor", self = "Tensor", weight = "Tensor", 
    kernel_size = "IntArrayRef", stride = "IntArrayRef", padding = "IntArrayRef", 
    dilation = "IntArrayRef", output_mask = "std::array<bool,3>")
nd_args <- c("grad_output", "self", "weight", "kernel_size", "stride", "padding", 
"dilation", "output_mask")
return_types <- list(list("Tensor", "Tensor", "Tensor"))
call_c_function(
fun_name = 'slow_conv_dilated2d_backward',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_slow_conv_dilated3d <- function(self, weight, kernel_size, bias = list(), stride = 1, padding = 0, dilation = 1) {
  args <- rlang::env_get_list(nms = c("self", "weight", "kernel_size", "bias", "stride", "padding", "dilation"))
expected_types <- list(self = "Tensor", weight = "Tensor", kernel_size = "IntArrayRef", 
    bias = "Tensor", stride = "IntArrayRef", padding = "IntArrayRef", 
    dilation = "IntArrayRef")
nd_args <- c("self", "weight", "kernel_size")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'slow_conv_dilated3d',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_slow_conv_dilated3d_backward <- function(grad_output, self, weight, kernel_size, stride, padding, dilation, output_mask) {
  args <- rlang::env_get_list(nms = c("grad_output", "self", "weight", "kernel_size", "stride", "padding", "dilation", "output_mask"))
expected_types <- list(grad_output = "Tensor", self = "Tensor", weight = "Tensor", 
    kernel_size = "IntArrayRef", stride = "IntArrayRef", padding = "IntArrayRef", 
    dilation = "IntArrayRef", output_mask = "std::array<bool,3>")
nd_args <- c("grad_output", "self", "weight", "kernel_size", "stride", "padding", 
"dilation", "output_mask")
return_types <- list(list("Tensor", "Tensor", "Tensor"))
call_c_function(
fun_name = 'slow_conv_dilated3d_backward',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_slow_conv_transpose2d <- function(self, weight, kernel_size, bias = list(), stride = 1, padding = 0, output_padding = 0, dilation = 1) {
  args <- rlang::env_get_list(nms = c("self", "weight", "kernel_size", "bias", "stride", "padding", "output_padding", "dilation"))
expected_types <- list(self = "Tensor", weight = "Tensor", kernel_size = "IntArrayRef", 
    bias = "Tensor", stride = "IntArrayRef", padding = "IntArrayRef", 
    output_padding = "IntArrayRef", dilation = "IntArrayRef")
nd_args <- c("self", "weight", "kernel_size")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'slow_conv_transpose2d',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_slow_conv_transpose2d_backward <- function(grad_output, self, weight, kernel_size, stride, padding, output_padding, dilation, columns, ones, output_mask) {
  args <- rlang::env_get_list(nms = c("grad_output", "self", "weight", "kernel_size", "stride", "padding", "output_padding", "dilation", "columns", "ones", "output_mask"))
expected_types <- list(grad_output = "Tensor", self = "Tensor", weight = "Tensor", 
    kernel_size = "IntArrayRef", stride = "IntArrayRef", padding = "IntArrayRef", 
    output_padding = "IntArrayRef", dilation = "IntArrayRef", 
    columns = "Tensor", ones = "Tensor", output_mask = "std::array<bool,3>")
nd_args <- c("grad_output", "self", "weight", "kernel_size", "stride", "padding", 
"output_padding", "dilation", "columns", "ones", "output_mask"
)
return_types <- list(list("Tensor", "Tensor", "Tensor"))
call_c_function(
fun_name = 'slow_conv_transpose2d_backward',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_slow_conv_transpose2d_backward_out <- function(grad_input, grad_weight, grad_bias, grad_output, self, weight, kernel_size, stride, padding, output_padding, dilation, columns, ones) {
  args <- rlang::env_get_list(nms = c("grad_input", "grad_weight", "grad_bias", "grad_output", "self", "weight", "kernel_size", "stride", "padding", "output_padding", "dilation", "columns", "ones"))
expected_types <- list(grad_input = "Tensor", grad_weight = "Tensor", grad_bias = "Tensor", 
    grad_output = "Tensor", self = "Tensor", weight = "Tensor", 
    kernel_size = "IntArrayRef", stride = "IntArrayRef", padding = "IntArrayRef", 
    output_padding = "IntArrayRef", dilation = "IntArrayRef", 
    columns = "Tensor", ones = "Tensor")
nd_args <- c("grad_input", "grad_weight", "grad_bias", "grad_output", "self", 
"weight", "kernel_size", "stride", "padding", "output_padding", 
"dilation", "columns", "ones")
return_types <- list(list("Tensor", "Tensor", "Tensor"))
call_c_function(
fun_name = 'slow_conv_transpose2d_backward_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_slow_conv_transpose2d_out <- function(out, self, weight, kernel_size, bias = list(), stride = 1, padding = 0, output_padding = 0, dilation = 1) {
  args <- rlang::env_get_list(nms = c("out", "self", "weight", "kernel_size", "bias", "stride", "padding", "output_padding", "dilation"))
expected_types <- list(out = "Tensor", self = "Tensor", weight = "Tensor", kernel_size = "IntArrayRef", 
    bias = "Tensor", stride = "IntArrayRef", padding = "IntArrayRef", 
    output_padding = "IntArrayRef", dilation = "IntArrayRef")
nd_args <- c("out", "self", "weight", "kernel_size")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'slow_conv_transpose2d_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_slow_conv_transpose3d <- function(self, weight, kernel_size, bias = list(), stride = 1, padding = 0, output_padding = 0, dilation = 1) {
  args <- rlang::env_get_list(nms = c("self", "weight", "kernel_size", "bias", "stride", "padding", "output_padding", "dilation"))
expected_types <- list(self = "Tensor", weight = "Tensor", kernel_size = "IntArrayRef", 
    bias = "Tensor", stride = "IntArrayRef", padding = "IntArrayRef", 
    output_padding = "IntArrayRef", dilation = "IntArrayRef")
nd_args <- c("self", "weight", "kernel_size")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'slow_conv_transpose3d',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_slow_conv_transpose3d_backward <- function(grad_output, self, weight, kernel_size, stride, padding, output_padding, dilation, finput, fgrad_input, output_mask) {
  args <- rlang::env_get_list(nms = c("grad_output", "self", "weight", "kernel_size", "stride", "padding", "output_padding", "dilation", "finput", "fgrad_input", "output_mask"))
expected_types <- list(grad_output = "Tensor", self = "Tensor", weight = "Tensor", 
    kernel_size = "IntArrayRef", stride = "IntArrayRef", padding = "IntArrayRef", 
    output_padding = "IntArrayRef", dilation = "IntArrayRef", 
    finput = "Tensor", fgrad_input = "Tensor", output_mask = "std::array<bool,3>")
nd_args <- c("grad_output", "self", "weight", "kernel_size", "stride", "padding", 
"output_padding", "dilation", "finput", "fgrad_input", "output_mask"
)
return_types <- list(list("Tensor", "Tensor", "Tensor"))
call_c_function(
fun_name = 'slow_conv_transpose3d_backward',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_slow_conv_transpose3d_backward_out <- function(grad_input, grad_weight, grad_bias, grad_output, self, weight, kernel_size, stride, padding, output_padding, dilation, finput, fgrad_input) {
  args <- rlang::env_get_list(nms = c("grad_input", "grad_weight", "grad_bias", "grad_output", "self", "weight", "kernel_size", "stride", "padding", "output_padding", "dilation", "finput", "fgrad_input"))
expected_types <- list(grad_input = "Tensor", grad_weight = "Tensor", grad_bias = "Tensor", 
    grad_output = "Tensor", self = "Tensor", weight = "Tensor", 
    kernel_size = "IntArrayRef", stride = "IntArrayRef", padding = "IntArrayRef", 
    output_padding = "IntArrayRef", dilation = "IntArrayRef", 
    finput = "Tensor", fgrad_input = "Tensor")
nd_args <- c("grad_input", "grad_weight", "grad_bias", "grad_output", "self", 
"weight", "kernel_size", "stride", "padding", "output_padding", 
"dilation", "finput", "fgrad_input")
return_types <- list(list("Tensor", "Tensor", "Tensor"))
call_c_function(
fun_name = 'slow_conv_transpose3d_backward_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_slow_conv_transpose3d_out <- function(out, self, weight, kernel_size, bias = list(), stride = 1, padding = 0, output_padding = 0, dilation = 1) {
  args <- rlang::env_get_list(nms = c("out", "self", "weight", "kernel_size", "bias", "stride", "padding", "output_padding", "dilation"))
expected_types <- list(out = "Tensor", self = "Tensor", weight = "Tensor", kernel_size = "IntArrayRef", 
    bias = "Tensor", stride = "IntArrayRef", padding = "IntArrayRef", 
    output_padding = "IntArrayRef", dilation = "IntArrayRef")
nd_args <- c("out", "self", "weight", "kernel_size")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'slow_conv_transpose3d_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_slow_conv3d <- function(self, weight, kernel_size, bias = list(), stride = 1, padding = 0) {
  args <- rlang::env_get_list(nms = c("self", "weight", "kernel_size", "bias", "stride", "padding"))
expected_types <- list(self = "Tensor", weight = "Tensor", kernel_size = "IntArrayRef", 
    bias = "Tensor", stride = "IntArrayRef", padding = "IntArrayRef")
nd_args <- c("self", "weight", "kernel_size")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'slow_conv3d',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_slow_conv3d_backward <- function(grad_output, self, weight, kernel_size, stride, padding, finput, fgrad_input, output_mask) {
  args <- rlang::env_get_list(nms = c("grad_output", "self", "weight", "kernel_size", "stride", "padding", "finput", "fgrad_input", "output_mask"))
expected_types <- list(grad_output = "Tensor", self = "Tensor", weight = "Tensor", 
    kernel_size = "IntArrayRef", stride = "IntArrayRef", padding = "IntArrayRef", 
    finput = "Tensor", fgrad_input = "Tensor", output_mask = "std::array<bool,3>")
nd_args <- c("grad_output", "self", "weight", "kernel_size", "stride", "padding", 
"finput", "fgrad_input", "output_mask")
return_types <- list(list("Tensor", "Tensor", "Tensor"))
call_c_function(
fun_name = 'slow_conv3d_backward',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_slow_conv3d_backward_out <- function(grad_input, grad_weight, grad_bias, grad_output, self, weight, kernel_size, stride, padding, finput, fgrad_input) {
  args <- rlang::env_get_list(nms = c("grad_input", "grad_weight", "grad_bias", "grad_output", "self", "weight", "kernel_size", "stride", "padding", "finput", "fgrad_input"))
expected_types <- list(grad_input = "Tensor", grad_weight = "Tensor", grad_bias = "Tensor", 
    grad_output = "Tensor", self = "Tensor", weight = "Tensor", 
    kernel_size = "IntArrayRef", stride = "IntArrayRef", padding = "IntArrayRef", 
    finput = "Tensor", fgrad_input = "Tensor")
nd_args <- c("grad_input", "grad_weight", "grad_bias", "grad_output", "self", 
"weight", "kernel_size", "stride", "padding", "finput", "fgrad_input"
)
return_types <- list(list("Tensor", "Tensor", "Tensor"))
call_c_function(
fun_name = 'slow_conv3d_backward_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_slow_conv3d_forward <- function(self, weight, kernel_size, bias, stride, padding) {
  args <- rlang::env_get_list(nms = c("self", "weight", "kernel_size", "bias", "stride", "padding"))
expected_types <- list(self = "Tensor", weight = "Tensor", kernel_size = "IntArrayRef", 
    bias = "Tensor", stride = "IntArrayRef", padding = "IntArrayRef")
nd_args <- c("self", "weight", "kernel_size", "bias", "stride", "padding"
)
return_types <- list(list("Tensor", "Tensor", "Tensor"))
call_c_function(
fun_name = 'slow_conv3d_forward',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_slow_conv3d_forward_out <- function(output, finput, fgrad_input, self, weight, kernel_size, bias, stride, padding) {
  args <- rlang::env_get_list(nms = c("output", "finput", "fgrad_input", "self", "weight", "kernel_size", "bias", "stride", "padding"))
expected_types <- list(output = "Tensor", finput = "Tensor", fgrad_input = "Tensor", 
    self = "Tensor", weight = "Tensor", kernel_size = "IntArrayRef", 
    bias = "Tensor", stride = "IntArrayRef", padding = "IntArrayRef")
nd_args <- c("output", "finput", "fgrad_input", "self", "weight", "kernel_size", 
"bias", "stride", "padding")
return_types <- list(list("Tensor", "Tensor", "Tensor"))
call_c_function(
fun_name = 'slow_conv3d_forward_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_slow_conv3d_out <- function(out, self, weight, kernel_size, bias = list(), stride = 1, padding = 0) {
  args <- rlang::env_get_list(nms = c("out", "self", "weight", "kernel_size", "bias", "stride", "padding"))
expected_types <- list(out = "Tensor", self = "Tensor", weight = "Tensor", kernel_size = "IntArrayRef", 
    bias = "Tensor", stride = "IntArrayRef", padding = "IntArrayRef")
nd_args <- c("out", "self", "weight", "kernel_size")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'slow_conv3d_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_smm <- function(self, mat2) {
  args <- rlang::env_get_list(nms = c("self", "mat2"))
expected_types <- list(self = "Tensor", mat2 = "Tensor")
nd_args <- c("self", "mat2")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'smm',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_smooth_l1_loss <- function(self, target, reduction = torch_reduction_mean()) {
  args <- rlang::env_get_list(nms = c("self", "target", "reduction"))
expected_types <- list(self = "Tensor", target = "Tensor", reduction = "int64_t")
nd_args <- c("self", "target")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'smooth_l1_loss',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_smooth_l1_loss_backward <- function(grad_output, self, target, reduction) {
  args <- rlang::env_get_list(nms = c("grad_output", "self", "target", "reduction"))
expected_types <- list(grad_output = "Tensor", self = "Tensor", target = "Tensor", 
    reduction = "int64_t")
nd_args <- c("grad_output", "self", "target", "reduction")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'smooth_l1_loss_backward',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_smooth_l1_loss_backward_out <- function(grad_input, grad_output, self, target, reduction) {
  args <- rlang::env_get_list(nms = c("grad_input", "grad_output", "self", "target", "reduction"))
expected_types <- list(grad_input = "Tensor", grad_output = "Tensor", self = "Tensor", 
    target = "Tensor", reduction = "int64_t")
nd_args <- c("grad_input", "grad_output", "self", "target", "reduction")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'smooth_l1_loss_backward_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_smooth_l1_loss_out <- function(out, self, target, reduction = torch_reduction_mean()) {
  args <- rlang::env_get_list(nms = c("out", "self", "target", "reduction"))
expected_types <- list(out = "Tensor", self = "Tensor", target = "Tensor", reduction = "int64_t")
nd_args <- c("out", "self", "target")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'smooth_l1_loss_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_soft_margin_loss <- function(self, target, reduction = torch_reduction_mean()) {
  args <- rlang::env_get_list(nms = c("self", "target", "reduction"))
expected_types <- list(self = "Tensor", target = "Tensor", reduction = "int64_t")
nd_args <- c("self", "target")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'soft_margin_loss',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_soft_margin_loss_backward <- function(grad_output, self, target, reduction) {
  args <- rlang::env_get_list(nms = c("grad_output", "self", "target", "reduction"))
expected_types <- list(grad_output = "Tensor", self = "Tensor", target = "Tensor", 
    reduction = "int64_t")
nd_args <- c("grad_output", "self", "target", "reduction")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'soft_margin_loss_backward',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_soft_margin_loss_backward_out <- function(grad_input, grad_output, self, target, reduction) {
  args <- rlang::env_get_list(nms = c("grad_input", "grad_output", "self", "target", "reduction"))
expected_types <- list(grad_input = "Tensor", grad_output = "Tensor", self = "Tensor", 
    target = "Tensor", reduction = "int64_t")
nd_args <- c("grad_input", "grad_output", "self", "target", "reduction")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'soft_margin_loss_backward_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_soft_margin_loss_out <- function(out, self, target, reduction = torch_reduction_mean()) {
  args <- rlang::env_get_list(nms = c("out", "self", "target", "reduction"))
expected_types <- list(out = "Tensor", self = "Tensor", target = "Tensor", reduction = "int64_t")
nd_args <- c("out", "self", "target")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'soft_margin_loss_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_softmax <- function(self, dim, dtype = NULL) {
  args <- rlang::env_get_list(nms = c("self", "dim", "dtype"))
expected_types <- list(self = "Tensor", dim = c("int64_t", "Dimname"), dtype = "ScalarType")
nd_args <- c("self", "dim")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'softmax',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_softplus <- function(self, beta = 1, threshold = 20) {
  args <- rlang::env_get_list(nms = c("self", "beta", "threshold"))
expected_types <- list(self = "Tensor", beta = "Scalar", threshold = "Scalar")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'softplus',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_softplus_backward <- function(grad_output, self, beta, threshold, output) {
  args <- rlang::env_get_list(nms = c("grad_output", "self", "beta", "threshold", "output"))
expected_types <- list(grad_output = "Tensor", self = "Tensor", beta = "Scalar", 
    threshold = "Scalar", output = "Tensor")
nd_args <- c("grad_output", "self", "beta", "threshold", "output")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'softplus_backward',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_softplus_backward_out <- function(grad_input, grad_output, self, beta, threshold, output) {
  args <- rlang::env_get_list(nms = c("grad_input", "grad_output", "self", "beta", "threshold", "output"))
expected_types <- list(grad_input = "Tensor", grad_output = "Tensor", self = "Tensor", 
    beta = "Scalar", threshold = "Scalar", output = "Tensor")
nd_args <- c("grad_input", "grad_output", "self", "beta", "threshold", "output"
)
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'softplus_backward_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_softplus_out <- function(out, self, beta = 1, threshold = 20) {
  args <- rlang::env_get_list(nms = c("out", "self", "beta", "threshold"))
expected_types <- list(out = "Tensor", self = "Tensor", beta = "Scalar", threshold = "Scalar")
nd_args <- c("out", "self")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'softplus_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_softshrink <- function(self, lambd = 0.500000) {
  args <- rlang::env_get_list(nms = c("self", "lambd"))
expected_types <- list(self = "Tensor", lambd = "Scalar")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'softshrink',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_softshrink_backward <- function(grad_output, self, lambd) {
  args <- rlang::env_get_list(nms = c("grad_output", "self", "lambd"))
expected_types <- list(grad_output = "Tensor", self = "Tensor", lambd = "Scalar")
nd_args <- c("grad_output", "self", "lambd")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'softshrink_backward',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_softshrink_backward_out <- function(grad_input, grad_output, self, lambd) {
  args <- rlang::env_get_list(nms = c("grad_input", "grad_output", "self", "lambd"))
expected_types <- list(grad_input = "Tensor", grad_output = "Tensor", self = "Tensor", 
    lambd = "Scalar")
nd_args <- c("grad_input", "grad_output", "self", "lambd")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'softshrink_backward_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_softshrink_out <- function(out, self, lambd = 0.500000) {
  args <- rlang::env_get_list(nms = c("out", "self", "lambd"))
expected_types <- list(out = "Tensor", self = "Tensor", lambd = "Scalar")
nd_args <- c("out", "self")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'softshrink_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_solve <- function(self, A) {
  args <- rlang::env_get_list(nms = c("self", "A"))
expected_types <- list(self = "Tensor", A = "Tensor")
nd_args <- c("self", "A")
return_types <- list(list("Tensor", "Tensor"))
call_c_function(
fun_name = 'solve',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_solve_out <- function(solution, lu, self, A) {
  args <- rlang::env_get_list(nms = c("solution", "lu", "self", "A"))
expected_types <- list(solution = "Tensor", lu = "Tensor", self = "Tensor", A = "Tensor")
nd_args <- c("solution", "lu", "self", "A")
return_types <- list(list("Tensor", "Tensor"))
call_c_function(
fun_name = 'solve_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_sort <- function(self, dim = -1, descending = FALSE) {
  args <- rlang::env_get_list(nms = c("self", "dim", "descending"))
expected_types <- list(self = "Tensor", dim = c("int64_t", "Dimname"), descending = "bool")
nd_args <- "self"
return_types <- list(list("Tensor", "Tensor"))
call_c_function(
fun_name = 'sort',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_sort_out <- function(values, indices, self, dim = -1, descending = FALSE) {
  args <- rlang::env_get_list(nms = c("values", "indices", "self", "dim", "descending"))
expected_types <- list(values = "Tensor", indices = "Tensor", self = "Tensor", 
    dim = c("int64_t", "Dimname"), descending = "bool")
nd_args <- c("values", "indices", "self")
return_types <- list(list("Tensor", "Tensor"))
call_c_function(
fun_name = 'sort_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_sparse_coo_tensor <- function(indices, values, size, options = list()) {
  args <- rlang::env_get_list(nms = c("indices", "values", "size", "options"))
expected_types <- list(indices = "Tensor", values = "Tensor", size = "IntArrayRef", 
    options = "TensorOptions")
nd_args <- c("indices", "values", "size")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'sparse_coo_tensor',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_split <- function(self, split_size, dim = 0) {
  args <- rlang::env_get_list(nms = c("self", "split_size", "dim"))
expected_types <- list(self = "Tensor", split_size = "int64_t", dim = "int64_t")
nd_args <- c("self", "split_size")
return_types <- list(list('TensorList'))
call_c_function(
fun_name = 'split',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_split_with_sizes <- function(self, split_sizes, dim = 0) {
  args <- rlang::env_get_list(nms = c("self", "split_sizes", "dim"))
expected_types <- list(self = "Tensor", split_sizes = "IntArrayRef", dim = "int64_t")
nd_args <- c("self", "split_sizes")
return_types <- list(list('TensorList'))
call_c_function(
fun_name = 'split_with_sizes',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_sqrt <- function(self) {
  args <- rlang::env_get_list(nms = c("self"))
expected_types <- list(self = "Tensor")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'sqrt',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_sqrt_ <- function(self) {
  args <- rlang::env_get_list(nms = c("self"))
expected_types <- list(self = "Tensor")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'sqrt_',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_sqrt_out <- function(out, self) {
  args <- rlang::env_get_list(nms = c("out", "self"))
expected_types <- list(out = "Tensor", self = "Tensor")
nd_args <- c("out", "self")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'sqrt_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_square <- function(self) {
  args <- rlang::env_get_list(nms = c("self"))
expected_types <- list(self = "Tensor")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'square',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_square_ <- function(self) {
  args <- rlang::env_get_list(nms = c("self"))
expected_types <- list(self = "Tensor")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'square_',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_squeeze <- function(self, dim) {
  args <- rlang::env_get_list(nms = c("self", "dim"))
expected_types <- list(self = "Tensor", dim = c("int64_t", "Dimname"))
nd_args <- c("self", "dim")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'squeeze',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_sspaddmm <- function(self, mat1, mat2, beta = 1, alpha = 1) {
  args <- rlang::env_get_list(nms = c("self", "mat1", "mat2", "beta", "alpha"))
expected_types <- list(self = "Tensor", mat1 = "Tensor", mat2 = "Tensor", beta = "Scalar", 
    alpha = "Scalar")
nd_args <- c("self", "mat1", "mat2")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'sspaddmm',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_sspaddmm_out <- function(out, self, mat1, mat2, beta = 1, alpha = 1) {
  args <- rlang::env_get_list(nms = c("out", "self", "mat1", "mat2", "beta", "alpha"))
expected_types <- list(out = "Tensor", self = "Tensor", mat1 = "Tensor", mat2 = "Tensor", 
    beta = "Scalar", alpha = "Scalar")
nd_args <- c("out", "self", "mat1", "mat2")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'sspaddmm_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_stack <- function(tensors, dim = 0) {
  args <- rlang::env_get_list(nms = c("tensors", "dim"))
expected_types <- list(tensors = "TensorList", dim = "int64_t")
nd_args <- "tensors"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'stack',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_stack_out <- function(out, tensors, dim = 0) {
  args <- rlang::env_get_list(nms = c("out", "tensors", "dim"))
expected_types <- list(out = "Tensor", tensors = "TensorList", dim = "int64_t")
nd_args <- c("out", "tensors")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'stack_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_std <- function(self, dim, unbiased = TRUE, keepdim = FALSE) {
  args <- rlang::env_get_list(nms = c("self", "dim", "unbiased", "keepdim"))
expected_types <- list(self = "Tensor", dim = c("IntArrayRef", "DimnameList"), 
    unbiased = "bool", keepdim = "bool")
nd_args <- c("self", "dim")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'std',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_std_mean <- function(self, dim, unbiased = TRUE, keepdim = FALSE) {
  args <- rlang::env_get_list(nms = c("self", "dim", "unbiased", "keepdim"))
expected_types <- list(self = "Tensor", dim = c("IntArrayRef", "DimnameList"), 
    unbiased = "bool", keepdim = "bool")
nd_args <- c("self", "dim")
return_types <- list(list("Tensor", "Tensor"))
call_c_function(
fun_name = 'std_mean',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_std_out <- function(out, self, dim, unbiased = TRUE, keepdim = FALSE) {
  args <- rlang::env_get_list(nms = c("out", "self", "dim", "unbiased", "keepdim"))
expected_types <- list(out = "Tensor", self = "Tensor", dim = c("IntArrayRef", 
"DimnameList"), unbiased = "bool", keepdim = "bool")
nd_args <- c("out", "self", "dim")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'std_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_stft <- function(self, n_fft, hop_length = NULL, win_length = NULL, window = list(), normalized = FALSE, onesided = TRUE) {
  args <- rlang::env_get_list(nms = c("self", "n_fft", "hop_length", "win_length", "window", "normalized", "onesided"))
expected_types <- list(self = "Tensor", n_fft = "int64_t", hop_length = "int64_t", 
    win_length = "int64_t", window = "Tensor", normalized = "bool", 
    onesided = "bool")
nd_args <- c("self", "n_fft")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'stft',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_stride <- function(self, dim) {
  args <- rlang::env_get_list(nms = c("self", "dim"))
expected_types <- list(self = "Tensor", dim = c("int64_t", "Dimname"))
nd_args <- c("self", "dim")
return_types <- list(list('int64_t'))
call_c_function(
fun_name = 'stride',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_sub <- function(self, other, alpha = 1) {
  args <- rlang::env_get_list(nms = c("self", "other", "alpha"))
expected_types <- list(self = "Tensor", other = c("Tensor", "Scalar"), alpha = "Scalar")
nd_args <- c("self", "other")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'sub',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_sub_out <- function(out, self, other, alpha = 1) {
  args <- rlang::env_get_list(nms = c("out", "self", "other", "alpha"))
expected_types <- list(out = "Tensor", self = "Tensor", other = "Tensor", alpha = "Scalar")
nd_args <- c("out", "self", "other")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'sub_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_sum <- function(self, dim, keepdim = FALSE, dtype = NULL) {
  args <- rlang::env_get_list(nms = c("self", "dim", "keepdim", "dtype"))
expected_types <- list(self = "Tensor", dim = c("IntArrayRef", "DimnameList"), 
    keepdim = "bool", dtype = "ScalarType")
nd_args <- c("self", "dim")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'sum',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_sum_out <- function(out, self, dim, keepdim = FALSE, dtype = NULL) {
  args <- rlang::env_get_list(nms = c("out", "self", "dim", "keepdim", "dtype"))
expected_types <- list(out = "Tensor", self = "Tensor", dim = c("IntArrayRef", 
"DimnameList"), keepdim = "bool", dtype = "ScalarType")
nd_args <- c("out", "self", "dim")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'sum_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_svd <- function(self, some = TRUE, compute_uv = TRUE) {
  args <- rlang::env_get_list(nms = c("self", "some", "compute_uv"))
expected_types <- list(self = "Tensor", some = "bool", compute_uv = "bool")
nd_args <- "self"
return_types <- list(list("Tensor", "Tensor", "Tensor"))
call_c_function(
fun_name = 'svd',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_svd_out <- function(U, S, V, self, some = TRUE, compute_uv = TRUE) {
  args <- rlang::env_get_list(nms = c("U", "S", "V", "self", "some", "compute_uv"))
expected_types <- list(U = "Tensor", S = "Tensor", V = "Tensor", self = "Tensor", 
    some = "bool", compute_uv = "bool")
nd_args <- c("U", "S", "V", "self")
return_types <- list(list("Tensor", "Tensor", "Tensor"))
call_c_function(
fun_name = 'svd_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_symeig <- function(self, eigenvectors = FALSE, upper = TRUE) {
  args <- rlang::env_get_list(nms = c("self", "eigenvectors", "upper"))
expected_types <- list(self = "Tensor", eigenvectors = "bool", upper = "bool")
nd_args <- "self"
return_types <- list(list("Tensor", "Tensor"))
call_c_function(
fun_name = 'symeig',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_symeig_out <- function(e, V, self, eigenvectors = FALSE, upper = TRUE) {
  args <- rlang::env_get_list(nms = c("e", "V", "self", "eigenvectors", "upper"))
expected_types <- list(e = "Tensor", V = "Tensor", self = "Tensor", eigenvectors = "bool", 
    upper = "bool")
nd_args <- c("e", "V", "self")
return_types <- list(list("Tensor", "Tensor"))
call_c_function(
fun_name = 'symeig_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_t <- function(self) {
  args <- rlang::env_get_list(nms = c("self"))
expected_types <- list(self = "Tensor")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 't',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_take <- function(self, index) {
  args <- rlang::env_get_list(nms = c("self", "index"))
expected_types <- list(self = "Tensor", index = "Tensor")
nd_args <- c("self", "index")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'take',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_take_out <- function(out, self, index) {
  args <- rlang::env_get_list(nms = c("out", "self", "index"))
expected_types <- list(out = "Tensor", self = "Tensor", index = "Tensor")
nd_args <- c("out", "self", "index")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'take_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_tan <- function(self) {
  args <- rlang::env_get_list(nms = c("self"))
expected_types <- list(self = "Tensor")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'tan',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_tan_ <- function(self) {
  args <- rlang::env_get_list(nms = c("self"))
expected_types <- list(self = "Tensor")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'tan_',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_tan_out <- function(out, self) {
  args <- rlang::env_get_list(nms = c("out", "self"))
expected_types <- list(out = "Tensor", self = "Tensor")
nd_args <- c("out", "self")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'tan_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_tanh <- function(self) {
  args <- rlang::env_get_list(nms = c("self"))
expected_types <- list(self = "Tensor")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'tanh',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_tanh_ <- function(self) {
  args <- rlang::env_get_list(nms = c("self"))
expected_types <- list(self = "Tensor")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'tanh_',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_tanh_backward <- function(grad_output, output) {
  args <- rlang::env_get_list(nms = c("grad_output", "output"))
expected_types <- list(grad_output = "Tensor", output = "Tensor")
nd_args <- c("grad_output", "output")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'tanh_backward',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_tanh_backward_out <- function(grad_input, grad_output, output) {
  args <- rlang::env_get_list(nms = c("grad_input", "grad_output", "output"))
expected_types <- list(grad_input = "Tensor", grad_output = "Tensor", output = "Tensor")
nd_args <- c("grad_input", "grad_output", "output")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'tanh_backward_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_tanh_out <- function(out, self) {
  args <- rlang::env_get_list(nms = c("out", "self"))
expected_types <- list(out = "Tensor", self = "Tensor")
nd_args <- c("out", "self")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'tanh_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_tensordot <- function(self, other, dims_self, dims_other) {
  args <- rlang::env_get_list(nms = c("self", "other", "dims_self", "dims_other"))
expected_types <- list(self = "Tensor", other = "Tensor", dims_self = "IntArrayRef", 
    dims_other = "IntArrayRef")
nd_args <- c("self", "other", "dims_self", "dims_other")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'tensordot',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_thnn_conv_depthwise2d <- function(self, weight, kernel_size, bias = list(), stride = 1, padding = 0, dilation = 1) {
  args <- rlang::env_get_list(nms = c("self", "weight", "kernel_size", "bias", "stride", "padding", "dilation"))
expected_types <- list(self = "Tensor", weight = "Tensor", kernel_size = "IntArrayRef", 
    bias = "Tensor", stride = "IntArrayRef", padding = "IntArrayRef", 
    dilation = "IntArrayRef")
nd_args <- c("self", "weight", "kernel_size")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'thnn_conv_depthwise2d',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_thnn_conv_depthwise2d_backward <- function(grad_output, self, weight, kernel_size, stride, padding, dilation, output_mask) {
  args <- rlang::env_get_list(nms = c("grad_output", "self", "weight", "kernel_size", "stride", "padding", "dilation", "output_mask"))
expected_types <- list(grad_output = "Tensor", self = "Tensor", weight = "Tensor", 
    kernel_size = "IntArrayRef", stride = "IntArrayRef", padding = "IntArrayRef", 
    dilation = "IntArrayRef", output_mask = "std::array<bool,2>")
nd_args <- c("grad_output", "self", "weight", "kernel_size", "stride", "padding", 
"dilation", "output_mask")
return_types <- list(list("Tensor", "Tensor"))
call_c_function(
fun_name = 'thnn_conv_depthwise2d_backward',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_thnn_conv_depthwise2d_backward_out <- function(grad_input, grad_weight, grad_output, self, weight, kernel_size, stride, padding, dilation) {
  args <- rlang::env_get_list(nms = c("grad_input", "grad_weight", "grad_output", "self", "weight", "kernel_size", "stride", "padding", "dilation"))
expected_types <- list(grad_input = "Tensor", grad_weight = "Tensor", grad_output = "Tensor", 
    self = "Tensor", weight = "Tensor", kernel_size = "IntArrayRef", 
    stride = "IntArrayRef", padding = "IntArrayRef", dilation = "IntArrayRef")
nd_args <- c("grad_input", "grad_weight", "grad_output", "self", "weight", 
"kernel_size", "stride", "padding", "dilation")
return_types <- list(list("Tensor", "Tensor"))
call_c_function(
fun_name = 'thnn_conv_depthwise2d_backward_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_thnn_conv_depthwise2d_forward <- function(self, weight, kernel_size, bias, stride, padding, dilation) {
  args <- rlang::env_get_list(nms = c("self", "weight", "kernel_size", "bias", "stride", "padding", "dilation"))
expected_types <- list(self = "Tensor", weight = "Tensor", kernel_size = "IntArrayRef", 
    bias = "Tensor", stride = "IntArrayRef", padding = "IntArrayRef", 
    dilation = "IntArrayRef")
nd_args <- c("self", "weight", "kernel_size", "bias", "stride", "padding", 
"dilation")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'thnn_conv_depthwise2d_forward',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_thnn_conv_depthwise2d_forward_out <- function(out, self, weight, kernel_size, bias, stride, padding, dilation) {
  args <- rlang::env_get_list(nms = c("out", "self", "weight", "kernel_size", "bias", "stride", "padding", "dilation"))
expected_types <- list(out = "Tensor", self = "Tensor", weight = "Tensor", kernel_size = "IntArrayRef", 
    bias = "Tensor", stride = "IntArrayRef", padding = "IntArrayRef", 
    dilation = "IntArrayRef")
nd_args <- c("out", "self", "weight", "kernel_size", "bias", "stride", "padding", 
"dilation")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'thnn_conv_depthwise2d_forward_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_thnn_conv_depthwise2d_out <- function(out, self, weight, kernel_size, bias = list(), stride = 1, padding = 0, dilation = 1) {
  args <- rlang::env_get_list(nms = c("out", "self", "weight", "kernel_size", "bias", "stride", "padding", "dilation"))
expected_types <- list(out = "Tensor", self = "Tensor", weight = "Tensor", kernel_size = "IntArrayRef", 
    bias = "Tensor", stride = "IntArrayRef", padding = "IntArrayRef", 
    dilation = "IntArrayRef")
nd_args <- c("out", "self", "weight", "kernel_size")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'thnn_conv_depthwise2d_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_thnn_conv2d <- function(self, weight, kernel_size, bias = list(), stride = 1, padding = 0) {
  args <- rlang::env_get_list(nms = c("self", "weight", "kernel_size", "bias", "stride", "padding"))
expected_types <- list(self = "Tensor", weight = "Tensor", kernel_size = "IntArrayRef", 
    bias = "Tensor", stride = "IntArrayRef", padding = "IntArrayRef")
nd_args <- c("self", "weight", "kernel_size")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'thnn_conv2d',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_thnn_conv2d_backward <- function(grad_output, self, weight, kernel_size, stride, padding, finput, fgrad_input, output_mask) {
  args <- rlang::env_get_list(nms = c("grad_output", "self", "weight", "kernel_size", "stride", "padding", "finput", "fgrad_input", "output_mask"))
expected_types <- list(grad_output = "Tensor", self = "Tensor", weight = "Tensor", 
    kernel_size = "IntArrayRef", stride = "IntArrayRef", padding = "IntArrayRef", 
    finput = "Tensor", fgrad_input = "Tensor", output_mask = "std::array<bool,3>")
nd_args <- c("grad_output", "self", "weight", "kernel_size", "stride", "padding", 
"finput", "fgrad_input", "output_mask")
return_types <- list(list("Tensor", "Tensor", "Tensor"))
call_c_function(
fun_name = 'thnn_conv2d_backward',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_thnn_conv2d_backward_out <- function(grad_input, grad_weight, grad_bias, grad_output, self, weight, kernel_size, stride, padding, finput, fgrad_input) {
  args <- rlang::env_get_list(nms = c("grad_input", "grad_weight", "grad_bias", "grad_output", "self", "weight", "kernel_size", "stride", "padding", "finput", "fgrad_input"))
expected_types <- list(grad_input = "Tensor", grad_weight = "Tensor", grad_bias = "Tensor", 
    grad_output = "Tensor", self = "Tensor", weight = "Tensor", 
    kernel_size = "IntArrayRef", stride = "IntArrayRef", padding = "IntArrayRef", 
    finput = "Tensor", fgrad_input = "Tensor")
nd_args <- c("grad_input", "grad_weight", "grad_bias", "grad_output", "self", 
"weight", "kernel_size", "stride", "padding", "finput", "fgrad_input"
)
return_types <- list(list("Tensor", "Tensor", "Tensor"))
call_c_function(
fun_name = 'thnn_conv2d_backward_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_thnn_conv2d_forward <- function(self, weight, kernel_size, bias, stride, padding) {
  args <- rlang::env_get_list(nms = c("self", "weight", "kernel_size", "bias", "stride", "padding"))
expected_types <- list(self = "Tensor", weight = "Tensor", kernel_size = "IntArrayRef", 
    bias = "Tensor", stride = "IntArrayRef", padding = "IntArrayRef")
nd_args <- c("self", "weight", "kernel_size", "bias", "stride", "padding"
)
return_types <- list(list("Tensor", "Tensor", "Tensor"))
call_c_function(
fun_name = 'thnn_conv2d_forward',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_thnn_conv2d_forward_out <- function(output, finput, fgrad_input, self, weight, kernel_size, bias, stride, padding) {
  args <- rlang::env_get_list(nms = c("output", "finput", "fgrad_input", "self", "weight", "kernel_size", "bias", "stride", "padding"))
expected_types <- list(output = "Tensor", finput = "Tensor", fgrad_input = "Tensor", 
    self = "Tensor", weight = "Tensor", kernel_size = "IntArrayRef", 
    bias = "Tensor", stride = "IntArrayRef", padding = "IntArrayRef")
nd_args <- c("output", "finput", "fgrad_input", "self", "weight", "kernel_size", 
"bias", "stride", "padding")
return_types <- list(list("Tensor", "Tensor", "Tensor"))
call_c_function(
fun_name = 'thnn_conv2d_forward_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_thnn_conv2d_out <- function(out, self, weight, kernel_size, bias = list(), stride = 1, padding = 0) {
  args <- rlang::env_get_list(nms = c("out", "self", "weight", "kernel_size", "bias", "stride", "padding"))
expected_types <- list(out = "Tensor", self = "Tensor", weight = "Tensor", kernel_size = "IntArrayRef", 
    bias = "Tensor", stride = "IntArrayRef", padding = "IntArrayRef")
nd_args <- c("out", "self", "weight", "kernel_size")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'thnn_conv2d_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_threshold <- function(self, threshold, value) {
  args <- rlang::env_get_list(nms = c("self", "threshold", "value"))
expected_types <- list(self = "Tensor", threshold = "Scalar", value = "Scalar")
nd_args <- c("self", "threshold", "value")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'threshold',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_threshold_ <- function(self, threshold, value) {
  args <- rlang::env_get_list(nms = c("self", "threshold", "value"))
expected_types <- list(self = "Tensor", threshold = "Scalar", value = "Scalar")
nd_args <- c("self", "threshold", "value")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'threshold_',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_threshold_backward <- function(grad_output, self, threshold) {
  args <- rlang::env_get_list(nms = c("grad_output", "self", "threshold"))
expected_types <- list(grad_output = "Tensor", self = "Tensor", threshold = "Scalar")
nd_args <- c("grad_output", "self", "threshold")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'threshold_backward',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_threshold_out <- function(out, self, threshold, value) {
  args <- rlang::env_get_list(nms = c("out", "self", "threshold", "value"))
expected_types <- list(out = "Tensor", self = "Tensor", threshold = "Scalar", value = "Scalar")
nd_args <- c("out", "self", "threshold", "value")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'threshold_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_to_dense_backward <- function(grad, input) {
  args <- rlang::env_get_list(nms = c("grad", "input"))
expected_types <- list(grad = "Tensor", input = "Tensor")
nd_args <- c("grad", "input")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'to_dense_backward',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_to_mkldnn_backward <- function(grad, input) {
  args <- rlang::env_get_list(nms = c("grad", "input"))
expected_types <- list(grad = "Tensor", input = "Tensor")
nd_args <- c("grad", "input")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'to_mkldnn_backward',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_topk <- function(self, k, dim = -1, largest = TRUE, sorted = TRUE) {
  args <- rlang::env_get_list(nms = c("self", "k", "dim", "largest", "sorted"))
expected_types <- list(self = "Tensor", k = "int64_t", dim = "int64_t", largest = "bool", 
    sorted = "bool")
nd_args <- c("self", "k")
return_types <- list(list("Tensor", "Tensor"))
call_c_function(
fun_name = 'topk',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_topk_out <- function(values, indices, self, k, dim = -1, largest = TRUE, sorted = TRUE) {
  args <- rlang::env_get_list(nms = c("values", "indices", "self", "k", "dim", "largest", "sorted"))
expected_types <- list(values = "Tensor", indices = "Tensor", self = "Tensor", 
    k = "int64_t", dim = "int64_t", largest = "bool", sorted = "bool")
nd_args <- c("values", "indices", "self", "k")
return_types <- list(list("Tensor", "Tensor"))
call_c_function(
fun_name = 'topk_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_trace <- function(self) {
  args <- rlang::env_get_list(nms = c("self"))
expected_types <- list(self = "Tensor")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'trace',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_transpose <- function(self, dim0, dim1) {
  args <- rlang::env_get_list(nms = c("self", "dim0", "dim1"))
expected_types <- list(self = "Tensor", dim0 = c("int64_t", "Dimname"), dim1 = c("int64_t", 
"Dimname"))
nd_args <- c("self", "dim0", "dim1")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'transpose',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_trapz <- function(y, dx = 1, x, dim = -1) {
  args <- rlang::env_get_list(nms = c("y", "dx", "x", "dim"))
expected_types <- list(y = "Tensor", dx = "double", x = "Tensor", dim = "int64_t")
nd_args <- c("y", "x")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'trapz',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_triangular_solve <- function(self, A, upper = TRUE, transpose = FALSE, unitriangular = FALSE) {
  args <- rlang::env_get_list(nms = c("self", "A", "upper", "transpose", "unitriangular"))
expected_types <- list(self = "Tensor", A = "Tensor", upper = "bool", transpose = "bool", 
    unitriangular = "bool")
nd_args <- c("self", "A")
return_types <- list(list("Tensor", "Tensor"))
call_c_function(
fun_name = 'triangular_solve',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_triangular_solve_out <- function(X, M, self, A, upper = TRUE, transpose = FALSE, unitriangular = FALSE) {
  args <- rlang::env_get_list(nms = c("X", "M", "self", "A", "upper", "transpose", "unitriangular"))
expected_types <- list(X = "Tensor", M = "Tensor", self = "Tensor", A = "Tensor", 
    upper = "bool", transpose = "bool", unitriangular = "bool")
nd_args <- c("X", "M", "self", "A")
return_types <- list(list("Tensor", "Tensor"))
call_c_function(
fun_name = 'triangular_solve_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_tril <- function(self, diagonal = 0) {
  args <- rlang::env_get_list(nms = c("self", "diagonal"))
expected_types <- list(self = "Tensor", diagonal = "int64_t")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'tril',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_tril_indices <- function(row, col, offset = 0, options = torch_long()) {
  args <- rlang::env_get_list(nms = c("row", "col", "offset", "options"))
expected_types <- list(row = "int64_t", col = "int64_t", offset = "int64_t", options = "TensorOptions")
nd_args <- c("row", "col")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'tril_indices',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_tril_out <- function(out, self, diagonal = 0) {
  args <- rlang::env_get_list(nms = c("out", "self", "diagonal"))
expected_types <- list(out = "Tensor", self = "Tensor", diagonal = "int64_t")
nd_args <- c("out", "self")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'tril_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_triplet_margin_loss <- function(anchor, positive, negative, margin = 1.000000, p = 2, eps = 0.000001, swap = FALSE, reduction = torch_reduction_mean()) {
  args <- rlang::env_get_list(nms = c("anchor", "positive", "negative", "margin", "p", "eps", "swap", "reduction"))
expected_types <- list(anchor = "Tensor", positive = "Tensor", negative = "Tensor", 
    margin = "double", p = "double", eps = "double", swap = "bool", 
    reduction = "int64_t")
nd_args <- c("anchor", "positive", "negative")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'triplet_margin_loss',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_triu <- function(self, diagonal = 0) {
  args <- rlang::env_get_list(nms = c("self", "diagonal"))
expected_types <- list(self = "Tensor", diagonal = "int64_t")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'triu',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_triu_indices <- function(row, col, offset = 0, options = torch_long()) {
  args <- rlang::env_get_list(nms = c("row", "col", "offset", "options"))
expected_types <- list(row = "int64_t", col = "int64_t", offset = "int64_t", options = "TensorOptions")
nd_args <- c("row", "col")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'triu_indices',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_triu_out <- function(out, self, diagonal = 0) {
  args <- rlang::env_get_list(nms = c("out", "self", "diagonal"))
expected_types <- list(out = "Tensor", self = "Tensor", diagonal = "int64_t")
nd_args <- c("out", "self")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'triu_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_true_divide <- function(self, other) {
  args <- rlang::env_get_list(nms = c("self", "other"))
expected_types <- list(self = "Tensor", other = c("Tensor", "Scalar"))
nd_args <- c("self", "other")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'true_divide',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_true_divide_out <- function(out, self, other) {
  args <- rlang::env_get_list(nms = c("out", "self", "other"))
expected_types <- list(out = "Tensor", self = "Tensor", other = "Tensor")
nd_args <- c("out", "self", "other")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'true_divide_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_trunc <- function(self) {
  args <- rlang::env_get_list(nms = c("self"))
expected_types <- list(self = "Tensor")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'trunc',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_trunc_ <- function(self) {
  args <- rlang::env_get_list(nms = c("self"))
expected_types <- list(self = "Tensor")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'trunc_',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_trunc_out <- function(out, self) {
  args <- rlang::env_get_list(nms = c("out", "self"))
expected_types <- list(out = "Tensor", self = "Tensor")
nd_args <- c("out", "self")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'trunc_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_unbind <- function(self, dim = 0) {
  args <- rlang::env_get_list(nms = c("self", "dim"))
expected_types <- list(self = "Tensor", dim = c("int64_t", "Dimname"))
nd_args <- "self"
return_types <- list(list('TensorList'))
call_c_function(
fun_name = 'unbind',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_unique_consecutive <- function(self, return_inverse = FALSE, return_counts = FALSE, dim = NULL) {
  args <- rlang::env_get_list(nms = c("self", "return_inverse", "return_counts", "dim"))
expected_types <- list(self = "Tensor", return_inverse = "bool", return_counts = "bool", 
    dim = "int64_t")
nd_args <- "self"
return_types <- list(list("Tensor", "Tensor", "Tensor"))
call_c_function(
fun_name = 'unique_consecutive',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_unique_dim <- function(self, dim, sorted = TRUE, return_inverse = FALSE, return_counts = FALSE) {
  args <- rlang::env_get_list(nms = c("self", "dim", "sorted", "return_inverse", "return_counts"))
expected_types <- list(self = "Tensor", dim = "int64_t", sorted = "bool", return_inverse = "bool", 
    return_counts = "bool")
nd_args <- c("self", "dim")
return_types <- list(list("Tensor", "Tensor", "Tensor"))
call_c_function(
fun_name = 'unique_dim',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_unique_dim_consecutive <- function(self, dim, return_inverse = FALSE, return_counts = FALSE) {
  args <- rlang::env_get_list(nms = c("self", "dim", "return_inverse", "return_counts"))
expected_types <- list(self = "Tensor", dim = "int64_t", return_inverse = "bool", 
    return_counts = "bool")
nd_args <- c("self", "dim")
return_types <- list(list("Tensor", "Tensor", "Tensor"))
call_c_function(
fun_name = 'unique_dim_consecutive',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_unsqueeze <- function(self, dim) {
  args <- rlang::env_get_list(nms = c("self", "dim"))
expected_types <- list(self = "Tensor", dim = "int64_t")
nd_args <- c("self", "dim")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'unsqueeze',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_upsample_bicubic2d <- function(self, output_size, align_corners, scales_h = NULL, scales_w = NULL) {
  args <- rlang::env_get_list(nms = c("self", "output_size", "align_corners", "scales_h", "scales_w"))
expected_types <- list(self = "Tensor", output_size = "IntArrayRef", align_corners = "bool", 
    scales_h = "double", scales_w = "double")
nd_args <- c("self", "output_size", "align_corners")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'upsample_bicubic2d',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_upsample_bicubic2d_backward <- function(grad_output, output_size, input_size, align_corners, scales_h = NULL, scales_w = NULL) {
  args <- rlang::env_get_list(nms = c("grad_output", "output_size", "input_size", "align_corners", "scales_h", "scales_w"))
expected_types <- list(grad_output = "Tensor", output_size = "IntArrayRef", input_size = "IntArrayRef", 
    align_corners = "bool", scales_h = "double", scales_w = "double")
nd_args <- c("grad_output", "output_size", "input_size", "align_corners"
)
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'upsample_bicubic2d_backward',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_upsample_bicubic2d_backward_out <- function(grad_input, grad_output, output_size, input_size, align_corners, scales_h = NULL, scales_w = NULL) {
  args <- rlang::env_get_list(nms = c("grad_input", "grad_output", "output_size", "input_size", "align_corners", "scales_h", "scales_w"))
expected_types <- list(grad_input = "Tensor", grad_output = "Tensor", output_size = "IntArrayRef", 
    input_size = "IntArrayRef", align_corners = "bool", scales_h = "double", 
    scales_w = "double")
nd_args <- c("grad_input", "grad_output", "output_size", "input_size", "align_corners"
)
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'upsample_bicubic2d_backward_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_upsample_bicubic2d_out <- function(out, self, output_size, align_corners, scales_h = NULL, scales_w = NULL) {
  args <- rlang::env_get_list(nms = c("out", "self", "output_size", "align_corners", "scales_h", "scales_w"))
expected_types <- list(out = "Tensor", self = "Tensor", output_size = "IntArrayRef", 
    align_corners = "bool", scales_h = "double", scales_w = "double")
nd_args <- c("out", "self", "output_size", "align_corners")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'upsample_bicubic2d_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_upsample_bilinear2d <- function(self, output_size, align_corners, scales_h = NULL, scales_w = NULL) {
  args <- rlang::env_get_list(nms = c("self", "output_size", "align_corners", "scales_h", "scales_w"))
expected_types <- list(self = "Tensor", output_size = "IntArrayRef", align_corners = "bool", 
    scales_h = "double", scales_w = "double")
nd_args <- c("self", "output_size", "align_corners")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'upsample_bilinear2d',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_upsample_bilinear2d_backward <- function(grad_output, output_size, input_size, align_corners, scales_h = NULL, scales_w = NULL) {
  args <- rlang::env_get_list(nms = c("grad_output", "output_size", "input_size", "align_corners", "scales_h", "scales_w"))
expected_types <- list(grad_output = "Tensor", output_size = "IntArrayRef", input_size = "IntArrayRef", 
    align_corners = "bool", scales_h = "double", scales_w = "double")
nd_args <- c("grad_output", "output_size", "input_size", "align_corners"
)
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'upsample_bilinear2d_backward',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_upsample_bilinear2d_backward_out <- function(grad_input, grad_output, output_size, input_size, align_corners, scales_h = NULL, scales_w = NULL) {
  args <- rlang::env_get_list(nms = c("grad_input", "grad_output", "output_size", "input_size", "align_corners", "scales_h", "scales_w"))
expected_types <- list(grad_input = "Tensor", grad_output = "Tensor", output_size = "IntArrayRef", 
    input_size = "IntArrayRef", align_corners = "bool", scales_h = "double", 
    scales_w = "double")
nd_args <- c("grad_input", "grad_output", "output_size", "input_size", "align_corners"
)
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'upsample_bilinear2d_backward_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_upsample_bilinear2d_out <- function(out, self, output_size, align_corners, scales_h = NULL, scales_w = NULL) {
  args <- rlang::env_get_list(nms = c("out", "self", "output_size", "align_corners", "scales_h", "scales_w"))
expected_types <- list(out = "Tensor", self = "Tensor", output_size = "IntArrayRef", 
    align_corners = "bool", scales_h = "double", scales_w = "double")
nd_args <- c("out", "self", "output_size", "align_corners")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'upsample_bilinear2d_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_upsample_linear1d <- function(self, output_size, align_corners, scales = NULL) {
  args <- rlang::env_get_list(nms = c("self", "output_size", "align_corners", "scales"))
expected_types <- list(self = "Tensor", output_size = "IntArrayRef", align_corners = "bool", 
    scales = "double")
nd_args <- c("self", "output_size", "align_corners")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'upsample_linear1d',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_upsample_linear1d_backward <- function(grad_output, output_size, input_size, align_corners, scales = NULL) {
  args <- rlang::env_get_list(nms = c("grad_output", "output_size", "input_size", "align_corners", "scales"))
expected_types <- list(grad_output = "Tensor", output_size = "IntArrayRef", input_size = "IntArrayRef", 
    align_corners = "bool", scales = "double")
nd_args <- c("grad_output", "output_size", "input_size", "align_corners"
)
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'upsample_linear1d_backward',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_upsample_linear1d_backward_out <- function(grad_input, grad_output, output_size, input_size, align_corners, scales = NULL) {
  args <- rlang::env_get_list(nms = c("grad_input", "grad_output", "output_size", "input_size", "align_corners", "scales"))
expected_types <- list(grad_input = "Tensor", grad_output = "Tensor", output_size = "IntArrayRef", 
    input_size = "IntArrayRef", align_corners = "bool", scales = "double")
nd_args <- c("grad_input", "grad_output", "output_size", "input_size", "align_corners"
)
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'upsample_linear1d_backward_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_upsample_linear1d_out <- function(out, self, output_size, align_corners, scales = NULL) {
  args <- rlang::env_get_list(nms = c("out", "self", "output_size", "align_corners", "scales"))
expected_types <- list(out = "Tensor", self = "Tensor", output_size = "IntArrayRef", 
    align_corners = "bool", scales = "double")
nd_args <- c("out", "self", "output_size", "align_corners")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'upsample_linear1d_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_upsample_nearest1d <- function(self, output_size, scales = NULL) {
  args <- rlang::env_get_list(nms = c("self", "output_size", "scales"))
expected_types <- list(self = "Tensor", output_size = "IntArrayRef", scales = "double")
nd_args <- c("self", "output_size")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'upsample_nearest1d',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_upsample_nearest1d_backward <- function(grad_output, output_size, input_size, scales = NULL) {
  args <- rlang::env_get_list(nms = c("grad_output", "output_size", "input_size", "scales"))
expected_types <- list(grad_output = "Tensor", output_size = "IntArrayRef", input_size = "IntArrayRef", 
    scales = "double")
nd_args <- c("grad_output", "output_size", "input_size")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'upsample_nearest1d_backward',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_upsample_nearest1d_backward_out <- function(grad_input, grad_output, output_size, input_size, scales = NULL) {
  args <- rlang::env_get_list(nms = c("grad_input", "grad_output", "output_size", "input_size", "scales"))
expected_types <- list(grad_input = "Tensor", grad_output = "Tensor", output_size = "IntArrayRef", 
    input_size = "IntArrayRef", scales = "double")
nd_args <- c("grad_input", "grad_output", "output_size", "input_size")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'upsample_nearest1d_backward_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_upsample_nearest1d_out <- function(out, self, output_size, scales = NULL) {
  args <- rlang::env_get_list(nms = c("out", "self", "output_size", "scales"))
expected_types <- list(out = "Tensor", self = "Tensor", output_size = "IntArrayRef", 
    scales = "double")
nd_args <- c("out", "self", "output_size")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'upsample_nearest1d_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_upsample_nearest2d <- function(self, output_size, scales_h = NULL, scales_w = NULL) {
  args <- rlang::env_get_list(nms = c("self", "output_size", "scales_h", "scales_w"))
expected_types <- list(self = "Tensor", output_size = "IntArrayRef", scales_h = "double", 
    scales_w = "double")
nd_args <- c("self", "output_size")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'upsample_nearest2d',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_upsample_nearest2d_backward <- function(grad_output, output_size, input_size, scales_h = NULL, scales_w = NULL) {
  args <- rlang::env_get_list(nms = c("grad_output", "output_size", "input_size", "scales_h", "scales_w"))
expected_types <- list(grad_output = "Tensor", output_size = "IntArrayRef", input_size = "IntArrayRef", 
    scales_h = "double", scales_w = "double")
nd_args <- c("grad_output", "output_size", "input_size")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'upsample_nearest2d_backward',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_upsample_nearest2d_backward_out <- function(grad_input, grad_output, output_size, input_size, scales_h = NULL, scales_w = NULL) {
  args <- rlang::env_get_list(nms = c("grad_input", "grad_output", "output_size", "input_size", "scales_h", "scales_w"))
expected_types <- list(grad_input = "Tensor", grad_output = "Tensor", output_size = "IntArrayRef", 
    input_size = "IntArrayRef", scales_h = "double", scales_w = "double")
nd_args <- c("grad_input", "grad_output", "output_size", "input_size")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'upsample_nearest2d_backward_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_upsample_nearest2d_out <- function(out, self, output_size, scales_h = NULL, scales_w = NULL) {
  args <- rlang::env_get_list(nms = c("out", "self", "output_size", "scales_h", "scales_w"))
expected_types <- list(out = "Tensor", self = "Tensor", output_size = "IntArrayRef", 
    scales_h = "double", scales_w = "double")
nd_args <- c("out", "self", "output_size")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'upsample_nearest2d_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_upsample_nearest3d <- function(self, output_size, scales_d = NULL, scales_h = NULL, scales_w = NULL) {
  args <- rlang::env_get_list(nms = c("self", "output_size", "scales_d", "scales_h", "scales_w"))
expected_types <- list(self = "Tensor", output_size = "IntArrayRef", scales_d = "double", 
    scales_h = "double", scales_w = "double")
nd_args <- c("self", "output_size")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'upsample_nearest3d',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_upsample_nearest3d_backward <- function(grad_output, output_size, input_size, scales_d = NULL, scales_h = NULL, scales_w = NULL) {
  args <- rlang::env_get_list(nms = c("grad_output", "output_size", "input_size", "scales_d", "scales_h", "scales_w"))
expected_types <- list(grad_output = "Tensor", output_size = "IntArrayRef", input_size = "IntArrayRef", 
    scales_d = "double", scales_h = "double", scales_w = "double")
nd_args <- c("grad_output", "output_size", "input_size")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'upsample_nearest3d_backward',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_upsample_nearest3d_backward_out <- function(grad_input, grad_output, output_size, input_size, scales_d = NULL, scales_h = NULL, scales_w = NULL) {
  args <- rlang::env_get_list(nms = c("grad_input", "grad_output", "output_size", "input_size", "scales_d", "scales_h", "scales_w"))
expected_types <- list(grad_input = "Tensor", grad_output = "Tensor", output_size = "IntArrayRef", 
    input_size = "IntArrayRef", scales_d = "double", scales_h = "double", 
    scales_w = "double")
nd_args <- c("grad_input", "grad_output", "output_size", "input_size")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'upsample_nearest3d_backward_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_upsample_nearest3d_out <- function(out, self, output_size, scales_d = NULL, scales_h = NULL, scales_w = NULL) {
  args <- rlang::env_get_list(nms = c("out", "self", "output_size", "scales_d", "scales_h", "scales_w"))
expected_types <- list(out = "Tensor", self = "Tensor", output_size = "IntArrayRef", 
    scales_d = "double", scales_h = "double", scales_w = "double")
nd_args <- c("out", "self", "output_size")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'upsample_nearest3d_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_upsample_trilinear3d <- function(self, output_size, align_corners, scales_d = NULL, scales_h = NULL, scales_w = NULL) {
  args <- rlang::env_get_list(nms = c("self", "output_size", "align_corners", "scales_d", "scales_h", "scales_w"))
expected_types <- list(self = "Tensor", output_size = "IntArrayRef", align_corners = "bool", 
    scales_d = "double", scales_h = "double", scales_w = "double")
nd_args <- c("self", "output_size", "align_corners")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'upsample_trilinear3d',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_upsample_trilinear3d_backward <- function(grad_output, output_size, input_size, align_corners, scales_d = NULL, scales_h = NULL, scales_w = NULL) {
  args <- rlang::env_get_list(nms = c("grad_output", "output_size", "input_size", "align_corners", "scales_d", "scales_h", "scales_w"))
expected_types <- list(grad_output = "Tensor", output_size = "IntArrayRef", input_size = "IntArrayRef", 
    align_corners = "bool", scales_d = "double", scales_h = "double", 
    scales_w = "double")
nd_args <- c("grad_output", "output_size", "input_size", "align_corners"
)
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'upsample_trilinear3d_backward',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_upsample_trilinear3d_backward_out <- function(grad_input, grad_output, output_size, input_size, align_corners, scales_d = NULL, scales_h = NULL, scales_w = NULL) {
  args <- rlang::env_get_list(nms = c("grad_input", "grad_output", "output_size", "input_size", "align_corners", "scales_d", "scales_h", "scales_w"))
expected_types <- list(grad_input = "Tensor", grad_output = "Tensor", output_size = "IntArrayRef", 
    input_size = "IntArrayRef", align_corners = "bool", scales_d = "double", 
    scales_h = "double", scales_w = "double")
nd_args <- c("grad_input", "grad_output", "output_size", "input_size", "align_corners"
)
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'upsample_trilinear3d_backward_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_upsample_trilinear3d_out <- function(out, self, output_size, align_corners, scales_d = NULL, scales_h = NULL, scales_w = NULL) {
  args <- rlang::env_get_list(nms = c("out", "self", "output_size", "align_corners", "scales_d", "scales_h", "scales_w"))
expected_types <- list(out = "Tensor", self = "Tensor", output_size = "IntArrayRef", 
    align_corners = "bool", scales_d = "double", scales_h = "double", 
    scales_w = "double")
nd_args <- c("out", "self", "output_size", "align_corners")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'upsample_trilinear3d_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_var <- function(self, dim, unbiased = TRUE, keepdim = FALSE) {
  args <- rlang::env_get_list(nms = c("self", "dim", "unbiased", "keepdim"))
expected_types <- list(self = "Tensor", dim = c("IntArrayRef", "DimnameList"), 
    unbiased = "bool", keepdim = "bool")
nd_args <- c("self", "dim")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'var',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_var_mean <- function(self, dim, unbiased = TRUE, keepdim = FALSE) {
  args <- rlang::env_get_list(nms = c("self", "dim", "unbiased", "keepdim"))
expected_types <- list(self = "Tensor", dim = c("IntArrayRef", "DimnameList"), 
    unbiased = "bool", keepdim = "bool")
nd_args <- c("self", "dim")
return_types <- list(list("Tensor", "Tensor"))
call_c_function(
fun_name = 'var_mean',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_var_out <- function(out, self, dim, unbiased = TRUE, keepdim = FALSE) {
  args <- rlang::env_get_list(nms = c("out", "self", "dim", "unbiased", "keepdim"))
expected_types <- list(out = "Tensor", self = "Tensor", dim = c("IntArrayRef", 
"DimnameList"), unbiased = "bool", keepdim = "bool")
nd_args <- c("out", "self", "dim")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'var_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_where <- function(condition, self, other) {
  args <- rlang::env_get_list(nms = c("condition", "self", "other"))
expected_types <- list(condition = "Tensor", self = "Tensor", other = "Tensor")
nd_args <- c("condition", "self", "other")
return_types <- list(list('Tensor'), list('TensorList'))
call_c_function(
fun_name = 'where',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_zero_ <- function(self) {
  args <- rlang::env_get_list(nms = c("self"))
expected_types <- list(self = "Tensor")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'zero_',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


.torch_zeros <- function(size, names, options = list()) {
  args <- rlang::env_get_list(nms = c("size", "names", "options"))
expected_types <- list(size = "IntArrayRef", names = "DimnameList", options = "TensorOptions")
nd_args <- c("size", "names")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'zeros',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


.torch_zeros_like <- function(self, options = list(), memory_format = NULL) {
  args <- rlang::env_get_list(nms = c("self", "options", "memory_format"))
expected_types <- list(self = "Tensor", options = "TensorOptions", memory_format = "MemoryFormat")
nd_args <- "self"
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'zeros_like',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}


torch_zeros_out <- function(out, size) {
  args <- rlang::env_get_list(nms = c("out", "size"))
expected_types <- list(out = "Tensor", size = "IntArrayRef")
nd_args <- c("out", "size")
return_types <- list(list('Tensor'))
call_c_function(
fun_name = 'zeros_out',
args = args,
expected_types = expected_types,
nd_args = nd_args,
return_types = return_types,
fun_type = 'namespace'
)
}

